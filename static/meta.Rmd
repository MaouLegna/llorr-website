---
title: "Meta & Decks (from Patch 2.18 onward)"
author: "by Legna"
base_url: https://www.llorr-stats.com
output:
  flexdashboard::flex_dashboard:
    navbar:
      - { icon: "fa-trophy", text: "MatchUps", href: "https://www.llorr-stats.com/static/mu.html", align: right }
      - { icon: "fa-home", href: "https://www.llorr-stats.com", align: right }
    # orientation: columns
    # vertical_layout: fill
    orientation: row
    vertical_layout: fill
# date: "`r Sys.Date()`"
params:
  # start: "2021-06-02 17:00:00" #UTC tz / 2.09 <- Balance Patch
  # start:   "2021-06-30 17:00:00" #UTC tz / 2.11 <- Rose of the Underworld
  # start: "2021-07-14 17:00:00" #UTC tz / 2.12 <- Ruination Event
  # end: "2021-08-25 17:00:00" #UTC tz / 2.14 <- Bandle Release
  # start: "2021-09-01 17:00:00" #UTC tz / 2.14 <- World Patch to 2.18 ( one week later because of world patch )
  start:   "2021-10-20 17:00:00" #UTC tz / 2.18 <- Balance Patch
  end:   "2022-01-01 17:00:00" #UTC tz /
  # skip:  2800000  # Patch 2.14
  # skip:  3500000  # Patch 2.18
  # hrs: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  eval = TRUE,
  warning = FALSE,
  error = FALSE,
  message = FALSE,
  comment = NA,
  R.options = list(width = 140,
                   digits.secs=6),
  dev.args = list(bg = 'transparent'), # make graphics with transparent background
  fig.align = 'center',
  fig.width=12,
  fig.height=8,
  engine.path = list(
    python = 'C:/anaconda/'   # -> use_python("C:/anaconda/")
  ),
  #'distill options
  layout="l-body-outset",
  preview=FALSE
)

#' R Option
options(scipen = 999)
source(file.path("C:","LlorR","scripts","lor_main.R" ))
# xaringanExtra::use_panelset()

# pacman::p_load(tidyverse,data.table,DT,reactable,crosstalk,
#                flextable,officer,scales,htmltools,
#                downloadthis)
```

```{r load-data}
#' load gameDT
#'############
# file.DT <- file.path("C:","LlorR","data","raw","LoR_MatchDT.csv")
# header        <- fread(file.DT, header = FALSE, na.strings = c("",NA), nrows = 1, stringsAsFactors = FALSE)
# LoR.Match.RMD <- fread(file.DT, header = FALSE, na.strings = c("",NA), skip = params$skip )
# colnames(LoR.Match.RMD) <- unlist(header,use.names = F)

#' load Games DT
#'##############
LoR.Match.RMD <- fread(file.path("C:","LlorR","data","raw","LoR_MatchDT.csv"), header = T, na.strings = c("", NA))

#' Read New Master
##################
LoR.LastMaster.RMD <- fread(file.path("C:","LlorR","data","raw","LoR_TempDT.csv"), header = T, na.strings = c("",NA))

#' load Account
#'#############
LoR.Account.RMD <- fread(file.path("C:","LlorR","data","raw","LoR_ACCOUNT.csv"), header=T, na.strings = c("",NA), encoding = 'UTF-8') |>
  mutate( RiotID = glue::glue("{gameName}#{tagLine}"))

#' load DeckDT
#'############
LoR.Deck.RMD        <- fread(file.path("C:","LlorR","data","raw","LoR_DECK.csv"),na.strings = c("",NA))
```

```{r constants}
# Precalculate user score colors to be used for custom cell rendering
get_score_color <- function(score) {
  blue_pal <- function(x) rgb(colorRamp(c("#9fc7df", "#416ea4"))(x), maxColorValue = 255)
  normalized <- score/100
  blue_pal(normalized)
}

LastUpdate.box <- flexdashboard::valueBox(Sys.Date(),
                                          caption = glue::glue("Last Update / Usually done around 5:00 UTC / 7:00 CET"),
                                          icon = "fa-clock",
                                          # color = "lightgreen"
                                          color = "#1A9850")

n = 15   # if I want to select a fixed number of underdog decks
p = 0.01 # if I want to use the standard meta deck threshold
```

```{r archetype-fix}
#' Limit the Deck DT to make the fixes much faster
deck_filter <- rbind(LoR.Match.RMD,LoR.LastMaster.RMD) |>
  #' Base filters
  filter( game_type=="Ranked" ) |>
  filter( game_start_time_utc > as.POSIXct(params$start, tz = "UTC") ) |>
  select(deck_code_1,deck_code_2) |>
  pivot_longer( cols = contains("deck_code"),values_to = "decks" ) |>
  filter(decks!="") |>
  distinct(decks)

LoR.Deck.RMD <- LoR.Deck.RMD[deck_code %in% deck_filter$decks]

#' Archetype-Fix
#'##############
source(file.path("C:","LlorR","scripts","functions","lor_archetype_rmd.R"))

# LoR.Deck.RMD[ ,tabyl(archetype_pretty) ]

#' Archetype names fix
######################
LoR.Deck.RMD[ !is.na(archetype_pretty), archetype:=archetype_pretty ]
```

```{r process-data}
#' Metl tbl
#'#########
LoR.Melt.Matches.RMD <- LoR.Match.RMD |>
  filter( game_type=="Ranked" ) |>
  filter( game_start_time_utc > as.POSIXct(params$start, tz = "UTC") ) |>
  select( -ends_with("_3"),-ends_with("_4")  ) |>
  left_join(LoR.Deck.RMD[,.(deck_code,playerDeck_1=archetype)],  by=c("deck_code_1"="deck_code")) |>
  left_join(LoR.Deck.RMD[,.(deck_code,opponentDeck_1=archetype)],by=c("deck_code_2"="deck_code")) |>
  rename( playerPuuid_1 = puuid_1, playerPuuid_2 = puuid_2 ) |>
  mutate( playerDeck_2 = opponentDeck_1, opponentDeck_2 = playerDeck_1, opponentPuuid_1 = playerPuuid_2, opponentPuuid_2 = playerPuuid_1 ) |>
  pivot_longer(cols = c(ends_with("_1"),ends_with("_2")),
               names_to = c(".value"),
               names_pattern = "(.*)_[0-9]"
  ) |>
  #' finish 'process' data
  left_join(LoR.Account.RMD[,.(puuid,playerID=RiotID)]   ,by=c("playerPuuid"="puuid")) |>
  left_join(LoR.Account.RMD[,.(puuid,opponentID=RiotID)] ,by=c("opponentPuuid"="puuid")) |>
  left_join(LoR.Deck.RMD |> select(!archetype),by=c("deck_code","factions")) |>
  as.data.table()

# LoR.Melt.Matches.RMD <- LoR.Melt.Matches.RMD[ !(is.na(playerDeck) | is.na(opponentDeck)) ]
```

```{r prepare-data-2}
#' Additional tbl
#' contain the a second DT
#' can be Plat+, or Diamond depending on my current project
#'#########################################################
LoR.Melt.Extra.RMD <- LoR.LastMaster.RMD |>
  filter( game_type=="Ranked" ) |>
  filter( game_start_time_utc > as.POSIXct(params$start, tz = "UTC") ) |>
  select( -ends_with("_3"),-ends_with("_4")  ) |>
  left_join(LoR.Deck.RMD[,.(deck_code,playerDeck_1=archetype)],  by=c("deck_code_1"="deck_code")) |>
  left_join(LoR.Deck.RMD[,.(deck_code,opponentDeck_1=archetype)],by=c("deck_code_2"="deck_code")) |>
  rename( playerPuuid_1 = puuid_1, playerPuuid_2 = puuid_2 ) |>
  mutate( playerDeck_2 = opponentDeck_1, opponentDeck_2 = playerDeck_1, opponentPuuid_1 = playerPuuid_2, opponentPuuid_2 = playerPuuid_1 ) |>
  pivot_longer(cols = c(ends_with("_1"),ends_with("_2")),
               names_to = c(".value"),
               names_pattern = "(.*)_[0-9]"
  ) |>
  #' finish 'process' data
  left_join(LoR.Account.RMD[,.(puuid,playerID=RiotID)]   ,by=c("playerPuuid"="puuid")) |>
  left_join(LoR.Account.RMD[,.(puuid,opponentID=RiotID)] ,by=c("opponentPuuid"="puuid")) |>
  left_join(LoR.Deck.RMD |> select(!archetype),by=c("deck_code","factions")) |>
  as.data.table()
```

# Stats (whole Patch) {data-icon="fa-table"}

```{r process-winRate}
WR.DT <- LoR.Melt.Matches.RMD |>
  filter(game_outcome!="tie") |>
  select(playerDeck,opponentDeck,game_outcome ) |>
  group_by(playerDeck) |>
  summarise( 
    nWin   = sum(game_outcome=="win"),
    nGames = n(),
    WR=mean(game_outcome=="win")
  ) |>
  ungroup() |>
  mutate( 
    playrate = nGames/sum(nGames)
  ) |>
  as.data.table() |>
  {\(x) x[ ,c("LCI","UCI") := binom.confint(nWin,nGames,0.95,methods="exact")[5:6] ] }() |>
  mutate( CI := glue("({percent(LCI,accuracy = 0.1)} - {percent(UCI,accuracy = 0.1)})" ) )

WR.DT.Reg <- LoR.Melt.Matches.RMD |>
  filter(game_outcome!="tie") |>
  select( playerDeck,opponentDeck,game_outcome,server ) |>
  group_by(server,playerDeck) |>
  summarise( 
    nWin   = sum(game_outcome=="win"),
    nGames = n(),
    WR=mean(game_outcome=="win")
  ) |>
  ungroup() |>
  group_by(server) |>
  mutate( sumGames = sum(nGames), regPlayrate = nGames/sumGames ) |>
  ungroup() |>
  left_join(WR.DT[,c("playerDeck","playrate")],by="playerDeck") 

fct_meta <- WR.DT |>
  filter(playrate > p) |>
  arrange(desc(nGames)) |>
  pull(playerDeck)

fct_underdog <- WR.DT |>
  filter( nGames >= 50 & WR >= 0.50 & playrate >= 0.001 & playrate < 0.01) |>
  arrange(desc(n)) |>
  pull(playerDeck)
```
## Row

### Decks Performances

```{r create-support-tbl}
deckCodeTbl  <- LoR.Melt.Matches.RMD |>
  filter( playerDeck %in% c(fct_meta,fct_underdog) ) |>
  mutate( playerDeck = factor(playerDeck, ordered = TRUE,
                              levels = c(fct_meta,fct_underdog) )
          ) |>
  group_by(server,playerDeck,deck_code ) |>
  summarise( n = n() ) |>
  slice_max(n, n = 3) |>
  ungroup() |>
  # select( playerDeck,deck_code, nGames=n ) |>
  mutate( link = glue::glue("<a href='https://runeterra.ar/decks/code/{deck_code}'>{deck_code}</a>"),
          server = str_to_title(server) ) |>
  # rename_all(~c("Server","Archetype","DeckCode","nGames")) |>
  select(playerDeck,n,link,server)
  # select( nGames = n, DeckCode = deck_code, Archetype = playerDeck, Server = server )

serverWRTbl <- WR.DT.Reg |>
  filter( playerDeck %in% c(fct_meta,fct_underdog) ) |>
  as.data.table() |>
  mutate(
    type = case_when(
      playerDeck %in% fct_meta ~ "Meta",
      playerDeck %in% fct_underdog ~ "Underdog",
      TRUE ~ "other"
    )
  ) |>
  {\(x) x[ ,c("LCI","UCI") := binom.confint(nWin,nGames,0.95,methods="exact")[5:6] ] }() |>
  mutate( 
    server = str_to_title(server),
    CI := glue("({percent(LCI,accuracy = 0.1)} - {percent(UCI,accuracy = 0.1)})" )
    ) |>
  arrange(desc(playrate)) |>
  select(playerDeck,WR,nWin,nGames,regPlayrate,CI,server)
```
```{r react-stats-master}
reactDT <- WR.DT |>
  filter( playerDeck %in% c(fct_meta,fct_underdog) ) |>
  mutate(
    type = case_when(
      playerDeck %in% fct_meta ~ "Meta",
      playerDeck %in% fct_underdog ~ "Underdog",
      TRUE ~ "other"
    ),
    PR_ind    = scale_quantile(playrate),
    WR_ind    = scale_quantile(WR),
    LMI = map2_dbl(.x =PR_ind,.y =WR_ind, ~harm.mean(c(.x,.y) )  ),
    tier = case_when( 
     LMI >= 0.975 ~ "Tier0",
     0.85 <= LMI & LMI < 0.975 ~ "Tier1",
     0.60 <= LMI & LMI < 0.85 ~ "Tier2",
     LMI < 0.60 ~ "Tier3 or lower"
    ),
    LMI = round(LMI*100)
  ) |>
  arrange(desc(playrate)) |>
  select(playerDeck,WR,nWin,nGames,playrate,LMI,tier,CI,type) |>
  mutate(score_color = get_score_color(LMI))

reactDT |> 
  reactable(
    # groupBy = "playerDeck",
    searchable = TRUE,
    bordered = TRUE,
    # wrap = FALSE,
    highlight = TRUE,
    striped = TRUE,
    pagination = FALSE,
    fullWidth = T,
    defaultSorted = list(LMI = "desc"),
    defaultColDef = colDef(
      align = "center",
      minWidth = 100,
      # headerStyle = list(background = "steelblue",color="white")
    ),
    details = function(index) {
      # index = 1
      deckdata <- deckCodeTbl[ deckCodeTbl$playerDeck == reactDT$playerDeck[index], ]
      reactable(
        deckdata,
        fullWidth = F,
        defaultColDef = colDef( 
          style = list( fontSize = 13 ),
          html = TRUE
          ),
        theme = reactableTheme( headerStyle = list(background = "red",color="white", fontSize = 13 ) ),
        columns = list(
          n = colDef(name = "#Games", minWidth = 75 ),
          link = colDef(name = "DeckCode - Most played lists", minWidth = 750, style = list( fontSize = 9 ) ),
          # playerDeck = colDef(name = "Archetype", minWidth = 150 ),
          playerDeck = colDef(show = F),
          server = colDef(name = "Server", minWidth = 100 )
          ) )},
    columns = list(
      playerDeck = colDef(name = "Archetype",minWidth = 250,align = "left"),
      nWin   = colDef(name = "#Win"),
      nGames = colDef(name = "#Games"),
      playrate = colDef(name = "PlayRate", format = colFormat(percent = TRUE,digits = 1) ),
      type = colDef(name = "Type"),
      # LMI = colDef(name = "LMI"),
      tier = colDef(name = "Tier",minWidth = 200,align = "left"),
      CI = colDef(name = "Conf.Interval",minWidth = 200,align = "center"),
      LMI = colDef(
        name = "LMI",
        defaultSortOrder = "desc",
        # Show the user score in a donut chart like TMDb does. Since donut charts
        # are hard to compare, apply a color scale as well.
        cell = JS("function(cellInfo) {
                  const sliceColor = cellInfo.row['score_color']
                  const sliceLength = 2 * Math.PI * 24
                  const sliceOffset = sliceLength * (1 - cellInfo.value / 100)
                  const donutChart = (
                  '<svg width=60 height=60 style=\"transform: rotate(-90deg)\" focusable=false>' +
                  '<circle cx=30 cy=30 r=24 fill=none stroke-width=4 stroke=rgba(0,0,0,0.1)></circle>' +
                  '<circle cx=30 cy=30 r=24 fill=none stroke-width=4 stroke=' + sliceColor +
                  ' stroke-dasharray=' + sliceLength + ' stroke-dashoffset=' + sliceOffset + '></circle>' +
                  '</svg>'
                  )
                  const label = '<div style=\"position: absolute; top: 50%; left: 50%; ' +
                  'transform: translate(-50%, -50%)\">' + cellInfo.value + '</div>'
                  return '<div style=\"display: inline-flex; position: relative\">' + donutChart + label + '</div>'
                  }"),
        html = TRUE,
        align = "center",
        width = 140,
        class = "user-score"
        ),
      score_color = colDef(show = F),
      WR     = colDef(name = "WinRate",
                      format = colFormat(percent = TRUE,digits = 1),
                      details = function(index) {
                        wrdata <- serverWRTbl[ serverWRTbl$playerDeck == reactDT$playerDeck[index], ]
                        htmltools::div(style = "padding: 10px",
                                       reactable(
                                         wrdata,
                                         fullWidth = FALSE,
                                         theme = reactableTheme( headerStyle = list(background = "green",color="white", fontSize = 12 ) ),
                                         defaultColDef = colDef( 
                                           style = list( fontSize = 12, align = "center" )
                                           # html = TRUE
                                           ),
                                         columns = list(
                                           playerDeck = colDef(name = "Archetype",minWidth = 250,align = "left"),
                                           WR = colDef(name = "WinRate", format = colFormat(percent = TRUE,digits = 1) ),
                                           nWin   = colDef(name = "#Win"),
                                           nGames = colDef(name = "#Games"),
                                           regPlayrate = colDef(name = "PlayRate", format = colFormat(percent = TRUE,digits = 1) ),
                                           CI = colDef(name = "Conf.Interval",minWidth = 200,align = "center"),
                                           server = colDef(name = "Server",align = "left")
                                         )
                                         )
                                       ) } )
    )
  ) |>
  reactablefmtr::add_source(glue::glue("Data from Current Master Only. Source: Metadata of games collected with RiotGames API"), background_color = "transparent", font_family = "Chivo")
```
## Row {data-heigth="150"}

### Number of Games

```{r value-games}
flexdashboard::valueBox(glue::glue("{NROW(LoR.Melt.Matches.RMD)} Games"),
                        caption = glue::glue("Number of Ranked Games"),
                        icon = "fa-table",
                        color = "#a88b32")
```

### Number of Meta Decks

```{r value-meta}
flexdashboard::valueBox(glue::glue("{length(fct_meta)} Meta Decks"),
                        caption = glue::glue("Decks with PlayRate with at least 1%"),
                        icon = "fa-trophy",
                        color = "#65c0a9")
```

### Number of Underdog Decks

```{r value-underdog}
flexdashboard::valueBox(glue::glue("{length(fct_underdog)} Underdog Decks"),
                        caption = glue::glue("Decks with positive WR and PR in 0.1% to 1%"),
                        icon = "fa-dog",
                        color = "#ff7f24")
```

### Last Update

```{r}
LastUpdate.box
```

# Stats (last 7days) {data-icon="fa-table"}

```{r 7days-process-winRate}
WR.DT.d7 <- LoR.Melt.Matches.RMD |>
  filter( game_start_time_utc >= Sys.Date()+hours(18)-days(7) ) |>
  filter(game_outcome!="tie") |>
  select(playerDeck,opponentDeck,game_outcome ) |>
  group_by(playerDeck) |>
  summarise( 
    nWin   = sum(game_outcome=="win"),
    nGames = n(),
    WR=mean(game_outcome=="win")
  ) |>
  ungroup() |>
  mutate( 
    playrate = nGames/sum(nGames)
  ) |>
  as.data.table() |>
  {\(x) x[ ,c("LCI","UCI") := binom.confint(nWin,nGames,0.95,methods="exact")[5:6] ] }() |>
  mutate( CI := glue("({percent(LCI,accuracy = 0.1)} - {percent(UCI,accuracy = 0.1)})" ) )
  
WR.DT.Reg.d7 <- LoR.Melt.Matches.RMD |>
  filter( game_start_time_utc >= Sys.Date()+hours(18)-days(7) ) |>
  filter(game_outcome!="tie") |>
  select( playerDeck,opponentDeck,game_outcome,server ) |>
  group_by(server,playerDeck) |>
  summarise( 
    nWin   = sum(game_outcome=="win"),
    nGames = n(),
    WR=mean(game_outcome=="win")
  ) |>
  ungroup() |>
  group_by(server) |>
  mutate( sumGames = sum(nGames), regPlayrate = nGames/sumGames ) |>
  ungroup() |>
  left_join(WR.DT.d7[,c("playerDeck","playrate")],by="playerDeck") 

fct_meta.d7 <- WR.DT.d7 |>
  filter(playrate > p) |>
  arrange(desc(nGames)) |>
  pull(playerDeck)

fct_underdog.d7 <- WR.DT.d7 |>
  filter( nGames >= 50 & WR >= 0.50 & playrate >= 0.001 & playrate < 0.01) |>
  arrange(desc(n)) |>
  pull(playerDeck)
```
## Row

### Decks Performances

```{r 7days-create-support-tbl}
deckCodeTbl.d7  <- LoR.Melt.Matches.RMD |>
  filter( game_start_time_utc >= Sys.Date()+hours(18)-days(7) ) |>
  filter( playerDeck %in% c(fct_meta.d7,fct_underdog.d7) ) |>
  mutate( playerDeck = factor(playerDeck, ordered = TRUE,
                              levels = c(fct_meta.d7,fct_underdog.d7) )
          ) |>
  group_by(server,playerDeck,deck_code ) |>
  summarise( n = n() ) |>
  slice_max(n, n = 3) |>
  ungroup() |>
  mutate( link = glue::glue("<a href='https://runeterra.ar/decks/code/{deck_code}'>{deck_code}</a>"),
          server = str_to_title(server) ) |>
  select(playerDeck,n,link,server)
  
serverWRTbl.d7 <- WR.DT.Reg.d7 |>
  filter( playerDeck %in% c(fct_meta.d7,fct_underdog.d7) ) |>
  as.data.table() |>
  mutate(
    type = case_when(
      playerDeck %in% fct_meta ~ "Meta",
      playerDeck %in% fct_underdog ~ "Underdog",
      TRUE ~ "other"
    )
  ) |>
  {\(x) x[ ,c("LCI","UCI") := binom.confint(nWin,nGames,0.95,methods="exact")[5:6] ] }() |>
  mutate( 
    server = str_to_title(server),
    CI := glue("({percent(LCI,accuracy = 0.1)} - {percent(UCI,accuracy = 0.1)})" )
    ) |>
  arrange(desc(playrate)) |>
  select(playerDeck,WR,nWin,nGames,regPlayrate,CI,server)
```


```{r 7days-react-stats-master}
reactDT.d7 <- WR.DT.d7 |>
  filter( playerDeck %in% c(fct_meta.d7,fct_underdog.d7) ) |>
  mutate(
    type = case_when(
      playerDeck %in% fct_meta.d7 ~ "Meta",
      playerDeck %in% fct_underdog.d7 ~ "Underdog",
      TRUE ~ "other"
    ),
    PR_ind    = scale_quantile(playrate),
    WR_ind    = scale_quantile(WR),
    LMI = map2_dbl(.x =PR_ind,.y =WR_ind, ~harm.mean(c(.x,.y) )  ),
    tier = case_when( 
     LMI >= 0.975 ~ "Tier0",
     0.85 <= LMI & LMI < 0.975 ~ "Tier1",
     0.60 <= LMI & LMI < 0.85 ~ "Tier2",
     LMI < 0.60 ~ "Tier3 or lower"
    ),
    LMI = round(LMI*100)
  ) |>
  arrange(desc(playrate)) |>
  select(playerDeck,WR,nWin,nGames,playrate,LMI,tier,CI,type) |>
  mutate(score_color = get_score_color(LMI))

reactDT.d7 |> 
  reactable(
    # groupBy = "playerDeck",
    searchable = TRUE,
    bordered = TRUE,
    # wrap = FALSE,
    highlight = TRUE,
    striped = TRUE,
    pagination = FALSE,
    fullWidth = T,
    defaultSorted = list(LMI = "desc"),
    defaultColDef = colDef(
      align = "center",
      minWidth = 100,
      # headerStyle = list(background = "steelblue",color="white")
    ),
    details = function(index) {
      # index = 1
      deckdata <- deckCodeTbl.d7[ deckCodeTbl.d7$playerDeck == reactDT.d7$playerDeck[index], ]
      reactable(
        deckdata,
        fullWidth = F,
        defaultColDef = colDef( 
          style = list( fontSize = 13 ),
          html = TRUE
          ),
        theme = reactableTheme( headerStyle = list(background = "red",color="white", fontSize = 13 ) ),
        columns = list(
          n = colDef(name = "#Games", minWidth = 75 ),
          link = colDef(name = "DeckCode - Most played lists", minWidth = 750, style = list( fontSize = 9 ) ),
          # playerDeck = colDef(name = "Archetype", minWidth = 150 ),
          playerDeck = colDef(show = F),
          server = colDef(name = "Server", minWidth = 100 )
          ) )},
    columns = list(
      playerDeck = colDef(name = "Archetype",minWidth = 250,align = "left"),
      nWin   = colDef(name = "#Win"),
      nGames = colDef(name = "#Games"),
      playrate = colDef(name = "PlayRate", format = colFormat(percent = TRUE,digits = 1) ),
      type = colDef(name = "Type"),
      # LMI = colDef(name = "LMI"),
      tier = colDef(name = "Tier",minWidth = 200,align = "left"),
      CI = colDef(name = "Conf.Interval",minWidth = 200,align = "center"),
      LMI = colDef(
        name = "LMI",
        defaultSortOrder = "desc",
        # Show the user score in a donut chart like TMDb does. Since donut charts
        # are hard to compare, apply a color scale as well.
        cell = JS("function(cellInfo) {
                  const sliceColor = cellInfo.row['score_color']
                  const sliceLength = 2 * Math.PI * 24
                  const sliceOffset = sliceLength * (1 - cellInfo.value / 100)
                  const donutChart = (
                  '<svg width=60 height=60 style=\"transform: rotate(-90deg)\" focusable=false>' +
                  '<circle cx=30 cy=30 r=24 fill=none stroke-width=4 stroke=rgba(0,0,0,0.1)></circle>' +
                  '<circle cx=30 cy=30 r=24 fill=none stroke-width=4 stroke=' + sliceColor +
                  ' stroke-dasharray=' + sliceLength + ' stroke-dashoffset=' + sliceOffset + '></circle>' +
                  '</svg>'
                  )
                  const label = '<div style=\"position: absolute; top: 50%; left: 50%; ' +
                  'transform: translate(-50%, -50%)\">' + cellInfo.value + '</div>'
                  return '<div style=\"display: inline-flex; position: relative\">' + donutChart + label + '</div>'
                  }"),
        html = TRUE,
        align = "center",
        width = 140,
        class = "user-score"
        ),
      score_color = colDef(show = F),
      WR     = colDef(name = "WinRate",
                      format = colFormat(percent = TRUE,digits = 1),
                      details = function(index) {
                        wrdata <- serverWRTbl.d7[ serverWRTbl.d7$playerDeck == reactDT.d7$playerDeck[index], ]
                        htmltools::div(style = "padding: 10px",
                                       reactable(
                                         wrdata,
                                         fullWidth = FALSE,
                                         theme = reactableTheme( headerStyle = list(background = "green",color="white", fontSize = 12 ) ),
                                         defaultColDef = colDef( 
                                           style = list( fontSize = 12, align = "center" )
                                           # html = TRUE
                                           ),
                                         columns = list(
                                           playerDeck = colDef(name = "Archetype",minWidth = 250,align = "left"),
                                           WR = colDef(name = "WinRate", format = colFormat(percent = TRUE,digits = 1) ),
                                           nWin   = colDef(name = "#Win"),
                                           nGames = colDef(name = "#Games"),
                                           regPlayrate = colDef(name = "PlayRate", format = colFormat(percent = TRUE,digits = 1) ),
                                           CI = colDef(name = "Conf.Interval",minWidth = 200,align = "center"),
                                           server = colDef(name = "Server",align = "left")
                                         )
                                         )
                                       ) } )
    )
  ) |>
  reactablefmtr::add_source(glue::glue("Data from Current Master Only. Source: Metadata of games collected with RiotGames API"), background_color = "transparent", font_family = "Chivo")
```
## Row {data-heigth="150"}

### Number of Games

```{r 7days-value-games}
nGames7 <- LoR.Melt.Matches.RMD |>
  filter( game_start_time_utc >= Sys.Date()+hours(18)-days(7) ) |>
  NROW()

flexdashboard::valueBox(glue::glue("{nGames7} Games"),
                        caption = glue::glue("Number of Ranked Games"),
                        icon = "fa-table",
                        color = "#a88b32")
```

### Number of Meta Decks

```{r 7days-value-meta}
flexdashboard::valueBox(glue::glue("{length(fct_meta.d7)} Meta Decks"),
                        caption = glue::glue("Decks with PlayRate with at least 1%"),
                        icon = "fa-trophy",
                        color = "#65c0a9")
```

### Number of Underdog Decks

```{r 7days-value-underdog}
flexdashboard::valueBox(glue::glue("{length(fct_underdog.d7)} Underdog Decks"),
                        caption = glue::glue("Decks with positive WR and PR in 0.1% to 1%"),
                        icon = "fa-dog",
                        color = "#ff7f24")
```

### Last-Update

```{r 7days-value-update}
LastUpdate.box
```

# Fresh Stats (last 24 hours) {data-icon="fa-table"}

## Row

### Previous Day

```{r 24hrs-process-winRate}
LoR.Melt.24hrs <- LoR.Melt.Matches.RMD |>
  filter( 
      game_start_time_utc >= Sys.Date()+hours(18)-days(2) &
      game_start_time_utc <  Sys.Date()+hours(18)-days(1)
      )

WR.DT.24h <- LoR.Melt.24hrs |>
  filter(game_outcome!="tie") |>
  # select(playerDeck,opponentDeck,game_outcome ) |>
  # filter( playerDeck == "Ezreal/Karma" ) |> tabyl(playerID)
  group_by(playerDeck) |>
  summarise(
    nWin   = sum(game_outcome=="win"),
    nGames = n(),
    WR=mean(game_outcome=="win")
  ) |>
  ungroup() |>
  mutate(
    playrate = nGames/sum(nGames)
  ) |>
  as.data.table() |>
  {\(x) x[ ,c("LCI","UCI") := binom.confint(nWin,nGames,0.95,methods="exact")[5:6] ] }() |>
  mutate( CI := glue("({percent(LCI,accuracy = 0.1)} - {percent(UCI,accuracy = 0.1)})" ) ) |>
  filter( playerDeck %!in% c(fct_meta,fct_meta.d7,fct_underdog,fct_underdog.d7) ) |>
  filter( WR > 0.5 & nGames > 10 ) |>
  select(-LCI,-UCI) 

deckCodeTbl.24hrs  <- LoR.Melt.24hrs |>
  filter( playerDeck %in% c(WR.DT.24h$playerDeck) ) |>
  mutate( playerDeck = factor(playerDeck, ordered = TRUE,
                              levels = c(WR.DT.24h$playerDeck) )
          ) |>
  group_by(server,playerDeck,deck_code ) |>
  summarise( n = n() ) |>
  ungroup() |>
  group_by(playerDeck) |>
  slice_max(n, n = 10) |>
  ungroup() |>
  mutate( link = glue::glue("<a href='https://runeterra.ar/decks/code/{deck_code}'>{deck_code}</a>"),
          server = str_to_title(server) ) |>
  select(playerDeck,n,link,server)
```


```{r 24hrs-react-winRate}
with_tooltip <- function(value, tooltip) {
  htmltools::tags$abbr(style = "text-decoration: underline; text-decoration-style: dotted; cursor: help",
            title = tooltip, value)
}

WR.DT.24h |>
  reactable(
    # groupBy = "playerDeck",
    searchable = TRUE,
    bordered = TRUE,
    # wrap = FALSE,
    highlight = TRUE,
    striped = TRUE,
    pagination = FALSE,
    fullWidth = T,
    # defaultSorted = list(LMI = "desc"),
    defaultColDef = colDef(
      align = "center",
      minWidth = 100,
      # headerStyle = list(background = "steelblue",color="white")
    ),
    details = function(index) {
      # index = 1
      deckdata <- deckCodeTbl.24hrs[ deckCodeTbl.24hrs$playerDeck == WR.DT.24h$playerDeck[index], ]
      reactable(
        deckdata,
        fullWidth = F,
        defaultColDef = colDef(
          style = list( fontSize = 13 ),
          html = TRUE
          ),
        theme = reactableTheme( headerStyle = list(background = "red",color="white", fontSize = 13 ) ),
        columns = list(
          n = colDef(name = "#Games", minWidth = 75 ),
          link = colDef(name = "DeckCode - Most played lists", minWidth = 750, style = list( fontSize = 9 ) ),
          # playerDeck = colDef(name = "Archetype", minWidth = 150 ),
          playerDeck = colDef(show = F),
          server = colDef(name = "Server", minWidth = 100 )
          ) )},
    columns = list(
      playerDeck = colDef(name = "Archetype",minWidth = 250,align = "left",header = with_tooltip("Archetype", "I still have to decide what to display here, so for now I'll simply but the decks with at least 10 games, before WR that did't appear in the other sections (whole-Patch and 7days).")),
      nWin   = colDef(name = "#Win"),
      nGames = colDef(name = "#Games"),
      playrate = colDef(name = "PlayRate", format = colFormat(percent = TRUE,digits = 1) ),
      type = colDef(name = "Type"),
      # LMI = colDef(name = "LMI"),
      tier = colDef(name = "Tier",minWidth = 200,align = "left"),
      CI = colDef(name = "Conf.Interval",minWidth = 200,align = "center"),
      # LMI = colDef(
      #   name = "LMI",
      #   defaultSortOrder = "desc",
      #   # Show the user score in a donut chart like TMDb does. Since donut charts
      #   # are hard to compare, apply a color scale as well.
      #   cell = JS("function(cellInfo) {
      #             const sliceColor = cellInfo.row['score_color']
      #             const sliceLength = 2 * Math.PI * 24
      #             const sliceOffset = sliceLength * (1 - cellInfo.value / 100)
      #             const donutChart = (
      #             '<svg width=60 height=60 style=\"transform: rotate(-90deg)\" focusable=false>' +
      #             '<circle cx=30 cy=30 r=24 fill=none stroke-width=4 stroke=rgba(0,0,0,0.1)></circle>' +
      #             '<circle cx=30 cy=30 r=24 fill=none stroke-width=4 stroke=' + sliceColor +
      #             ' stroke-dasharray=' + sliceLength + ' stroke-dashoffset=' + sliceOffset + '></circle>' +
      #             '</svg>'
      #             )
      #             const label = '<div style=\"position: absolute; top: 50%; left: 50%; ' +
      #             'transform: translate(-50%, -50%)\">' + cellInfo.value + '</div>'
      #             return '<div style=\"display: inline-flex; position: relative\">' + donutChart + label + '</div>'
      #             }"),
      #   html = TRUE,
      #   align = "center",
      #   width = 140,
      #   class = "user-score"
      #   ),
      # score_color = colDef(show = F),
      WR = colDef(name = "WinRate", format = colFormat(percent = TRUE,digits = 1) )
      # WR     = colDef(name = "WinRate",
      #                 format = colFormat(percent = TRUE,digits = 1),
      #                 details = function(index) {
      #                   wrdata <- serverWRTbl[ serverWRTbl$playerDeck == reactDT$playerDeck[index], ]
      #                   htmltools::div(style = "padding: 10px",
      #                                  reactable(
      #                                    wrdata,
      #                                    fullWidth = FALSE,
      #                                    theme = reactableTheme( headerStyle = list(background = "green",color="white", fontSize = 12 ) ),
      #                                    defaultColDef = colDef( 
      #                                      style = list( fontSize = 12, align = "center" )
      #                                      # html = TRUE
      #                                      ),
      #                                    columns = list(
      #                                      playerDeck = colDef(name = "Archetype",minWidth = 250,align = "left"),
      #                                      WR = colDef(name = "WinRate", format = colFormat(percent = TRUE,digits = 1) ),
      #                                      nWin   = colDef(name = "#Win"),
      #                                      nGames = colDef(name = "#Games"),
      #                                      regPlayrate = colDef(name = "PlayRate", format = colFormat(percent = TRUE,digits = 1) ),
      #                                      CI = colDef(name = "Conf.Interval",minWidth = 200,align = "center"),
      #                                      server = colDef(name = "Server",align = "left")
      #                                    )
      #                                    )
      #                                  ) } )
    )
    
  )
  # reactablefmtr::add_source(element_text(glue::glue("Data from Last-Season Master Only.
  #                                                   Source: Source: Metadata of games collected with RiotGames API")), background_color = "transparent", font_family = "Chivo")

```

## Row {data-heigth="150"}


### Time Frame

```{r}
flexdashboard::valueBox(glue::glue("24 Hours Time Frame"),
                        caption = glue::glue("from {Sys.Date()+hours(18)-days(2)} to {Sys.Date()+hours(18)-days(1)}"),
                        icon = "fa-clock",
                        # color = "lightgreen"
                        color = "red")
```


### Last Update


```{r}
LastUpdate.box
```


# Meta-Evolution {data-icon="fa-chart-line"}

## Row {data-heigth="750"}

```{r meta-evo-const}
ntopPR <- 12
# seqDate <- seq(as.Date(params$start), as.Date(now())-days(1), "day")
seqDate <- seq(as.POSIXct(params$start, tz = "UTC"),floor_date(now(),unit = "day")-days(1)+hours(18) ,"day") #
```

```{r}
top7days <- LoR.Melt.Matches.RMD |>
  filter( game_start_time_utc >= Sys.Date()+hours(18)-days(7) ) |>
  count(playerDeck) |>
  slice_max(n,n=ntopPR,with_ties = F) |>
  pull(playerDeck)

Champion.deck.daily <- tibble(
  game_start_time_utc = rep(seqDate, each = length(top7days)),
  playerDeck = rep(top7days, times = length(seqDate) ),
  intDate = findInterval(game_start_time_utc, seqDate )
) |>
  left_join(
    LoR.Melt.Matches.RMD |>
      mutate( playerDeck = fct_other(playerDeck,keep = top7days) |> fct_infreq(),
              intDate = findInterval(game_start_time_utc, seqDate )
      ) |>
      filter( playerDeck != "Other" ) |>
      group_by(intDate) |>
      count(playerDeck) |>
      mutate(freq = prop.table(n))|>
      ungroup(),
    by = c("playerDeck","intDate") ) |>
  mutate( across(where(is.numeric), ~replace_na(.x, 0)) ) |>
  mutate( game_start_time_utc = as.Date(game_start_time_utc) )
  

# top7days <- LoR.Melt.Matches.RMD |>
#   filter( game_start_time_utc >= Sys.Date()+hours(18)-days(7) ) |>
#   count(playerDeck) |>
#   slice_max(n,n=ntopPR,with_ties = F) |>
#   pull(playerDeck)
# 
# Champion.deck.daily <- tibble( 
#   game_start_time_utc = rep(seqDate, each = length(top7days)),
#   playerDeck = rep(top7days, times = length(seqDate))
# ) |>
#   left_join(
#     LoR.Melt.Matches.RMD |>
#       mutate( 
#         playerDeck = fct_other(playerDeck,keep = top7days) |> fct_infreq(),
#         game_start_time_utc = as.Date(game_start_time_utc) 
#         ) |>
#       filter( playerDeck != "Other" ) |>
#       group_by(game_start_time_utc) |>
#       count(playerDeck) |>
#       mutate(freq = prop.table(n))|>
#       ungroup(),
#     by = c("game_start_time_utc","playerDeck") ) |>
#   mutate( across(where(is.numeric), ~replace_na(.x, 0)) )
```

```{r prepare-meta-evo-extra}
top7days.extra <- LoR.Melt.Extra.RMD |>
  filter( game_start_time_utc >= now()-days(7) ) |>
  count(playerDeck) |>
  slice_max(n,n=ntopPR,with_ties = F) |>
  pull(playerDeck)

Champion.deck.daily.extra <- tibble( 
  game_start_time_utc = rep(seqDate, each = length(top7days.extra)),
  playerDeck = rep(top7days.extra, times = length(seqDate)),
  intDate = findInterval(game_start_time_utc, seqDate )
) |>
  left_join(
    LoR.Melt.Extra.RMD |>
      mutate( 
        playerDeck = fct_other(playerDeck,keep = top7days.extra) |> fct_infreq(),
        intDate = findInterval(game_start_time_utc, seqDate )
        ) |>
      filter( playerDeck != "Other" ) |>
      group_by(intDate) |>
      count(playerDeck) |>
      mutate(freq = prop.table(n))|>
      ungroup(),
    by = c("playerDeck","intDate") ) |>
  mutate( across(where(is.numeric), ~replace_na(.x, 0)) ) |>
  mutate( game_start_time_utc = as.Date(game_start_time_utc) )
```

```{r create-meta-evo, fig.width=12, fig.height=8, include=F}
meta_evo.base <- Champion.deck.daily |>
  ggplot( aes(game_start_time_utc, freq, group = playerDeck) ) +
  geom_line( aes(color = playerDeck), size = .9  ) +
  # geom_text( aes(label=str_to_upper(playerDeck),color = playerDeck)  ) +
  scale_x_date(
    # date_minor_breaks = "2 day", # not working
    limits = c(as.Date(params$start, tz="UTC"),  as.Date(now()+days(3)) )
  )  +
  scale_y_continuous(
    expand = c(0, 0),
    # limits = c(0,signif.ceiling(max(Champion.deck.daily$freq),1)),
    # breaks = seq(0,signif.ceiling(max(Champion.deck.daily$freq),1),signif.ceiling(max(Champion.deck.daily$freq),1)/5),
    limits = c(0,0.25),
    breaks = seq(0,0.25,0.05),
    labels = scales::percent_format(accuracy = 1) # glue::glue("{format(seq(0, 0.20, by = 0.05), nsmall = 2)}%")
  )  +
  labs(x = "Date",
       y = "PlayRate",
       title = "(Master) Evolution of Play Rate over time",
       caption = glue::glue("{params$patch}
                            Ranked games from {params$start} UTC to {params$end} UTC
                            Metadata of games collected with RiotGames API")
  ) +
  theme_539() +
  theme( legend.position = "none",
         axis.text = element_text(size = 10, face = "bold", color = "grey50")
  ) +
  # scale_color_manual( values = sample(colorRampPalette(brewer.pal(8, "Dark2"))(30),15) )
  # scale_color_manual( values = safe_colorblind_palette )
  scale_color_manual( values = rcartocolor::carto_pal(12, "Safe") ) +
  scale_fill_manual(values = setNames(rcartocolor::carto_pal(12, "Safe"), unique(Champion.deck.daily$playerDeck)  ) )

meta_evo.base + geom_label_repel(
    data = Champion.deck.daily |> filter( game_start_time_utc >= now()-days(2) ), 
    aes(label=str_to_upper(playerDeck),color = playerDeck ),
    fontface = "bold",
    family = "Helvetica",
    size = 3.5,
    
    force = 20,
    force_pull = 0.5,
    
    nudge_x      = 0.15,
    direction    = "y",
    hjust        = 0,
    # vjust        = 0.5,
    segment.size = 0.5,
    
    segment.alpha = .5,
    segment.linetype = "dotted",
    box.padding = .4,
    segment.curvature = -0.1,
    segment.ncp = 3,
    segment.angle = 15,
    bg.color = "grey",
    fill = "#f0f0f0",
    label.padding = 0,
    label.size = 0,
    # xlim = c( floor_date(Sys.Date()-days(1)), floor_date(Sys.Date()-days(1)) )
    # xlim = c(floor_date(Sys.Date()-hours(12)), floor_date(Sys.Date()) )
    xlim = c(as.Date(Sys.Date()), as.Date(Sys.Date()+days(4)) )
  ) + 
  plot_annotation(caption = glue::glue('Days starts at 18:00:00 UTC time of X day to 18:00:00 UTC time of X+1 day. During solar-time 18:00 UTC seems to be the release time of LoR content. Any detected changes will be reported.
                                       Source: Metadata of games collected with RiotGames API'))

ggsave("./images/meta-evo.png",width = 12,height = 8)
```

```{r create-meta-evo-extra, fig.width=12, fig.height=8, include=FALSE}
meta_evo.extra.base <- Champion.deck.daily.extra |>
  mutate( game_start_time_utc = as.Date(game_start_time_utc) ) |>
  ggplot( aes(game_start_time_utc, freq, group = playerDeck) ) +
  geom_line( aes(color = playerDeck), size = .9  ) +
  scale_x_date(
    # date_minor_breaks = "1 day",
    limits = c(as.Date(params$start, tz="UTC"),  as.Date(now()+days(3)) )
  )  +
  scale_y_continuous(
    expand = c(0, 0),
    # limits = c(0,signif.ceiling(max(Champion.deck.daily.extra$freq),1)),
    # breaks = seq(0,signif.ceiling(max(Champion.deck.daily.extra$freq),1),signif.ceiling(max(Champion.deck.daily.extra$freq),1)/5),
    limits = c(0,0.25),
    breaks = seq(0,0.25,0.05),
    labels = scales::percent_format(accuracy = 1) # glue::glue("{format(seq(0, 0.20, by = 0.05), nsmall = 2)}%")
  )  +
  labs(x = "Date",
       y = "PlayRate",
       title = "(~Plat+) Evolution of Play Rate over time",
       caption = glue::glue("{params$patch}
                            Ranked games from {params$start} UTC to {params$end} UTC
                            Games from Last Season Master.
                            Metadata of games collected with RiotGames API")
  ) +
  theme_539() +
  theme( legend.position = "none",
         axis.text = element_text(size = 10, face = "bold", color = "grey50")
  ) +
  scale_color_manual( values = rcartocolor::carto_pal(12, "Safe") ) +
  scale_fill_manual(values = setNames(rcartocolor::carto_pal(12, "Safe"), unique(Champion.deck.daily.extra$playerDeck)  ) )

meta_evo.extra.base +
  geom_label_repel(
    data = Champion.deck.daily.extra |> filter( game_start_time_utc >= now()-days(2) ), 
    aes(label=str_to_upper(playerDeck),color = playerDeck ),
    fontface = "bold",
    family = "Helvetica",
    size = 3.5,
    
    force = 20,
    force_pull = 0.5,
    
    nudge_x      = 0.15,
    direction    = "y",
    hjust        = 0,
    # vjust        = 0.5,
    segment.size = 0.5,
    
    segment.alpha = .5,
    segment.linetype = "dotted",
    box.padding = .4,
    segment.curvature = -0.1,
    segment.ncp = 3,
    segment.angle = 15,
    bg.color = "grey",
    fill = "#f0f0f0",
    label.padding = 0,
    label.size = 0,
    xlim = c(as.Date(Sys.Date()), as.Date(Sys.Date()+days(4)) )
  )

LoR.Melt.Extra.RMD |>
  filter(str_detect(playerDeck,"Jayce")) |>
  arrange(game_start_time_utc)

ggsave("./images/meta-evo-extra.png",width = 12,height = 8)
```

<!-- ### Graph -->

```{r plot-meta-evo-double, fig.width=20, fig.height=8}
meta_evo.base + 
  geom_label_repel(
    data = Champion.deck.daily |> filter( game_start_time_utc >= now()-days(2) ), 
    aes(label=str_to_upper(playerDeck),color = playerDeck ),
    fontface = "bold",
    family = "Helvetica",
    size = 2.5,
    
    force = 20,
    # force_pull = 0.5,
    
    nudge_x      = 0.15,
    direction    = "y",
    hjust        = 0,
    # vjust        = 0.5,
    segment.size = 0.5,
    
    segment.alpha = .5,
    segment.linetype = "dotted",
    box.padding = .4,
    segment.curvature = -0.1,
    segment.ncp = 3,
    segment.angle = 15,
    bg.color = "grey",
    # xlim = c( floor_date(Sys.Date()-days(1)), floor_date(Sys.Date()-days(1)) )
    # xlim = c(floor_date(Sys.Date()-hours(12)), floor_date(Sys.Date()) )
    xlim = c(as.Date(Sys.Date()), as.Date(Sys.Date()+days(4)) )
  ) +
meta_evo.extra.base +
  geom_label_repel(
    data = Champion.deck.daily.extra |> filter( game_start_time_utc >= now()-days(2) ),
    aes(label=str_to_upper(playerDeck),color = playerDeck ),
    
    fontface = "bold",
    family = "Helvetica",
    size = 2.5,
    
    force = 20,
    force_pull = 0.5,
    
    nudge_x      = 0.15,
    direction    = "y",
    hjust        = 0,
    # vjust        = 0.5,
    segment.size = 0.5,
    
    segment.alpha = .5,
    segment.linetype = "dotted",
    box.padding = .4,
    segment.curvature = -0.1,
    segment.ncp = 3,
    segment.angle = 15,
    bg.color = "grey",
    xlim = c(as.Date(Sys.Date()), as.Date(Sys.Date()+days(4)) )
  )
  # plot_annotation(caption = glue::glue('Days starts at 18:00:00 UTC time of X day to 18:00:00 UTC time of X+1 day. During solar-time 18:00 UTC seems to be the release time of LoR content. Any detected changes will be reported.
  #                                      Source: Metadata of games collected with RiotGames API'))

ggsave("./images/meta-evo-double.png",width = 19,height = 9)
```

## Row {data-heigth="150"}

### Last Update

```{r}
LastUpdate.box
```

# Downloads and Informations {data-orientation="columns" data-icon="fa-info-circle"}

## Download {data-width="200"}

### Meta-Evolution (Master)

```{r}
downloadthis::download_file(
  path = file.path("images/mugrid.png"),
  # path = system.file("assets/css/all.min.css", package = "downloadthis"),
  button_label = "Download Master PlayRates over time as .png",
  button_type = "primary",
  has_icon = TRUE,
  icon = "fa fa-save",
  self_contained = FALSE
)
```

### Meta-Evolution (~Plat+)

```{r}
downloadthis::download_file(
  path = file.path("images/meta-evo-extra.png"),
  # path = system.file("assets/css/all.min.css", package = "downloadthis"),
  button_label = "Download Plat+ PlayRates over time as .png",
  button_type = "primary",
  has_icon = TRUE,
  icon = "fa fa-save",
  self_contained = FALSE
)
```

### Meta-Evolution (Double)

```{r}
downloadthis::download_file(
  path = file.path("images/meta-evo-extra.png"),
  # path = system.file("assets/css/all.min.css", package = "downloadthis"),
  button_label = "Download (Master+Plat) PlayRates over time as .png",
  button_type = "primary",
  has_icon = TRUE,
  icon = "fa fa-save",
  self_contained = FALSE
)
```

## Column {data-width="800"}

### Archetype "fix"

current aggregations applied to archetypes (Champions+Regions)

```{r gt-archetype}
source(file.path("C:","LlorR","scripts","functions","lor_archetype_gt.R"))
gtfix
```

### LMI - Tiers

```{r info-gt-lmi}
tribble( 
  ~Tier, ~Note,
  "Tier0", "with LMI >= 97.5",
  "Tier1", "with LMI in [85,97.5)",
  "Tier2", "with LMI in [60,85)",
  "Tier3 or lower", "with LMI < 60"
  ) |>
  gt() |>
  tab_header(
    title = glue::glue("LMI Tiers")
  ) |>
  gtExtras::gt_theme_nytimes() |>
  # tab_style(
  #   style = cell_text(weight = "bold"),
  #   locations = cells_body(
  #     columns = 1,
  #   )
  # ) |>
  tab_options(
    table.background.color = "whitesmoke",
    table.font.color = "black",
    table.font.color.light = "black"
   )

```
### General info

When I refer to games it's always refering a single playerDeck. So, if I have the information of 1 match it's equivalent to 2 games.