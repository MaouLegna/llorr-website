---
title: "Meta & Decks (from Patch 2.18 onward)"
author: "by Legna"
base_url: https://www.llorr-stats.com
output:
  flexdashboard::flex_dashboard:
    navbar:
      - { icon: "fa-trophy", text: "MatchUps", href: "https://www.llorr-stats.com/static/mu.html", align: right }
      - { icon: "fa-home", href: "https://www.llorr-stats.com", align: right }
    # orientation: columns
    # vertical_layout: fill
    orientation: row
    vertical_layout: fill
# date: "`r Sys.Date()`"
params:
  # start: "2021-06-02 21:00:00" #UTC tz / 2.09 <- Balance Patch
  # start:   "2021-06-30 21:00:00" #UTC tz / 2.11 <- Rose of the Underworld
  # start: "2021-07-14 21:00:00" #UTC tz / 2.12 <- Ruination Event
  # end: "2021-08-25 21:00:00" #UTC tz / 2.14 <- Bandle Release
  # start: "2021-09-01 21:00:00" #UTC tz / 2.14 <- World Patch to 2.18 ( one week later because of world patch )
  start:   "2021-10-20 21:00:00" #UTC tz / 2.18 <- Balance Patch
  end:   "2022-01-01 21:00:00" #UTC tz /
  # skip:  2800000  # Patch 2.14
  # skip:  3500000  # Patch 2.18
  hrs: 2
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  eval = TRUE,
  warning = FALSE,
  error = FALSE,
  message = FALSE,
  comment = NA,
  R.options = list(width = 140,
                   digits.secs=6),
  dev.args = list(bg = 'transparent'), # make graphics with transparent background
  fig.align = 'center',
  fig.width=12,
  fig.height=8,
  engine.path = list(
    python = 'C:/anaconda/'   # -> use_python("C:/anaconda/")
  ),
  #'distill options
  layout="l-body-outset",
  preview=FALSE
)

#' R Option
options(scipen = 999)
source(file.path("C:","LlorR","scripts","lor_main.R" ))
# xaringanExtra::use_panelset()

# pacman::p_load(tidyverse,data.table,DT,reactable,crosstalk,
#                flextable,officer,scales,htmltools,
#                downloadthis)
```

```{r load-data}
#' load gameDT
#'############
# file.DT <- file.path("C:","LlorR","data","raw","LoR_MatchDT.csv")
# header        <- fread(file.DT, header = FALSE, na.strings = c("",NA), nrows = 1, stringsAsFactors = FALSE)
# LoR.Match.RMD <- fread(file.DT, header = FALSE, na.strings = c("",NA), skip = params$skip )
# colnames(LoR.Match.RMD) <- unlist(header,use.names = F)

#' load Games DT
#'##############
LoR.Match.RMD <- fread(file.path("C:","LlorR","data","raw","LoR_TempDT.csv"), header = T, na.strings = c("",NA) )

#' load Account
#'#############
LoR.Account.RMD <- fread(file.path("C:","LlorR","data","raw","LoR_ACCOUNT.csv"), header=T, na.strings = c("",NA), encoding = 'UTF-8') |>
  mutate( RiotID = glue::glue("{gameName}#{tagLine}"))

#' load DeckDT
#'############
LoR.Deck.RMD        <- fread(file.path("C:","LlorR","data","raw","LoR_DECK.csv"),na.strings = c("",NA))
```

```{r archetype-fix}
#' Limit the Deck DT to make the fixes much faster
deck_filter <- LoR.Match.RMD |>
  #' Base filters
  filter( game_type=="Ranked" ) |>
  filter( game_start_time_utc > as.POSIXct(params$start, tz = "UTC") ) |>
  select(deck_code_1,deck_code_2) |>
  pivot_longer( cols = contains("deck_code"),values_to = "decks" ) |>
  filter(decks!="") |>
  distinct(decks)

LoR.Deck.RMD <- LoR.Deck.RMD[deck_code %in% deck_filter$decks]

#' Archetype-Fix
#'##############
source(file.path("C:","LlorR","scripts","functions","lor_archetype_rmd.R"))
```

```{r functions}
get_deck_structure_2_meta <- function(DT = LoR.Melt.Matches.RMD, archetype, minN = 1, minP = 0, print = F ) {
  
  if (print==T) {
    message(glue::glue("Min number of games {minN}"))
    message(glue::glue("Min freq of games {minP}"))
  }
  
  # archetype = "Nami / Zoe" # fct_meta[1]
  # minN = 100
  # minP = 0
  
  #' freq Table of deckcodes for an archetype
  codeTbl <- DT |>
    filter( playerDeck == archetype ) |>
    # filter( playerDeck == "Nami / Zoe" ) |> 
    tabyl(deck_code) |>
    arrange(desc(n)) |>
    filter( n >= minN & percent >= minP )
  
  #' Number of games of an archetype / after the filters
  nGames <- codeTbl |>
    summarise( n = sum(n) ) |>
    pull()
  
  copies.cards <- codeTbl |>
    as_tibble() |>
    #' the first column of tabyl takes the value of the "tabled" variable
    #' from the table it takes the deckcode, create the get_decklist_from_code as table and repeat the result n times as in the tbl
    summarise( map2_df( .x = deck_code, .y = n , ~rep(list(lordecks::get_decklist_from_code(.x)),.y) |> rbindlist()) ) |>
    select(count,cardcode) |>
    rename_all(~c("copies","cardCode"))
  
  include.rate <- copies.cards |> 
    #' Divide copies from CardCode 
    group_by(cardCode) |>
    summarise( playrate = n() ) |>
    mutate( playrate = playrate/nGames ) |>
    select(playrate)
  
  copies.cards |> 
    rename_all(~c("Copies","Cardcode")) |>
    mutate( Copies = factor(Copies, levels = c(1,2,3)) ) |> 
    #' To the 'Nx3' table of cards and copies
    tabyl(Cardcode,Copies) |>
    adorn_percentages("row") |>
    add_column(include.rate) |>
    left_join(LoR.Set[,c("name","cardCode","rarity")],by=c("Cardcode"="cardCode")) |>
    arrange(desc(playrate),desc(`3`),desc(`2`),desc(`1`),desc(rarity)) |>
    # adorn_pct_formatting(digits = 1) |>
    select(-rarity,-Cardcode) |>
    relocate(5,4,3,2,1) |>
    add_column(archetype = archetype)
}

# deck_color_generator <- scales::col_numeric(c("white", "white","green"), domain = NULL)
make_color_pal <- function(colors, bias = 1) {
  get_color <- colorRamp(colors, bias = bias)
  function(x) rgb(get_color(x), maxColorValue = 255)
}

good_color <- make_color_pal(c("white", "white", "#9bc2e6"))
```


```{r process-data}
#' Metl tbl
#'#########
LoR.Melt.Matches.RMD <- LoR.Match.RMD |>
  filter( game_type=="Ranked" ) |>
  filter( game_start_time_utc > as.POSIXct(params$start, tz = "UTC") ) |>
  select( -ends_with("_3"),-ends_with("_4")  ) |>
  left_join(LoR.Deck.RMD[,.(deck_code,playerDeck_1=archetype)],  by=c("deck_code_1"="deck_code")) |>
  left_join(LoR.Deck.RMD[,.(deck_code,opponentDeck_1=archetype)],by=c("deck_code_2"="deck_code")) |>
  rename( playerPuuid_1 = puuid_1, playerPuuid_2 = puuid_2 ) |>
  mutate( playerDeck_2 = opponentDeck_1, opponentDeck_2 = playerDeck_1, opponentPuuid_1 = playerPuuid_2, opponentPuuid_2 = playerPuuid_1 ) |>
  pivot_longer(cols = c(ends_with("_1"),ends_with("_2")),
               names_to = c(".value"),
               names_pattern = "(.*)_[0-9]"
               ) |>
  #' finish 'process' data
  left_join(LoR.Account.RMD[,.(puuid,playerID=RiotID)]   ,by=c("playerPuuid"="puuid")) |>
  left_join(LoR.Account.RMD[,.(puuid,opponentID=RiotID)] ,by=c("opponentPuuid"="puuid")) |>
  left_join(LoR.Deck.RMD |> select(!archetype),by=c("deck_code","factions")) |>
  as.data.table()

# LoR.Melt.Matches.RMD[ is.na(playerDeck) ]
```

```{r}
ntopPR <- 15

top7days <- LoR.Melt.Matches.RMD |>
  filter( game_start_time_utc >= now()-days(7) ) |>
  count(playerDeck) |>
  slice_max(n,n=ntopPR) |>
  pull(playerDeck)

seqDate <- seq(as.Date(params$start), as.Date(now())-days(1), "day")

Champion.deck.daily <- tibble( 
  game_start_time_utc = rep(seqDate, each = length(top7days)),
  playerDeck = rep(top7days, times = length(seqDate))
  ) |>
  left_join(
    LoR.Melt.Matches.RMD |>
      mutate( playerDeck = fct_lump_n(playerDeck,n = ntopPR) |> fct_infreq(),
              game_start_time_utc = as.Date(game_start_time_utc) ) |>
      group_by(game_start_time_utc) |>
      count(playerDeck) |>
      mutate(freq = prop.table(n))|>
      ungroup(),
    by = c("game_start_time_utc","playerDeck") ) |>
  mutate( across(where(is.numeric), ~replace_na(.x, 0)) )

Champion.deck.daily |>
  mutate( game_start_time_utc = as.Date(game_start_time_utc) ) |>
  ggplot( aes(game_start_time_utc, freq, group = playerDeck) ) +
  geom_line( aes(color = playerDeck), size = .9  ) +
  # geom_text( aes(label=str_to_upper(playerDeck),color = playerDeck)  ) +
  geom_label_repel(
    data = Champion.deck.daily |>
      filter( game_start_time_utc >= now()-days(2) ),
    # data = Champion.deck.daily |> distinct(playerDeck),
    aes(label=str_to_upper(playerDeck),color = playerDeck),
    # aes(color = champions, label = champions),
    family = "Helvetica",
    # fontface = "bold",
    size = 3,
    direction = "y",
    force = 3,
    hjust = 0.5,
    segment.size = .7,
    segment.alpha = .5,
    segment.linetype = "dotted",
    box.padding = .4,
    segment.curvature = -0.1,
    segment.ncp = 3,
    segment.angle = 15,
    bg.color = "grey50",
    xlim = c(as.Date(now()), as.Date(now()+days(2)) ),
  ) +
  scale_x_date(
    # expand = c(0.02,0.01),
    # date_minor_breaks = "1 day",
    limits = c(as.Date(params$start, tz="UTC"),  as.Date(now()+days(2)) )
    # limits = c(as.POSIXct(params$start, tz="UTC"), as.POSIXct(params$end, tz="UTC"))
  )  +
  scale_y_continuous(
    expand = c(0, 0),
    limits = c(0,0.15),
    breaks = seq(0,0.15,0.02),
    labels = scales::percent_format(accuracy = 1) # glue::glue("{format(seq(0, 0.20, by = 0.05), nsmall = 2)}%")
  ) +
  scale_color_manual(
    values = c(rcartocolor::carto_pal(n = ntopPR, name = "Vivid")[1:ntopPR-1], "grey50")
  ) +
  labs(x = "Date",
       y = "PlayRate",
       title = "Evolution of Play Rate over time",
       caption = glue::glue("{params$patch}
                            Ranked games from {params$start} UTC to {params$end} UTC
                            Metadata of games collected with RiotGames API")
  ) +
  theme_539() +
  theme( legend.position = "none",
         axis.text = element_text(size = 10, face = "bold", color = "grey50")
         )

meta_evo
  

  

# ggsave(glue::glue("./images/meta-report/{params$ind}-playrate-daybyday.png"))

```

```{r plot-date-by-date}
meta_evo <- ggplot(
   # The ggplot object has associated the data for the highlighted countries
  data = Champion.deck.daily |> filter(champions %in% fct_values[-1]),
  aes(game_start_time_utc, cumFreq, group = champions)
  ) +
  ## Lines for the non-highlighted countries
  geom_line(
    data = Champion.deck.daily |> filter(champions %!in% fct_values[-1]),
    color = "grey75",
    size = .6,
    alpha = .5
  ) +
  ## Lines for the highlighted countries.
  # It's important to put them after the grey lines
  # so the colored ones are on top
  geom_line(
    aes(color = champions),
    size = .9
  ) +
  # geom_text(aes(label=champions,color = champions))
  geom_label_repel(
    data = Champion.deck.daily |> filter(champions %in% fct_values[-1]) |> group_by(champions) |> slice_max(game_start_time_utc,n=1) |> distinct(game_start_time_utc,champions,.keep_all = T),
    aes(label=str_to_upper(champions),color = champions),
    # aes(color = champions, label = champions),
    family = "Helvetica",
    # fontface = "bold",
    size = 3.5,
    direction = "y",
    xlim = c(as.POSIXct(max(Champion.deck.daily$game_start_time_utc) + hours(12)), NA),
    force = 3,
    hjust = 1,
    segment.size = .7,
    segment.alpha = .5,
    segment.linetype = "dotted",
    box.padding = .4,
    segment.curvature = -0.1,
    segment.ncp = 3,
    segment.angle = 15,
    bg.color = "grey50"
  ) +
  scale_x_datetime(
    # expand = c(0.02,0.01),
    date_minor_breaks = "1 day",
    limits = c(as.POSIXct(params$start, tz="UTC"), as.POSIXct(params$end, tz="UTC")+hours(23))
    # limits = c(as.POSIXct(params$start, tz="UTC"), as.POSIXct(params$end, tz="UTC"))
  )  +
  scale_y_continuous(
    expand = c(0, 0),
    limits = c(0,0.15),
    breaks = seq(0,0.15,0.02),
    labels = scales::percent_format(accuracy = 1) # glue::glue("{format(seq(0, 0.20, by = 0.05), nsmall = 2)}%")
  ) +
  scale_color_manual(
    values = c(rcartocolor::carto_pal(n = 10, name = "Vivid")[1:10-1], "grey50")
  ) +
  labs(x = "Date",
       y = "PlayRate",
       title = "Evolution of Play Rate over time",
       caption = glue::glue("{params$patch}
                            Ranked games from {params$start} UTC to {params$end} UTC
                            Metadata of games collected with RiotGames API")
  ) +
  theme_539() +
  theme( legend.position = "none",
         axis.text = element_text(size = 10, face = "bold", color = "grey50")
         )

meta_evo

# ggsave(glue::glue("./images/meta-report/{params$ind}-playrate-daybyday.png"))
```


```{r decks}
n = 20 # if I want to select a fixed number of underdog decks
p = 0.01 # if I want to use the standard meta deck threshold

WR.DT <- LoR.Melt.Matches.RMD |>
  filter(game_outcome!="tie") |>
  group_by(playerDeck) |>
  summarise( nWin   = sum(game_outcome=="win"),
             nGames = n(),
             WR=mean(game_outcome=="win")
            ) |>
  ungroup() |>
  mutate( playrate = nGames/sum(nGames) )

fct_meta <- WR.DT |>
  filter(playrate > p) |>
  arrange(desc(nGames)) |>
  pull(playerDeck)

fct_underdog <- WR.DT |>
  filter( nGames >= 50 & WR >= 0.50 & playrate >= 0.001 & playrate < 0.01) |>
  arrange(desc(n)) |>
  pull(playerDeck)
```

```{r shared-data}
Champion.deck.daily.byserver <- LoR.Melt.Matches.RMD |>
  rename("playerDeck"="playerDeck") |>
  arrange(game_start_time_utc) |>
  group_by(server) |>
  select(game_start_time_utc,playerDeck,server) |>
  mutate( num_cc = factor(playerDeck) |> as.numeric() ) |>
    ungroup() |> as.data.table() %>%
  .[ , playRate := (cumsum(num_cc)/num_cc)/.I , by=playerDeck ] |>
  select(!num_cc) |>
  mutate( playerDeck = factor(playerDeck) |> fct_infreq() )

#' Get last value for PR
maxFreq <- Champion.deck.daily.byserver |>
  filter( playerDeck %in% fct_meta &
            game_start_time_utc >= min(LoR.Melt.Matches.RMD$game_start_time_utc)|>as.Date()+hours(24) ) |>
  summarise( maxfreq = max(playRate) ) |>
  signif.ceiling(1) |> pull()

# options(digits.secs = 0)
Champion.deck.daily.byserver <- Champion.deck.daily.byserver |>
  mutate( game_start_time_utc = floor_date(game_start_time_utc, unit = "hours") ) |>
  group_by(game_start_time_utc,server,playerDeck) |>
  slice_head(n=1) |>
  ungroup() |>
  group_by(server,playerDeck) |>
  filter(row_number() %% params$hrs == 1) |>
  ungroup() %>%
  filter(complete.cases(.)) |>
  ungroup()

# hrs_filter <- unique(Champion.deck.daily.byserver$game_start_time_utc)[ c(rep(FALSE,params$hrs-1),TRUE) ]

keyDeckDaily <- Champion.deck.daily.byserver |>
  # filter( game_start_time_utc %in% hrs_filter  ) |>
  filter( playerDeck %in% fct_meta &
            game_start_time_utc >= min(LoR.Melt.Matches.RMD$game_start_time_utc)|>as.Date()+hours(24) ) |>
  mutate( server = str_to_title(server), playRate = round(playRate,3) ) |>
  rename(Archetype=playerDeck) |>
  highlight_key(~Archetype)
```

# Meta-Stats {data-icon="fa-table"}

```{r process-winRate}
WR.DT <- LoR.Melt.Matches.RMD |>
  filter(game_outcome!="tie") |>
  select(playerDeck,opponentDeck,game_outcome ) |>
  group_by(playerDeck) |>
  summarise( 
    nWin   = sum(game_outcome=="win"),
    nGames = n(),
    WR=mean(game_outcome=="win")
    ) |>
  ungroup() |>
  mutate( playrate = nGames/sum(nGames) )

WR.DT.Reg <- LoR.Melt.Matches.RMD |>
  filter(game_outcome!="tie") |>
  select( playerDeck,opponentDeck,game_outcome,server ) |>
  group_by(server,playerDeck) |>
  summarise( 
    nWin   = sum(game_outcome=="win"),
    nGames = n(),
    WR=mean(game_outcome=="win")
    ) |>
  ungroup() |>
  group_by(server) |>
  mutate( sumGames = sum(nGames), regPlayrate = nGames/sumGames ) |>
  left_join(WR.DT[,c("playerDeck","playrate")],by="playerDeck") 
```

## Row

### MetaDecks WinRates

```{r print-tableWinRate}
WR.DT.Reg |>
  arrange(desc(playrate)) |>
  filter(playrate >= 0.01) |>
  # slice_max(playerDeck,n = 10, with_ties = T) |>
  arrange(desc(playrate)) |>
  relocate(playerDeck,WR,nWin,nGames,regPlayrate,server) |>
  reactable(
    groupBy = "playerDeck",
    # searchable = TRUE,
    bordered = TRUE,
    # wrap = FALSE,
    highlight = TRUE,
    striped = TRUE,
    pagination = FALSE,
    # filterable = TRUE,
    defaultColDef = colDef(
      # header = function(value) str_to_title(value),
      #  cell = function(value) format(value, nsmall = 1),
      align = "center",
      minWidth = 70
      # headerStyle = list(background = "steelblue",color="white")
      ),
    columns = list(
      playerDeck = colDef(name = "Champions",minWidth = 150),
      server = colDef(name = "Server", aggregate = "unique"),
      nWin   = colDef(name = "#Win", aggregate = "sum"),
      nGames = colDef(name = "#Games", aggregate = "sum"),
      WR     = colDef(name = "WinRate", aggregate = JS(
        "function(values, rows) {
        var totalWin = 0
        var totalGames = 0
        rows.forEach(function(row) {
        totalWin   += row['nWin']
        totalGames += row['nGames']
        })
        return totalWin / totalGames
        }"
        ),format = colFormat(percent = TRUE,digits = 1),
        ),
      regPlayrate   = colDef(name = "Play Rate",
                             aggregate = JS("function(values, rows) {
                                            var total = 0;
                                            var n = 0;
                                            rows.forEach(function(row) {
                                            total += row['playrate']
                                            n += 1
                                            })
                                            return total/n
                                            }"),
                             format = colFormat(percent = TRUE,digits = 1)),
      sumGames   = colDef(show=F),
      playrate   = colDef(show=F)
      )
    )
```

### UnderdogDecks WinRates

```{r print-under-tableWinRate}
WR.DT |>
  filter( nGames >= 50 & WR >= 0.50 & playrate >= 0.001 & playrate < 0.01) |>
  relocate(playerDeck,WR,nWin,nGames,playrate) |>
  arrange(desc(WR)) |>
  reactable(
    # searchable = TRUE,
    bordered = TRUE,
    # wrap = FALSE,
    highlight = TRUE,
    striped = TRUE,
    pagination = FALSE,
    # filterable = TRUE,
    defaultColDef = colDef(
      # header = function(value) str_to_title(value),
      #  cell = function(value) format(value, nsmall = 1),
      align = "center",
      minWidth = 70,
      headerStyle = list(background = "steelblue",color="white")
      ),
    columns = list(
      playerDeck = colDef(name = "Champions",minWidth = 150),
      nWin   = colDef(name = "#Win"),
      nGames = colDef(name = "#Games"),
      WR     = colDef(name = "WinRate",format = colFormat(percent = TRUE,digits = 1) ),
      playrate   = colDef(name = "Play Rate",format = colFormat(percent = TRUE,digits = 1))
      )
    )
```

## Row {data-heigth="150"}

### Number of Games

```{r value-games}
flexdashboard::valueBox(glue::glue("{NROW(LoR.Melt.Matches.RMD)} Games"),
                        caption = glue::glue("Number of Ranked Games"),
                        icon = "fa-table",
                        color = "#a88b32")
```

### Number of Meta Decks

```{r value-meta}
flexdashboard::valueBox(glue::glue("{length(fct_meta)} Meta Decks"),
                        caption = glue::glue("Decks with PlayRate with at least 1%"),
                        icon = "fa-trophy",
                        color = "#65c0a9")
```

### Number of Underdog Decks

```{r value-underdog}
flexdashboard::valueBox(glue::glue("{length(fct_underdog)} Underdog Decks"),
                        caption = glue::glue("Decks with positive WR and PR in 0.1% to 1%"),
                        icon = "fa-dog",
                        color = "#ff7f24")
```

### Last Update

```{r value-update}
flexdashboard::valueBox(Sys.Date(),
                        caption = glue::glue("Last Update"),
                        icon = "fa-clock",
                        color = "lightgreen")
```

# MetaDeck-Structure {data-icon="fa-align-left"}

## Inputs {.sidebar}

### Filters

```{r filters-deck-structure}
deckStrctures_meta  <- map_df(.x = c(fct_meta), ~get_deck_structure_2_meta(DT = LoR.Melt.Matches.RMD, archetype =.x, minN = 20) ) |>
  as_tibble() |>
  add_column(popularity = "Meta")

deckStrctures_underdog <- map_df(.x = c(fct_underdog), ~get_deck_structure_2_meta(DT = LoR.Melt.Matches.RMD,archetype =.x,minN = 20) ) |>
  as_tibble() |>
  add_column(popularity = "Underdog")

shared_data <- crosstalk::SharedData$new(rbind(deckStrctures_meta,deckStrctures_underdog))
crosstalk::filter_select(id = "popularity", label = "Meta/Underdog", sharedData = shared_data, group = ~popularity)
crosstalk::filter_select(id = "archetype", label = "Archetype", sharedData = shared_data, group = ~archetype)
```
## Row {data-heigth="850"}

### Decks-Structures

```{r print-react-structure}
good_color <- make_color_pal(c("white", "white", "#9bc2e6"))

shared_data |>
  reactable(
    groupBy = c("popularity", "archetype"),
    bordered = TRUE,
    highlight = TRUE,
    searchable = TRUE,
    compact = TRUE, # compact the table height
    fullWidth = T, # don't fill the page
    pagination = FALSE,
    wrap = TRUE,
    # filterable = TRUE,
    defaultColDef = colDef(
      style = function(value) {
        if (!is.numeric(value)) return()
        color <- good_color(value)
        list(background = color,fontFamily = "Roboto", fontSize = "14px")
        },
      align = "center",
      minWidth = 120
      ),
    columns = list(
      popularity = colDef(name = "Meta/Underdog",minWidth = 150),
      archetype = colDef(name = "Archetype",minWidth = 150),
      name     = colDef(name = "Card",minWidth = 120, style = list( fontWeight = "bold", fontFamily = "Roboto", fontSize = "13px" ), align = "center" ),
      playrate = colDef(name = "PlayRate", format = colFormat(percent = TRUE,digits = 1) ),
      `3`      = colDef(name = "3",format = colFormat(percent = TRUE,digits = 1) ),
      `2`      = colDef(name = "2",format = colFormat(percent = TRUE,digits = 1) ),
      `1`      = colDef(name = "1",format = colFormat(percent = TRUE,digits = 1) )
      ),
    rowStyle = JS("function(rowInfo) {
                  if (rowInfo.level > 0) {
                  return { background: 'whitesmoke', borderLeft: '2px solid #ffa62d' }
                  } else {
                  return { borderLeft: '2px solid transparent' }
                  }
                  }"),
    defaultExpanded = T
    )
```
# Deck-Codes {data-icon="fa-code"}

```{r create-deck-code-tbl}
# https://lor.runeterra.ar/decks/code/CECQCAIDCQAQGBASAECAIEADAUBQCCINAQAQIJRHFU2AIAIBAMXACAIEAEAQGBALAECQGBACAEAQGOABAMBQ6
deckCodeTbl  <- LoR.Melt.Matches.RMD |>
  filter( playerDeck %in% c(fct_meta,fct_underdog) ) |>
  mutate( playerDeck = factor(playerDeck, ordered = TRUE, 
                                levels = c(fct_meta,fct_underdog) ),
          server = str_to_title(server) ) |>
  group_by(server,playerDeck,deck_code ) |>
  summarise( n = n() ) |>
  slice_max(n, n = 5) |>
  ungroup()
```

## Inputs {.sidebar}

### Filters

```{r filter-deck-code-tbl}
shared_code <- crosstalk::SharedData$new(deckCodeTbl)
crosstalk::filter_select(id = "server", label = "Server", sharedData = shared_code, group = ~server)
crosstalk::filter_select(id = "playerDeck", label = "Archetype", sharedData = shared_code, group = ~playerDeck)
```

## Row
### Decks Code

```{r print-deck-code-tbl}
shared_code |>
  reactable(
    groupBy = c("playerDeck","server"),
    bordered = TRUE,
    highlight = TRUE,
    searchable = TRUE,
    compact = TRUE, # compact the table height
    fullWidth = T, # don't fill the page
    # defaultPageSize = 20,
    pagination = FALSE,
    wrap = TRUE,
    # filterable = TRUE,
    defaultColDef = colDef(
      style = list(fontFamily = "Roboto", fontSize = "14px"),
      align = "center",
      minWidth = 120
      ),
    columns = list(
      deck_code = colDef(name = "DeckCode", cell = function(value, index) {
        # Render as a link
        url <- glue::glue("{urlruneterraAR}{urldeck}{value}")
        # url <- sprintf("https://lor.runeterra.ar/decks/code/%s",deckCodeTbl[index, "deck_code"], value)
        htmltools::tags$a(href = url, target = "_blank", as.character(value))
        },minWidth = 400),
      server = colDef(name = "Server",minWidth = 150),
      playerDeck = colDef(name = "Archetype",minWidth = 150),
      n     = colDef(name = "Games" )
      ),
    rowStyle = JS("function(rowInfo) {
                  if (rowInfo.level > 0) {
                  return { background: 'whitesmoke', borderLeft: '2px solid #ffa62d' }
                  } else {
                  return { borderLeft: '2px solid transparent' }
                  }
                  }"),
    defaultExpanded = T
    )
```

# Meta-Evolution {data-icon="fa-chart-line"}

## Inputs {.sidebar}

### Filters

```{r filters-meta-evo}
crosstalk::filter_select("Archetype", "Deck's Archetype", keyDeckDaily, ~Archetype)
```

By clicking on the plot (both the ones on the left or the one on the right) you can highlight a deck in all regions, hover over them and it will display their values. By double clicking on the plots restore it to default.

`r kableExtra::text_spec("WARNING:", color = "red")`: While it's possible to filter the data for specific decks, once the selection from the box is done, currently it's not possible to restore the highlights as default, it's necessary to update the page.

## Row
### Meta Decks PlayRate over time

```{r create-plot-meta-evo}
#' Grouped line plots for PR over time
meta_evo <- keyDeckDaily %>% {
   ggplot(., aes(game_start_time_utc, playRate, group = Archetype,color = Archetype)) +
      geom_line() +
      facet_wrap(~server, ncol = 2) +
      scale_colour_viridis_d(option = "turbo") +
      theme_Publication() +
      theme(legend.position = "none") +
      scale_y_continuous(limits = c(0, maxFreq),
                     breaks = seq(0,maxFreq,0.05),
                     # expand = c(-0.001,0.02),
                     labels = scales::percent_format(accuracy = 1),
                     position = "right") +
      labs(x= "",y = "")
   } |>
  ggplotly(tooltip=c("group","playRate"),hovertemplate = paste("%{xaxis.title.text}: %{playRate:.0%}<br>") )

#' Dot Plot of PR
dot_plot <- keyDeckDaily |>
  plot_ly( ) |>
  group_by(Archetype) |>
  summarise(playRate = last(playRate)) |>
  add_markers(
    x = ~round(playRate,3),
    y = ~forcats::fct_reorder(Archetype, playRate),
    hoverinfo = "x+y"
  ) |>
  layout(
    xaxis = list(title = "Play Rate", tickfont = list(size = 10) ),
    yaxis = list(title = "Archetype", tickfont = list(size = 10), side = "right")
  )
```

```{r print-plot-meta-evo, fig.width=12, fig.height=8}
plotly::subplot(meta_evo, dot_plot, widths = c(.8, .2)) |>
  layout(showlegend = FALSE) |>
  plotly::highlight(on = "plotly_click", off = "plotly_doubleclick")
```

# Informations {data-orientation="columns" data-icon="fa-info-circle"}

## Column
<!-- ## Column {data-width="800"} -->

### How to read/use

#### Deck-Structure

* The filter Meta/Underdog allows to restrict to decks that I define as 'MetaDeck' or 'UnderdogDeck'. Meta decks are in my case defined as decks with at least 1% PlayRate. Underdog decks are in my case defined as decks with at least 0.1% but no more than 1% PlayRate and a mean WR more or equal to 50%.

* The filter Archetypes allows to restrict to specific/s deck archetypes.

* The order of the archetypes is by decreasing values PlayRate from the most popular to the least popular.

#### Deck-Codes

* Currently showing only the top5 most played deckcodes for each archetype. Planning to add the top5 most played deckcodes for each archetype by the playerDeck with the highest amount of games with it. Both case (top5 and top5 by a playerDeck) for each server.

#### Meta-Evolution

* The graph in the Meta-Evolution section displays the PlayRate over time of what I define as 'MetaDeck'. Meta decks are in my case defined as decks with at least 1% PlayRate.

* The PlayRate is base around ALL games considered.

<!-- * `r kableExtra::text_spec("NOTE:", color = "red")`: it is possible I'll also display the playrates when those are computed as a single value by each day -->

* By clicking on the plot (both the ones on the left or the one on the right) you can highlight a deck in all regions, hover over them and it will display their values. By double clicking on the plots restore it to default.

* `r kableExtra::text_spec("WARNING:", color = "red")`: While it's possible to filter the data for specific decks, once the selection from the box is done, currently it's not possible to restore the highlights as default, it's necessary to update the page.

#### General info

When I refer to games it's always refering a single playerDeck. So, if I have the information of 1 match it's equivalent to 2 games.