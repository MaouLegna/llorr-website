---
title: "Match Ups Data (from Patch 2.18 onward)"
author: "by Legna"
output:
  flexdashboard::flex_dashboard:
    navbar:
      - { icon: "fa-trophy", text: "Meta", href: "https://www.llorr-stats.com/static/meta.html", align: right }
      - { icon: "fa-home", href: "https://www.llorr-stats.com", align: right }
    # orientation: columns
    # vertical_layout: fill
    orientation: row
# date: "`r Sys.Date()`"
params:
  # start: "2021-06-02 21:00:00" #UTC tz / 2.09 <- Balance Patch
  # start:   "2021-06-30 21:00:00" #UTC tz / 2.11 <- Rose of the Underworld
  # start: "2021-07-14 21:00:00" #UTC tz / 2.12 <- Ruination Event
  # end: "2021-08-25 21:00:00" #UTC tz / 2.14 <- Bandle Release
  # start: "2021-09-01 21:00:00" #UTC tz / 2.14 <- World Patch to 2.18 ( one week later because of world patch )
  start:   "2021-10-20 21:00:00" #UTC tz / 2.18 <- Balance Patch
  end:   "2022-01-01 21:00:00" #UTC tz /
  # skip:  2800000  # Patch 2.14
  # skip:  3500000  # Patch 2.18
---

```{r}
# 6/1/21 07:00 PM Game Updates PATCH 2.9.0 NOTES
# 6/29/21 07:00 PM Game Updates PATCH 2.11.0 NOTES <- Rise Underworld
# 7/13/21 07:00 PM Game Updates PATCH 2.12.0 NOTES <- Ruination # Viego & Akshan arrive in patch 2.12.0, which will be playable at approximately 11AM PT, July 14.
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  eval = TRUE,
  warning = FALSE,
  error = FALSE,
  message = FALSE,
  comment = NA,
  R.options = list(width = 140,
                   digits.secs=6),
  dev.args = list(bg = 'transparent'), # make graphics with transparent background
  fig.align = 'center',
  fig.width=12,
  fig.height=8,
  engine.path = list(
    python = 'C:/anaconda/'   # -> use_python("C:/anaconda/")
  ),
  #'distill options
  layout="l-body-outset",
  preview=FALSE
)

#' R Option
options(scipen = 999)
source(file.path("C:","LlorR","scripts","lor_main.R"))
xaringanExtra::use_panelset()
```

```{r load-data}
#' load DeckDT
#'############
LoR.Deck.RMD        <- fread(file.path("C:","LlorR","data","raw","LoR_DECK.csv"),na.strings = c("",NA))

#' load Games DT
#'##############
LoR.Match.RMD <- fread(file.path("C:","LlorR","data","raw","LoR_TempDT.csv"), header = T, na.strings = c("",NA) )

# file.DT <- file.path("C:","LlorR","data","raw","LoR_MatchDT_patch_2_04_to_17final.csv")
# header        <- fread(file.DT, header = FALSE, na.strings = c("",NA), nrows = 1, stringsAsFactors = FALSE)
# LoR.Match.RMD <- fread(file.DT, header = FALSE, na.strings = c("",NA), skip = params$skip )
# colnames(LoR.Match.RMD) <- unlist(header,use.names = F)
```

```{r archetype-fix}
#' Limit the Deck DT to make the fixes much faster
deck_filter <- LoR.Match.RMD |>
  #' Base filters
  filter( game_type=="Ranked" ) |>
  filter( game_start_time_utc > as.POSIXct(params$start, tz = "UTC") ) |>
  select(deck_code_1,deck_code_2) |>
  pivot_longer( cols = contains("deck_code"),values_to = "decks" ) |>
  filter(decks!="") |>
  distinct(decks)

LoR.Deck.RMD <- LoR.Deck.RMD[deck_code %in% deck_filter$decks]

#' Archetype-Fix
#'##############
source(file.path("C:","LlorR","scripts","functions","lor_archetype_rmd.R"))

# LoR.Deck.RMD[ ,tabyl(archetype_pretty) ]

#' Archetype names fix
######################
LoR.Deck.RMD[ !is.na(archetype_pretty), archetype:=archetype_pretty ]
```

```{r process-data}
#' Melt tbl
#'#########
LoR.Melt.Matches.RMD <- LoR.Match.RMD |>
  filter( game_type=="Ranked" ) |>
  # filter( game_start_time_utc > as.POSIXct(params$start, tz = "UTC") ) |>
  filter( game_start_time_utc >= as.POSIXct(params$start,"UTC") & game_start_time_utc < as.POSIXct(params$end,"UTC") ) |>
  select( -ends_with("_3"),-ends_with("_4")  ) |>
  left_join(LoR.Deck.RMD[,.(deck_code,playerDeck_1=archetype)],  by=c("deck_code_1"="deck_code")) |>
  left_join(LoR.Deck.RMD[,.(deck_code,opponentDeck_1=archetype)],by=c("deck_code_2"="deck_code")) |>
  rename( playerPuuid_1 = puuid_1, playerPuuid_2 = puuid_2 ) |>
  mutate( playerDeck_2 = opponentDeck_1, opponentDeck_2 = playerDeck_1, opponentPuuid_1 = playerPuuid_2, opponentPuuid_2 = playerPuuid_1 ) |>
  pivot_longer(cols = c(ends_with("_1"),ends_with("_2")),
               names_to = c(".value"),
               names_pattern = "(.*)_[0-9]"
               ) |>
  as.data.table()

# LoR.Melt.Matches.RMD[ is.na(playerDeck), .N ]
```

```{r process-MU}
#' WR tbl
#'#######
WR.DT <- LoR.Melt.Matches.RMD |>
  filter(game_outcome!="tie") |>
  select( playerDeck,opponentDeck,game_outcome ) |>
  group_by(playerDeck) |>
  summarise( nWin   = sum(game_outcome=="win"),
             nGames = n(),
             WR=mean(game_outcome=="win")
  ) |>
  ungroup() |>
  mutate( playrate = nGames/sum(nGames) )

#' MU tbl the date is already filtered
#'####################################
MUtbl <- LoR.Melt.Matches.RMD |>
  filter( game_outcome != "tie" ) |>
  select( playerDeck,opponentDeck,game_outcome,server,game_version,factions ) |>
  group_by(playerDeck,opponentDeck,factions) |>
  summarise( 
    muWin   = sum(game_outcome=="win"),
    muGames = n(),
    muWR=mean(game_outcome=="win")
    ) |>
  ungroup() |>
  mutate(
    factions = map_chr(.x = factions, ~str_remove_all(.x, paste(c("_Name","faction_", ""), collapse = "|") ) ),
    CI   = map2_df(.x=muWin,.y = muGames, .f = ~binom::binom.confint(.x,.y,0.95,methods="exact")[,c("lower","upper")] )
    ) |>
  chop(CI) |>
  unnest(CI) |>
  mutate( okCI = map2_lgl(.x = lower,.y = upper, ~ !between(0.50,.x,.y) ) ) |>
  mutate( direction = ifelse(muWR>0.50,"POS","NEG") ) |>
  mutate( direction = replace(direction,direction==0.50,"TIE") ) |>
  mutate( CI := glue::glue("({scales::percent(lower,accuracy = 0.1)}-{scales::percent(upper,accuracy = 0.1)})" ) ) |>
  # removing ~extra variables
  select(-lower,-upper) |>
  left_join(WR.DT[,c("playerDeck","playrate")],by="playerDeck") |>
  relocate(factions,.after = muWR)
```
# Table {data-icon="fa-table"}

```{r}
nfilter <- 10

MUtbl.tot <- sum(MUtbl$muGames)

data <- crosstalk::SharedData$new(
  MUtbl |>
    filter(muGames >= nfilter)
)
```

## Inputs {.sidebar}

### Filters

```{r filters}
crosstalk::filter_select("playerDeck", "Player's Deck", data, ~playerDeck)
crosstalk::filter_select("opponentDeck", "Opponent's Deck", data, ~opponentDeck)

crosstalk::filter_slider("muWin",   "#Win",  data, ~muWin,   step = 50 ,min = 0)
crosstalk::filter_slider("muGames", "#Games",data, ~muGames, step = 100,min = 0)

crosstalk::filter_slider("muWR", "WinRate", data, ~muWR,step=0.01,min = 0,max = 1)
crosstalk::filter_slider("playrate", "PlayRate", data, ~playrate,step=0.01,min = 0,max = round(max(MUtbl$playrate),4) )

crosstalk::filter_select("direction", "MU-Direction", data, ~direction)
```

## Row {data-heigth="750"}

### MU table

```{r print-react-MU}
# require(htmltools)

# Render a bar chart with positive and negative values
bar_chart_pos_neg <- function(label, value, max_value = 1, height = "12px",pos_fill = "#005ab5", neg_fill = "#dc3220") {
  
  base_chart <- htmltools::div(style = list(flex = "1 1"))
  # pos_chart <- htmltools::div(style = list(flex = "1 1"))
  width <- paste0((value / max_value) * 100, "%")

  if (value >= 0.5) {
    bar <- htmltools::div(style = list(marginLeft = "8px",marginRight = "8px", background = pos_fill, width = width, height = height))
    chart <- htmltools::div(style = list(display = "flex", alignItems = "center"), bar, label)
    base_chart <- htmltools::tagAppendChild(base_chart, chart)
    htmltools::div(style = list(display = "flex"), base_chart)
  } else {
    bar <- htmltools::div(style = list(marginLeft = "8px",marginRight = "8px", background = neg_fill, width = width, height = height))
    chart <- htmltools::div(style = list(display = "flex", alignItems = "center"), bar, label)
    base_chart <- htmltools::tagAppendChild(base_chart, chart)
    htmltools::div(style = list(display = "flex"), base_chart)
  }
}

data |>
  reactable(
    bordered = TRUE,
    highlight = TRUE,
    striped = TRUE,
    searchable = TRUE,
    compact = TRUE, # compact the table height
    fullWidth = T, # don't fill the page
    defaultPageSize = 20,
    wrap = TRUE,
    defaultSorted = list(muGames = "desc"),
    # filterable = TRUE,
    defaultColDef = colDef(
      style = list(fontFamily = "Roboto", fontSize = "13px"), align = "center"
      # minWidth = 120,
      ),
    columns = list(
      playerDeck   = colDef(name = "Player",minWidth = 120, style = list(fontSize = "11px", fontWeight = "bold", color="black") ),
      opponentDeck = colDef(name = "Opponent"  ,minWidth = 120, style = list(fontSize = "11px", fontWeight = "bold", color="black")),
      muWin    = colDef(name = "#Win" ), # , style = list( fontSize = "13px")
      muGames  = colDef(name = "#Games",defaultSortOrder = "desc"),
      muWR  = colDef(
        name = "Win Rate",
        # defaultSortOrder = "desc",
        cell = function(value) {
          label <- paste0(round(value * 100,1), "%")
          bar_chart_pos_neg(label, value)
          },
        align = "center",
        minWidth = 200
        ),
      playrate = colDef(name = "PlayRate",format = colFormat(percent = TRUE,digits = 1), style = list( fontSize = "13px") ),
      factions = colDef(name = "Regions"),
      CI       = colDef(name = "CI",minWidth = 120, style = list(fontSize = "13px")),
      LCI       = colDef(show=F), # lower
      UCI       = colDef(show=F), # lower
      direction = colDef(show=F),
      okCI      = colDef(show=F)
      )
    )
```

## Row

### Number of Games (min 10 games for each MU)

```{r value-nGames}
nGames = MUtbl |> 
  filter( muGames > nfilter ) |>
  summarise(n = sum(muGames)) |>
  pull()

flexdashboard::valueBox(glue::glue("{nGames} Ranked Games"),
                        caption = glue::glue("out of a total of {MUtbl.tot} - min 10 games"),
                        icon = "fa-table",
                        color = "#FA7404")
```

### Last Update

```{r value-update}
flexdashboard::valueBox(Sys.Date(),
         icon = "fa-clock",
         color = "lightgreen")
```

# Grid {data-icon="fa-file-image"}

## Row {data-heigth="850"}

### MU Grid

```{r get-WR-Top}
mu <- 10

TopCC <- MUtbl |>
  group_by(playerDeck) |>
  summarise(nGames = sum(muGames)) |> 
  arrange(desc(nGames)) |>
  slice_head(n = mu) |> 
  select(playerDeck) |>
  pull() # |> sort()


WRTopCC <- tibble::tibble( 
  playerDeck = rep(TopCC,each=mu),
  opponentDeck = rep(TopCC,mu)
  ) |>
  left_join(MUtbl, by = c("playerDeck","opponentDeck"))
```

<!-- The win rates on the grid are among the `r mu` most played champion combination. -->

```{r prepare-flex}
big_border   = officer::fp_border(color="darkgray", width = 2)
small_border = officer::fp_border(color="gray", width = 1)

dummy_fun <- function(x){
  # case_when(
  #   is.na(x) ~ NA,
  #   x > 0.15 & x < 0.85 ~ sprintf( "%.0f%%", x*100 ),
  #   x <= 0.15 & x >= 0.85 ~ sprintf( "%.0f%%*", x*100 )
  # )
  ifelse( !is.na(x),
          ifelse(x > 0.15 & x < 0.85,
                 sprintf( "%.0f%%",  x*100 ),
                 sprintf( "%.0f%%*", x*100 )
                ),NA )
}
```

```{r prepare-flex-grid}
grid <- matrix(WRTopCC$muWR, nrow = mu, ncol = mu, byrow = T)
diag(grid) <- NA

colnames(grid) <- TopCC
colourer <- scales::col_numeric(
  palette = c("#D73027", # red
          # "#f9ccac", # red/orange
          "white",
          # "#e3eaa7", # green
          "#1A9850" # darker green
          ),
  domain = c(0, 1))

funs <- setNames(rep(list(dummy_fun), mu), TopCC)
```

```{r create-flex}
require(flextable)

ft <- grid |> 
  as_tibble() |>
  # mutate(across(everything(),~scales::percent(.x, accuracy = 0.1 ))) |>
  add_column(TopCC,.before = TopCC[1]) |>
  rename("MatchUps"="TopCC") |>
  flextable::flextable( ) |> 
  flextable::theme_vanilla( ) |>
  # theme_booktabs(bold_header = TRUE) |> 
  flextable::align(align = "center", part = "all") |>
  flextable::bg(
    bg = colourer,
    j = ~ . -MatchUps,
    part = "body") |>
  {\(x) flextable::border_remove(x = x)}() |>
  # flextable::bold( bold = function(x)   )
  flextable::color(
    i = 1:ncol(grid),
    j = 2:ncol(grid)+1, 
    color = function(x) ifelse(x <= .15 | x >= .85 , "grey75", "grey25")
    ) |>
  flextable::border_outer(part="all", border = big_border ) |>
  flextable::border_inner_h(part="all", border = small_border ) |>
  flextable::border_inner_v(part="all", border = small_border ) |>
  flextable::set_formatter(values = funs) |>
  flextable::fontsize(size = 8, part = "header") |>
  flextable::fontsize(j=1, size = 8) |>
  flextable::bg(part = "header", bg = "white"  ) |>
  flextable::bg(part = "footer", bg = "white"  ) |>
  flextable::bg(j = 1, bg = "white"  ) |>
  flextable::autofit() |>
  flextable::add_footer_lines("Values with * and grayed are win rates below 15% or higher then 85%. Those MU may be unreliable because of Sample Size.")

# ft
```

```{r print-flex, fig.width=12, fig.height=8}
ft
flextable::save_as_image(x = ft, path = "images/mugrid.png") |> invisible()
```

## Row

### Number of Games (min 10 games for each MU)

```{r value-nGames-2}
nGames = MUtbl |> 
  filter( muGames > nfilter ) |>
  summarise(n = sum(muGames)) |>
  pull()

flexdashboard::valueBox(glue::glue("{nGames} Ranked Games"),
                        caption = glue::glue("out of a total of {MUtbl.tot} - min 10 games"),
                        icon = "fa-table",
                        color = "#FA7404")
```

### Last Update

```{r value-update-2}
flexdashboard::valueBox(Sys.Date(),
         icon = "fa-clock",
         color = "lightgreen")
```

<!-- ![](images/mugrid.png) -->

```{r}
# knitr::include_graphics(path = "./images/mugrid.png")
```

# Grid 2.14/2.17 (Bandle Release) {data-icon="fa-file-image"}

![](images/mugrid_patch_2_14to17.png)

# Grid 2.9/2.10 (Dragon) {data-icon="fa-file-image"}

![](images/mugrid_patch_2_09to10.png)

# Downloads and Informations {data-orientation="columns" data-icon="fa-info-circle"}

## Download {data-width="200"}

### Match Ups Data

```{r}
# MUtbl |>
#   filter( muGames > 10 ) |>
#   select(playerDeck,opponentDeck,muWin,muGames,muWR) |>
#   fwrite("mutbl_patch_2_12to13.csv")
```


```{r}
MUtbl |>
  filter( muGames > 10 ) |>
  select(playerDeck,opponentDeck,muWin,muGames,muWR) |>
  downloadthis::download_this(
    button_label = "Download MU data as .csv",
    output_name = "mutable",
    button_type = "success",
    has_icon = TRUE,
    icon = "fa fa-save"
    )

MUtbl |>
  filter( muGames > 10 ) |>
  select(playerDeck,opponentDeck,muWin,muGames,muWR) |>
  jsonlite::write_json("MU.json")
```

<!-- ### Match Ups Data (2.12/2.13) -->

<!-- ```{r} -->
<!-- # MUtbl |> -->
<!-- #   filter( muGames > 10 ) |> -->
<!-- #   fwrite( "data/mutbl_patch_2_12to13.csv" ) -->
<!-- fread("data/mutbl_patch_2_12to13.csv") |> -->
<!--   select(playerDeck,opponentDeck,muWin,muGames,muWR) |> -->
<!--   download_this(., -->
<!--               button_label = "Download MU data (2.12/2.13) as .csv", -->
<!--               output_name = "mutable", -->
<!--               button_type = "success", -->
<!--               has_icon = TRUE, -->
<!--               icon = "fa fa-save" -->
<!--               ) -->
<!-- ``` -->

### Match Ups Grid

```{r}
downloadthis::download_file(
  path = file.path("images/mugrid.png"),
  # path = system.file("assets/css/all.min.css", package = "downloadthis"),
  button_label = "Download MU grid as .png",
  button_type = "primary",
  has_icon = TRUE,
  icon = "fa fa-save",
  self_contained = FALSE
)
```
### Match Ups Grid (2.14/2.17)

```{r}
downloadthis::download_file(
  path = file.path("images/mugrid_patch_2_09to10.png"),
  # path = system.file("assets/css/all.min.css", package = "downloadthis"),
  button_label = "Download MU grid (2.14/2.17) as .png",
  button_type = "primary",
  has_icon = TRUE,
  icon = "fa fa-save",
  self_contained = FALSE
)
```

### Match Ups Grid (2.09/2.10)

```{r}
downloadthis::download_file(
  path = file.path("images/mugrid_patch_2_09to10.png"),
  # path = system.file("assets/css/all.min.css", package = "downloadthis"),
  button_label = "Download MU grid (2.9/2.10) as .png",
  button_type = "primary",
  has_icon = TRUE,
  icon = "fa fa-save",
  self_contained = FALSE
)
```

## Column {data-width="800"}

### How to use

#### Filters

The format of the table is the usual way I display the match-ups data but I also displayed additional variables that I normally remove in the report:

-   **Player's Deck** - deck's archetype of the playerDeck

-   **Opponent's Deck** - deck's archetype of the opponentDeck

-   **\#Win** - min number of wins for a match-up

-   **\#Games** - min number of games for a match-up

-   **Regions** - regions of the 'Player' deck.

-   **MU-Direction** - simply if the MU is positive (win rate \> 50%) or negative (win rate \< 50%) for the 'Player' or tie (win rate = 50%)

#### Archetypes Fix

1. **"ASZ - Sivir Ionia** Is the aggregation of (Ionia's) Sivir/Zed, Sivir/Akshan, Sivir/Zoe/Akshan as analysis I did shows they are the same deck.

2. **RubinBait** decks are burn focused bait-variant of decks with certain kind of champion

  - Draven / Sion
  - Caitlyn / Draven
  - Draven / Ezreal
  
3. **"Dragons (DE/MT)** All decks with at least both Shyvana and Aurelion Sol. A Shyvana/Zoe which was popularizes by Alanz as it doesn't contains ASol is not included because of this.

#### General info

When I refer to games it's always refering a single playerDeck. So, if I have the information of 1 match it's equivalent to 2 games.


```{r update-Shiny}
MUtbl |>
  filter(playerDeck %in% TopCC & opponentDeck %in% TopCC ) |>
  fwrite(file.path("C:","LlorR","scripts","shiny","bo3-helper","Bandle01-MUtbl.csv"))

flextable::save_as_image(x = ft, path = "images/mugrid.png") |> invisible()
```

