#'**************************************************************************** *
# HANDLE STATUS RESPONSE --------------------------------------------------
#'**************************************************************************** *

#' Send a GET call and return the appropriate response:
# 
#' @param getCall - the get call I'm interested in
#' 
#' @value [200] - the content I need
#' @value [403] - return nothing and write the error
#' @value [404] - return nothing -> will then be handled for each different case
#' @value [429] - retry-after value
#' @value [503] - return nothing and write the error
#' @value [other] - return nothing other cases, just give the status
#' 
#' @return GET - the appropriate get result for the response status
#' @return RS  - Response Status
#' 
#' @example response_status(GET("https://europe.api.riotgames.com", path = "/lor/ranked/v1/leaderboards/", add_headers("X-Riot-Token" = api_key))) *
#' 
response_status <- function(getCall) {
  
  res    <- list("GET" = NULL, "status" = NULL)
  status <- getCall$status_code
  res$status <- status
  
  # Service unavailable
  if (status == 503){ print(paste0("response_status / status code ",status)); return(res) }
  
  # Too many calls / exceeded rate limit
  if (status == 429){
    res$GET <- as.numeric(getCall$headers$`retry-after`)
    print(paste0("response_status / status code: ",getCall$status," / restart after: ",getCall$headers$`retry-after`,"s at: ",Sys.time()+as.numeric(getCall$headers$`retry-after`) ))
    return(res)
  }
  
  # found nothing
  if (status == 404){ return(res) }
  
  # API key expired or Forbidden
  if (status == 403){ 
    print(paste0("response_status / status code ",status ))
    # 403	Forbidden / so actually it's not always the key being the problem
    print(paste0("FORBIDDEN! (API key expired?)"))
    return(res)
  }
  
  # Error but rare case?
  if (status != 200){
    print(paste0("response_status / status code ",status ))
    print(getCall)
    return(res)
  }
  
  # All fine
  if (status == 200){ 
    GET <- rawToChar(getCall$content)
    Encoding(GET) <- "UTF-8"
    GET = jsonlite::fromJSON(GET)
    return(c(GET,status=status))
  }
}

#'**************************************************************************** *

#' Return the path for the one of the main 4 Riot servers
#' 
#' @param server the server name
#' @example get_path_server("europe")
#' 
get_path_server <- function(server) {
  base.url <- case_when(
    server == "americas"  ~ "https://americas.api.riotgames.com",
    server == "asia"      ~ "https://asia.api.riotgames.com",
    server == "europe"    ~ "https://europe.api.riotgames.com",
    server == "sea"       ~ "https://sea.api.riotgames.com"
  )
  
  # list.levels$server
  
  if (server %!in% c("americas","asia","europe","sea")){
    print("Provide a server value among one of these: " )
    return(NULL)
  }
  return(base.url)
}
# > get_path_server("europe")
# [1] "https://europe.api.riotgames.com"

#'**************************************************************************** *
# LEADERBOARD -------------------------------------------------------------
#'**************************************************************************** *

#' Return the list of players from one of the main 4 regions
# 
#' *X-Method-Rate-Limit": "30:10,500:600*
#' @param api_key essential variable for all API call to Riot Games, must be refreshed each 24hrs if a development key
#' @param server  to specify which server I want to get my data
#' 
#' @example GET("https://europe.api.riotgames.com", path = "/lor/ranked/v1/leaderboards/", add_headers("X-Riot-Token" = API_KEY_TEST))
#' @example lor_Leaderboard(server = "europe",api_key = API_KEY_TEST)
#' 
lor_Leaderboard <- function(server,api_key) {
  
  base.url <- get_path_server(server); path <- "/lor/ranked/v1/leaderboards/"
  
  # Note, it seems that it's not uncommon to have a 503 when doing this command, even when everything is fine (too many requestes?)
  LeaderboardDto <- response_status(
    GET(base.url, path = path,add_headers("X-Riot-Token" = api_key))
  )
  
  if (LeaderboardDto$status == 429) { return(LeaderboardDto$status) }
  if (LeaderboardDto$status != 200) { print(LeaderboardDto$status)  }
  
  res <- LeaderboardDto$players$name
  return(res)
}

#'**************************************************************************** *

#' Return the list of playerss with duplicate name currently in the leaderboard
#' 
#' @param api_key essential variable for all API call to Riot Games, must be refreshed each 24hrs if a development key
#' @param server  to specify which server I want to get my data
#' @example lor_Leaderboard_dupe(server = "europe",api_key = API_KEY_TEST)
#' 
lor_Leaderboard_dupe <- function(server,api_key) {
  
  base.url <- get_path_server(server); path <- "/lor/ranked/v1/leaderboards/"
  
  LeaderboardDto <- response_status(
    GET(base.url, path = path,add_headers("X-Riot-Token" = api_key))
  )
  
  if (LeaderboardDto$status == 429) { return(LeaderboardDto$status) }
  if (LeaderboardDto$status != 200) { print(LeaderboardDto$status)  }
  
  res <- LeaderboardDto$players$name
  
  if (length(res) != length(unique(res)) ) {
    print(paste0("Current number of Master players: ",length(res)," but the number of unique names is: ",length(unique(res)),"!" ))
    return(dupe = res[duplicated(res)])
  }
  print(paste0("Current number of Master players: ",length(res)," with no duplicates!" ))
}


#'**************************************************************************** *
# ACCOUNT-V1 --------------------------------------------------------------
#'**************************************************************************** *

#' Receive a vector of 1:n puuid and return the appropriate AccountDto so the gameName of tagLine
#' 
#' @param list.puuid the list of puuid you want to check. *Be aware that those puuid needs to be appropriate for the API_KEY used or will return status400*
#' @param api_key essential variable for all API call to Riot Games, must be refreshed each 24hrs if a development key
#' 
Account_bypuuid <- function(list.puuid, api_key ) {
  
  df <- data.table( puuid = character(),      # primary key for all Riot account
                    gameName = character(),   # 
                    tagLine = character()     # the tag after the name that combined with gameName create a secondary key
  )
  
  # the base.url doesn't matter
  base.url  <- "https://europe.api.riotgames.com"; path <- "/riot/account/v1/accounts/by-puuid/"
  
  for (i in 1:length(list.puuid) ) {
    cat(i," ")
    res <- GET(paste0( base.url,path,list.puuid[i] ),add_headers("X-Riot-Token" = api_key) )
    res <- response_status(res)
    
    if ( res$status == 429 ) { 
      Sys.sleep(res$GET+1)
      res <- GET(paste0( base.url,path,list.puuid[i] ),add_headers("X-Riot-Token" = api_key) )
      res <- response_status(res)
    }
    
    if ( res$status != 200 ) { df <- add_row(df, puuid=list.puuid[i], gameName=NA, tagLine=NA ) }
    if ( res$status == 200 ) { df <- add_row(df, puuid=list.puuid[i], gameName=res$gameName, tagLine=res$tagLine) }
  }
  return(df)
}

#'**************************************************************************** *

#' Receive a vector of 1:n puuid and return the appropriate AccountDto so the gameName of tagLine
#' 
#' @param list.puuid the list of puuid you want to check. *Be aware that those puuid needs to be appropriate for the API_KEY used or will return status400*
#' @param vecAPI_key essential variable for all API call to Riot Games, must be refreshed each 24hrs if a development key
#' @param origin when working with multiple api_key it specify which among n you need to use, the column of a line of keys
#' 
Account_byPuuid_O <- function(list.puuid, vecAPI_key, origin ) {
  
  df <- data.table( puuid = character(),      # primary key for all Riot account
                    gameName = character(),   # 
                    tagLine = character()     # the tag after the name that combined with gameName create a secondary key
  )
  
  base.url  <- "https://europe.api.riotgames.com"; path <- "/riot/account/v1/accounts/by-puuid/"
  
  print(paste0("Getting the info for ",NROW(list.puuid)," players"))
  
  if (length(list.puuid)==0) { stop("Searching for no one") }
  
  for (i in 1:length(list.puuid) ) {
    cat(i," ")
    
    res <- GET(paste0( base.url,path,list.puuid[i] ),add_headers("X-Riot-Token" = vecAPI_key[origin[i]]) ) %>% response_status()
    # res <- GET(paste0( base.url,path,list.puuid[i] ),add_headers("X-Riot-Token" = vecAPI_key[origin[i]] )) %>% response_status()
    
    if ( res$status == 429 ) { 
      Sys.sleep(res$GET+1)
      res <- GET(paste0( base.url,path,list.puuid[i] ),add_headers("X-Riot-Token" = vecAPI_key[origin[i]]) )
      res <- response_status(res)
    } 
    
    if ( (res$status != 429) & (res$status != 200) ) { 
      df <- add_row(df, puuid=list.puuid[i], gameName="FUCK", tagLine="FUCK" ) }
    if ( res$status == 200 ) { 
      df <- add_row(df, puuid=res$puuid, gameName=res$gameName, tagLine=res$tagLine) }
  }
  print("end")
  return(df)
}

get_account_by_puuid <- function(list.puuid, vecAPI_key, origin ) {
  
  df <- LoR.Account.base %>% as_tibble()
  
  base.url  <- "https://europe.api.riotgames.com"; path <- "/riot/account/v1/accounts/by-puuid/"
  
  print(paste0("Getting the info for ",NROW(list.puuid)," players"))
  
  if (length(list.puuid)==0) { stop("Searching for no one") }
  
  for (i in 1:length(list.puuid) ) {
    cat(i," ")
    
    res <- GET(paste0( base.url,path,list.puuid[i] ),add_headers("X-Riot-Token" = vecAPI_key[origin[i]]) ) %>% response_status()
    # res <- GET(paste0( base.url,path,list.puuid[i] ),add_headers("X-Riot-Token" = vecAPI_key[origin[i]] )) %>% response_status()
    
    if ( res$status == 429 ) { 
      Sys.sleep(res$GET+1)
      res <- GET(paste0( base.url,path,list.puuid[i] ),add_headers("X-Riot-Token" = vecAPI_key[origin[i]]) )
      res <- response_status(res)
    } 
    
    if ( res$status == 200 ) { 
      df <- add_row(df, gameName=res$gameName, tagLine=res$tagLine)
      df[ NROW(df)  , origin[i] ] <- res$puuid
    }
  }
  print("end")
  setDT(df)
  df <- df[, lapply( .SD, unique.naomit), by=.(gameName,tagLine)] %>% setcolorder(., names(LoR.Account.base) )
  return(df)
}

#'**************************************************************************** *

#' Recover the PUUID from the secondary key
#'
# [/riot/account/v1/accounts/by-riot-id/{gameName}/{tagLine}] 
#' @param gameName vector of gameName
#' @param tagLine  vector of tagLine 
#' 
get_puuid <- function(gameName,tagLine,api_key) {
  
  base.url <- "https://europe.api.riotgames.com"; path <- "/riot/account/v1/accounts/by-riot-id/";
  
  df <- data.table( puuid = character(),      # primary key for all Riot account
                    gameName = character(),   # first  component of secondary key
                    tagLine = character()     # second component of secondary key
  )
  
  if (length(gameName)!=length(tagLine)) { stop("provided different number of gameName and tagLine") }
  n <- length(gameName)
  
  for (i in 1:n ) {
    cat(i," ")
    
    res <- GET(paste0( base.url,path,URLencode(gameName[i]),"/",URLencode(tagLine[i]) ),add_headers("X-Riot-Token" = api_key) ) %>% response_status()
    
    if ( res$status == 429 ) { 
      Sys.sleep(res$GET+1) # Possible because the wait never more than 2 minutes
      res <- GET(paste0( base.url,path,URLencode(gameName[i]),"/",URLencode(tagLine[i]) ),add_headers("X-Riot-Token" = api_key) ) %>% response_status()
    } 
    
    if ( res$status == 200 ) { 
      df <- add_row(df, puuid=res$puuid, gameName=gameName[i], tagLine=tagLine[i] ) }
    if ( (res$status != 200) & (res$status != 429) ) { 
      df <- add_row(df, puuid="FUCK",    gameName=gameName[i], tagLine=tagLine[i] ) }
  }
  print("end")
  return(df)
}

#'**************************************************************************** *

#' * NEEDS TO BE OPTIMIZED FOR N API_KEYS NOW IT WORKS FOR 3 *
#' Return all the possible PUUID for a given gameName/tagLine combbination
#' @param gameName component of the secondary key for a Riot account, first in the GET method
#' @param tagLine  component of the secondary key for a Riot account, second in the GET method
#' @param vecAPIKey is where I saved all the API_key, it's a DB of 1 row and n variables. If I used a vector I couldn't name the elements without having more trouble, also it works easily is I read the keys froma  txt
# @path /riot/account/v1/accounts/by-riot-id/{gameName}/{tagLine}
#' 
NtoPuuid <- function(gameName,tagLine,vecAPIKey = API_KEY_vec) {
  
  df <- LoR.Account.base
  base.url <- "https://europe.api.riotgames.com"; path <- "/riot/account/v1/accounts/by-riot-id/"
  
  res1 <- GET(paste0( base.url,path,URLencode(gameName),"/",tagLine),add_headers("X-Riot-Token" = vecAPIKey[1]) ) %>% response_status()
  res2 <- GET(paste0( base.url,path,URLencode(gameName),"/",tagLine),add_headers("X-Riot-Token" = vecAPIKey[2]) ) %>% response_status()
  res3 <- GET(paste0( base.url,path,URLencode(gameName),"/",tagLine),add_headers("X-Riot-Token" = vecAPIKey[3]) ) %>% response_status()
  
  if ( any( c(res1$status,res2$status,res3$status)!=200 ) ) { return(df) } # empty in order not to mess witht the binds
  
  df <- add_row(df, puuid_1=res1$puuid, puuid_2=res2$puuid, puuid_3=res3$puuid, gameName=gameName, tagLine=tagLine )
  return(df)
}

#'**************************************************************************** *

#' Receive a vector of 1:n puuid and return the appropriate AccountDto for game (lor/val) and activeShard (server)
#' 
#' @param list.puuid the list of puuid you want to check. *Be aware that those puuid needs to be appropriate for the API_KEY used or will return status400*
#' @param api_key the necessary token for a Riot-API method
# @path /riot/account/v1/active-shards/by-game/{game}/by-puuid/{puuid}
#' 
Account_Shard <- function(list.puuid, api_key ) {
  df <- data.frame(puuid       = character(),
                   game        = character(),    # the call i'm using should make it so this value should always be "lor"
                   activeShard = character()     # the server
  )
  
  base.url <- "https://europe.api.riotgames.com"; path <- "/riot/account/v1/active-shards/by-game/lor/by-puuid/"
  
  
  for (i in 1:length(list.puuid) ) {
    cat(i," ")
    res <- GET(paste0( base.url,path,list.puuid[i] ),add_headers("X-Riot-Token" = api_key) ) %>% response_status()
    
    if ( res$status == 429 ) { 
      Sys.sleep(res$GET+1)
      res <- GET(paste0( base.url,path,list.puuid[i] ),add_headers("X-Riot-Token" = api_key) ) %>% response_status()
    }
    if ( (res$status != 429) & (res$status != 200) ) { 
      df <- add_row(df, puuid=list.puuid[i], game="FUCK", activeShard="FUCK" ) }
    if ( res$status == 200 ) { 
      df <- add_row(df, puuid=res$puuid, game=res$game, activeShard=res$activeShard) }
  }
  print("end")
  return(df)
}

#'**************************************************************************** *

#' Check is there are any new puuid and return the combination of puuid and the number of the appropriate key
#' 
#' @param DTAccount Datatable of the accounts with the puuid column, *will seatch for the column that start with puuid*
#' @param DTMatch   Datatable with the matchses metadata
#' 
#' @note will only seatch in Ranked and Seasonal games
newPuuids <- function(DTAccount=LoR.Account, DTMatch=LoR.Match.DT  ) {
  
  namesPuuid.col <- LoR.Account %>% select(ends_with("_1"),ends_with("_2"),ends_with("_3") ) %>% names()
  # namesPuuid.col <- DTAccount %>% select(starts_with("puuid")) %>% names()
  
  DTMatch <- copy(DTMatch)
  DTMatch <- DTMatch %>% select(game_type,game_mode,puuid_1,puuid_2,origin) %>% filter(game_type=="Ranked" | game_mode=="SeasonalTournamentLobby")
  
  RankedPuuid <- melt( DTMatch[, .(puuid_1,puuid_2,origin) ], id.vars = c("origin"), measure.vars=c("puuid_1","puuid_2"),value.name=c("puuid") ) %>% select(origin,puuid) %>% distinct()
  RankedPuuid <- RankedPuuid[puuid %!in% unlist( LoR.Account[,.SD, .SDcols=namesPuuid.col], use.names = F ), .(puuid,origin)]
  
  return(RankedPuuid)
}

#' Update the missing puuid of a specific account
#'
#' @param api_key  API key for the specific account I want to recover the puuid
#' @param puuid_col column name of the variable containing the missing puuid (puuid_1...)
#' @param DT data.table where I collect the accounts / default LoR.Account
#' @example update_missing_puuid(API_KEY_vec[1], puuid_1, LoR.Account) #'[UPDATE the puuid - MAOUVIVI]
update_missing_puuid <- function(api_key,puuid_col,DT) {
  # missingPuudid <- LoR.Account %>% filter( is.na(puuid_1) | is.na(puuid_2) | is.na(puuid_2) | puuid_1=="" | puuid_2=="" | puuid_3=="" ) %>% select(gameName,tagLine)
  # LoR.Account %>% filter( is.na("puuid_1") | is.na("puuid_2") | is.na("puuid_2") | "puuid_1"=="" | "puuid_2"=="" | "puuid_3"=="" ) %>% select("gameName","tagLine","puuid_1")
  
  # api_key <- API_KEY_vec[4]
  # rm(api_key)
  
  # LoR.Account %>% filter( is.na(puuid_4) | puuid_4=="" ) %>% select(puuid_4,gameName,tagLine)
  
  missingPuuid <- {{DT}} %>% filter( is.na({{puuid_col}}) | {{puuid_col}}=="" ) %>% select({{puuid_col}},gameName,tagLine)
  # missingPuuid
  colNames <-  names(missingPuuid)
  
  check <- which(API_KEY_vec == api_key) == str_sub(colNames[1],start = -1) %>% as.numeric()
  # which(API_KEY_vec == api_key) == str_sub(c("puuid_4","gameName","tagLine")[1],start = -1) %>% as.numeric()
  
  if ( !check ) {
    stop("You may be updating the wrong puuid with this key, check again")
  }
  
  print(paste0("Searching for ",NROW(missingPuuid) ))
  
  if ( NROW(missingPuuid) > 0 ) {
    preUpdate.Account <- {{DT}} %>% filter( !(is.na({{puuid_col}}) | {{puuid_col}}=="") ) %>% NROW()
    PUUID <- get_puuid(gameName = missingPuuid$gameName, tagLine=missingPuuid$tagLine,api_key = api_key )
    colnames(PUUID) <- colNames
    n <- colNames
    DT[PUUID, on=.(gameName,tagLine), (n):=mget(paste0("i.", n))]
    
    postUpdate.Account <- {{DT}} %>% filter( !(is.na({{puuid_col}}) | {{puuid_col}}=="") ) %>% NROW()
    
    print(paste0("preUpdate: ",preUpdate.Account," postUpdate: ",postUpdate.Account))
  }
}

# LoR.Account.sample <- copy( LoR.Account %>% sample_n(100) )
# update_missing_puuid(API_KEY_vec[4], puuid_4, LoR.Account.sample)


#' Update the missing game/activeShard
#' will only works with puuid_1 and its key
#'
#' @param DT data.table where I collect the accounts / default LoR.Account
#' 
update_missing_activeShard <- function(DT) {
  
  # missingShards <- LoR.Account %>% filter( puuid_1 != "FUCK" & ( is.na(activeShard) | activeShard=="" ) ) %>% select(puuid_1,game,activeShard)
  missingShards <- {{DT}} %>% filter( puuid_1 != "FUCK" & ( is.na(activeShard) | activeShard=="" ) ) %>% select(puuid_1,game,activeShard)
  colNames <-  names(missingShards)
  print(paste0("Searching for ",NROW(missingShards) ))
  
  if (NROW(missingShards)>0) {
    
    preUpdate.Account <- {{DT}} %>% filter( is.na(activeShard) | activeShard=="" ) %>% NROW()
    
    MissingShards.DT <- Account_Shard(missingShards$puuid_1,api_key = API_KEY_vec[1])
    setDT(MissingShards.DT)
    MissingShards.DT <- MissingShards.DT[ puuid != "FUCK" ,]
    # if (NROW(MissingShards.DT) > 0) {
    colnames(MissingShards.DT) <- colNames
    n <- colNames
    DT[MissingShards.DT, on=.(puuid_1), (n):=mget(paste0("i.", n))]
    # }
    
    postUpdate.Account <- {{DT}} %>% filter( is.na(activeShard) | activeShard=="" ) %>% NROW()
    print(paste0("preUpdate: ",preUpdate.Account," postUpdate: ",postUpdate.Account))
  }
}
# update_missing_activeShard(LoR.Account) #'[UPDATE SHARDS]

#' Update a DT of LoR accounts by their secondary key / gameName and tagLine / also remove duplicated from both of them
#' 
#' @param newplayers a table of gameName and tagLine
#' @param DT which dt to update / default is LoR.Account
update_lor_account <- function(newplayers,DT=LoR.Account) {
  print(paste("Number of rows before update: ",DT[,.N]))
  newplayers  <- newplayers  %>% distinct(gameName,tagLine,.keep_all = T)  %>% select(gameName,tagLine)
  DT <- add_row(DT, gameName=newplayers[,gameName] ,tagLine=newplayers[,tagLine]  ) 
  DT <- DT %>% distinct(gameName,tagLine,.keep_all = T) # just to be sure
  print(paste("Number of rows after update: ",DT[,.N]))
  return(DT)
}

#'**************************************************************************** *
# SUMMONER ----------------------------------------------------------------
#'**************************************************************************** *

#'*SISTEMARE*
summonerDTO <- function(call) {
  # "X-Method-Rate-Limit": "2000:60" per il server EU
  # receive a 200 status call and return the 7 variable from the GET call
  # call <- SummonerDTO.EUW
  list <- fromJSON(rawToChar(call$content))
  res <- LoR_Players[FALSE,c("id","accountId","puuid","name","profileIconId","revisionDate","summonerLevel")] # Players.name, Master, Add are excluded in this function
  res[1,c(1:5,7)] <- list[c(1:5,7)] # char
  res[1,6]        <- .POSIXct((as.numeric(list[6]))/1000, tz="UTC") # date
  return(res)
}

#'**************************************************************************** *

#'*SISTEMARE*
lor_summoner <- function(summoner.name,api_key,server) {
  # "X-Method-Rate-Limit": "2000:60" per il server EU
  # Recover the summoner's info of a player by summoner name
  
  # api_key <- essential variable for all API call to Riot Games, must be refreshed each 24hrs
  # summoner.name <- the player I'm searching for
  # server <- to specify which server I want to get my data
  
  if (server %!in% levels.server ){
    print("You must insert a server value among one the possible ones...")
    return()
  }
  
  path <- "/lol/summoner/v4/summoners/by-name/"
  
  base.url <- case_when(
    server == "EU/EUW1" ~ "https://euw1.api.riotgames.com",
    server == "EU/EUN1" ~ "https://eun1.api.riotgames.com",
    server == "EU/RU"   ~ "https://ru.api.riotgames.com",
    server == "EU/TR1"  ~ "https://tr1.api.riotgames.com",
    server == "NA/NA1"  ~ "https://na1.api.riotgames.com",
    server == "NA/LA1"  ~ "https://la1.api.riotgames.com",
    server == "NA/LA2"  ~ "https://la2.api.riotgames.com",
    server == "NA/BR1"  ~ "https://br1.api.riotgames.com"
  )
  
  SummonerDTO <- GET(base.url, path = paste0( path,URLencode(summoner.name)), add_headers("X-Riot-Token" = api_key))
  # print(SummonerDTO)
  SummonerDTO <- response_status(SummonerDTO)
  
  res <- LoR.Players[F,-c(1,2)] # LoR_Players è la struttura del DB per i giocatori, presente nel file delle funzioni
  
  res[1,"responseStatus"] <- SummonerDTO$status
  res[1,"server"]         <- server
  
  if ( SummonerDTO$status == 404 ) { return(res) }
  if ( SummonerDTO$status == 429 ) { return(SummonerDTO$GET) }
  if ( SummonerDTO$status != 200 ) { return() }
  
  res[1,c(1:5,7)]         <- SummonerDTO[c(1:5,7)]
  res[1,"revisionDate"]   <- .POSIXct((as.numeric( SummonerDTO[6] ))/1000, tz="UTC")
  # res[1,"responseStatus"] <- SummonerDTO$status
  # res[1,"server"]         <- factor(server,levels.server) # not needed
  # res[1,"server"]         <- server
  res[1,"add"]            <- Sys.time()
  
  return(res)
}

# lor_summoner("GRANRODEO",api_key = API_KEY,"EU/EUW1")
# lor_summoner("Meliador0",api_key = API_KEY,"EU/EUW1")

#'**************************************************************************** *

lor_summoner.update <- function(df,api_key) {
  # "X-Method-Rate-Limit": "2000:60" per il server EU
  # gives the db rows for each player in the list of names
  # df - which df I have to update
  
  # idList <- which( is.na(LoR.Players.EUv2[1:10,]$responseStatus) )
  idList <- which( is.na(df$responseStatus) )
  
  for (i in idList) {
    cat(i," ") 
    summonerInfo <- lor_summoner(summoner.name = URLencode(df$players.name[i]),api_key = api_key,server = df$server[i])
    # summonerInfo <- lor_summoner(summoner.name = URLencode( "Meliador0" ),api_key = api_key,server = "EU/EUW1"  )
    
    if (length(summonerInfo)==1 ) { # condition true when response status is 429
      if ( summonerInfo > 120 ) {
        cat(" \n Method rate limit reached \n")
        break  
      }
      Sys.sleep(summonerInfo) # it returned the retry-after. I could make it return at the start of the loop and get a new call, or just repeat it after the wait
      summonerInfo <- lor_summoner(summoner.name = URLencode(df$players.name[i]),api_key = api_key,server = df$server[i])
    }
    df[i,-c(1,2)]  <- summonerInfo
  }
  return(df)
}

#'**************************************************************************** *
# LOR-MATCH-V1 -----------------------------------------------------------------
#'**************************************************************************** *

#'*SISTEMARE*
#' Recover the list of the "last 20 matches (at most) by a player"
#' @rate-limit [200 requests every 1 hours]
#' @param puuid  the primary key
#' @param server which server is he from
#' @param api_key token for the Riot-API
#' @param API_KEY the vector(DF) of all the API_key in use to see which account it's associated with
#' 
#' @example lor_match_list(puuid = LoR.Account[gameName=="SaltySimonSE",puuid_1],server = LoR.Account[gameName=="SaltySimonSE",activeShard],api_key = API_KEY[1,1] )
#' @example match.list.429 # lor_match_list(puuid = LoR.Account[gameName=="SaltySimonSE",puuid_1],server = LoR.Account[gameName=="SaltySimonSE",activeShard],api_key = API_KEY[1,1] )
#' 
#' # nchar("e3eb021d-4e35-43d2-a7a6-f34eb3abdc42") # The length of a match's id is 36char
lor_match_list <- function(puuid,server,api_key) {
  
  base.url <- get_path_server(server); path <- "/lor/match/v1/matches/by-puuid/";
  LoR_Matches <- GET(paste0( base.url,path,puuid,"/ids/" ),add_headers("X-Riot-Token" = api_key) )
  
  LoR.Match.History.base <- data.table( match_id  = character(),
                                        server = factor(levels = list.levels$status)
  )
  
  origin = which( API_KEY_vec == api_key )
  
  #'*SISTEMARE*
  if (LoR_Matches$status_code == 429){
    res <- as.numeric(LoR_Matches$headers$`retry-after`)
    return(list(res=res,status=LoR_Matches$status_code))
  }
  
  if (LoR_Matches$status_code != 200){
    print(paste("lor_match_list / status code:",LoR_Matches$status_code,"/",puuid))
    return(list(status=LoR_Matches$status_code))
  } else { 
    res <- unlist(fromJSON(rawToChar(LoR_Matches$content))) }
  
  return(list(res=res,status=LoR_Matches$status_code))
}




#'**************************************************************************** *

#' Return repeat a lor_match_list for a series of puuid.id
#' 
#' @param puuid.id the vector of puuid I have to cycle. Since the method rate is 200:3600
#' @param server   server of the players related to the puuid.id as I have to check the correct one to not have a 400 error
#' @rate-limit [200 requests every 1 hours]
#' 
lor_match_list_update <- function(puuid.id,server,api_key) {
  
  match.list.DF <- data.table(match_id = character(),
                              player   = character(), # Not Necessary, still useful
                              server=factor(levels = c("europe","asia","americas")))
  
  # puuid.id <- puuid.id[1:min(200,length(puuid.id))] # I actually always work with group of 100 values to consider and optimize the standard rate-limit (100:120)
  
  for (i in 1:length(puuid.id) )  {  
    
    Match.list <- lor_match_list(puuid = puuid.id[i], server = server, api_key =  api_key )
    
    if ( Match.list$status == 429 ) {
      pause <- as.numeric(Match.list$res)
      if (pause<125) {
        print(paste0("lor_match_list_update / standard rate limit reached. Wait for ",pause,"s")) 
        Sys.sleep(pause+1) 
        Match.list <- lor_match_list(puuid = puuid.id[i],server = server, api_key = api_key )
      } else { 
        print(paste0("lor_match_list_update / Hourly rate limit reached. Wait for ",pause,"s")) 
        break
      }
    }
    
    if ( Match.list$status == 200 ) {
      if ( length(Match.list$res)==0 ) { print(paste0("lor_match_list_update / Status 200 empty list - #",i," / ",puuid.id[i]));                          next }
      if ( length(Match.list$res) > 0 & length(Match.list$res) < 20 ) { print(paste0("lor_match_list_update / less than 20 Matches History - #",i," / ",puuid.id[i]))  }
      
      match.list.DF <- add_row(match.list.DF, match_id=Match.list$res,
                               player=puuid.id[i],
                               server=server)
    }
  }
  return(res=match.list.DF)
}
# lor_match_list_update(puuid.id = masterEU[rMasterEU[1:2], puuid_1 ] ,server = "europe"   ,api_key = API_KEY[1,1] )

#'**************************************************************************** *

#' Convert the player list from the PlayerDto in the metadata call into the proper DATABASE ROW to assign in the metadata.db
#' @param # playerMetadata - the ROW from the list of PlayerDto / the format I should pass is fromJSON(rawToChar(metadata$content))$info$players[i,]
#' @value [PlayerDto] made of
#' [puuid]   string
#' [deck_id] string
#' [deck_code] string / Code for the deck played. Refer to LOR documentation for details on deck codes.
#' [factions]	List[string] *I assume no more than 3 regions*
#' [game_outcome] string
#' [order_of_play] int
#' 
#' @example playerMetadata <- metadata.GET.200$info$players[1,]
#' @example assignPlayer(playerMetadata)
assignPlayer <- function(playerMetadata) {
  
  res <- LoR.Player.base
  res <- add_row(res)
  
  regions <- paste(unlist(playerMetadata$factions),collapse = ",")
  
  nfactions <- length(regions)
  
  res[1,c("puuid","deck_id","deck_code","game_outcome","order_of_play")] <- playerMetadata[-4] %>% as.list()
  res[1,"factions"] <- regions
  
  return(res)
}

# assignPlayer(playerMetadata)



#'**************************************************************************** *

#' Convert the list of elements from the metadata$content call into the proper vector to assign in the metadata.db
#' 
#' @param metadataList the CONTENT / CONVERTED FROM JSON
#' @example metadata.200 <- jsonlite::fromJSON(rawToChar(GET("https://europe.api.riotgames.com", path = paste0("/lor/match/v1/matches/","44a130ae-12f4-45f8-8a24-0b319265d616" ),add_headers("X-Riot-Token" = API_KEY_TEST ))$content)) 
#' @example metadata.404 <- jsonlite::fromJSON(rawToChar(GET("https://europe.api.riotgames.com", path = paste0("/lor/match/v1/matches/","ec1a8951-7da7-4f6e-9020-60b03eb49f3b" ),add_headers("X-Riot-Token" = API_KEY_TEST ))$content)) 
#' @example metadataList.AI <- fromJSON(rawToChar(GET("https://europe.api.riotgames.com", path = paste0("/lor/match/v1/matches/","894823fd-d0af-4f88-a3b3-bf4b108c7c38"),add_headers("X-Riot-Token" = API_KEY))$content)) # AI match
#' @value  [MetadataDto] made of
#' [data_version]	string	Match data version.
#' [match_id]	string	Match id.
#' [participants]	List[string]	A list of participant PUUIDs.
#' 
#' [InfoDto]
#' [game_mode]	   string	(Legal values: Constructed, Expeditions, Tutorial) / AND MORE
#' [game_type]     string	(Legal values: Ranked, Normal, AI, Tutorial, VanillaTrial, Singleton, StandardGauntlet) / AND MORE
#' [game_start_time_utc]	string	
#' [game_version]	 string	
#' [players]	     List[PlayerDto]	
#' [total_turn_count]	int	Total turns taken by both players.
#' 
#' [PlayerDto]
#' [puuid]	      string	
#' [deck_id]	    string	
#' [deck_code]	  string	Code for the deck played. Refer to LOR documentation for details on deck codes.
#' [factions]	    List[string]	
#' [game_outcome]	string	
#' [order_of_play]	int	The order in which the players took turns. 
#' @example assignMatch(metadata.200)
#' 
assignMatch <- function(metadataList) {
  
  out <- tryCatch({
    
    # rm(metadataList)
    # rm(res)
    # metadataList <- metadata.GET.200
    # metadataList <- metadata.GET.404
    
    res <- LoR.Metadata.base
    # res <- LoR.Metadata.base %>% tibble()
    
    res <- add_row(res)
    
    res[1,"status"] <- metadataList$status
    
    if (res$status==200){
      
      res[1,c("data_version")] <- metadataList$metadata$data_version
      res[1,c("match_id")]     <- metadataList$metadata$match_id
      
      nPartecipant <- NROW(metadataList$metadata$participants)
      
      res[1,c("participants_1","participants_2","participants_3","participants_4")][,1:nPartecipant] <- metadataList$metadata$participants %>% as.list()
      
      
      res[1,c("game_mode","game_type","game_start_time_utc","game_version")]     <- c(metadataList$info$game_mode,metadataList$info$game_type,metadataList$info$game_start_time_utc,metadataList$info$game_version) %>% as.list()
      res[1,"total_turn_count"] <- metadataList$info$total_turn_count
      
      nPlayer <- NROW(metadataList$info$players)
      
      if (nPlayer >= 1 ) { 
        res[1,c("puuid_1","deck_id_1","deck_code_1","factions_1","game_outcome_1","order_of_play_1")] <- assignPlayer(metadataList$info$players[1,]) %>% as.list()
      }
      if (nPlayer >= 2 ) { 
        res[1,c("puuid_2","deck_id_2","deck_code_2","factions_2","game_outcome_2","order_of_play_2")] <- assignPlayer(metadataList$info$players[2,]) %>% as.list()
      }
      if (nPlayer >= 3 ) {
        res[1,c("puuid_3","deck_id_3","deck_code_3","factions_3","game_outcome_3","order_of_play_3")] <- assignPlayer(metadataList$info$players[3,]) %>% as.list() 
      }
      if (nPlayer == 4 ) {
        res[1,c("puuid_4","deck_id_4","deck_code_4","factions_4","game_outcome_4","order_of_play_4")] <- assignPlayer(metadataList$info$players[4,]) %>% as.list() 
      }
    }
    
    res
  }, warning=function(w) {
    print(w)
    stop("converted from warning: ", conditionMessage(w))
    
  }, error=function(e) {
    message("Assign / Here's the original error message: \n")
    print(e)
    message(e)
    return(NULL)
  })
  
  return(out) 
}
# assignMatch(metadata.GET.200)
# assignMatch(metadata.GET.404)
# assignMatch(metadata.GET.429)

#'**************************************************************************** *

#' Return the metadata from a matchId
#' 
# @rate-limit [100 requests every 1 hours] <- Fuck Riot
# @path [/lor/match/v1/matches/{matchId}]
#' @param match.id the primary key of a match
#' @param server the server where the game was played
#' @param api_key to do the calls with Riot's API
#' 
# @result on object of [LoR.Metadata.base] which is the *metadata elements* plus *status*
#' @example lor_match_metadata(match.id = "44a130ae-12f4-45f8-8a24-0b319265d616",server = "europe",api_key = API_KEY_TEST) # 200
#' metadata.GET.200 <- GET("https://europe.api.riotgames.com", path = paste0("/lor/match/v1/matches/","44a130ae-12f4-45f8-8a24-0b319265d616" ),add_headers("X-Riot-Token" = API_KEY_TEST )) %>% response_status()
#' @example lor_match_metadata(match.id = "ec1a8951-7da7-4f6e-9020-60b03eb49f3b",server = "europe",api_key = API_KEY_TEST) # 404
#' metadata.GET.404 <- GET("https://europe.api.riotgames.com", path = paste0("/lor/match/v1/matches/","ec1a8951-7da7-4f6e-9020-60b03eb49f3b" ),add_headers("X-Riot-Token" = API_KEY_TEST )) %>% response_status()


lor_match_metadata <- function(match.id,server,api_key) {
  out <- tryCatch( 
    {
      res <- LoR.Metadata.base
      base.url <- get_path_server(server); path <- "/lor/match/v1/matches/";
      
      # metadata.404 <- GET("https://europe.api.riotgames.com", path = paste0("/lor/match/v1/matches/","5c52dab6-4a50-491e-afdd-fcf32cadba0c" ),add_headers("X-Riot-Token" = API_KEY_TEST )) %>% response_status()
      # metadata.404 %>% assignMatch()
      
      metadata <- GET(base.url, path = paste0(path,match.id ),add_headers("X-Riot-Token" = api_key)) %>% response_status()
      
      if (metadata$status == 429){ return(  metadata) }
      if (metadata$status != 200){ 
        res <- metadata %>% assignMatch()
        print( paste0("lor_match_metadata / status code: ",metadata$status," / ",match.id)  )
        return(res)
      }
      
      res <- assignMatch(metadata)
      res
      
    },
    error=function(e) {
      message("Match.Metadata / Error / Here's the original error message: \n")
      message(e)
      return(NULL)
    },
    warning=function(w) {
      message("Match.Metadata / Warning / Here's the original warning message: \n")
      message(w)
      return(NULL)
    }
  )
  return(out)
}

# GET("https://europe.api.riotgames.com", path = paste0("/lor/match/v1/matches/","44a130ae-12f4-45f8-8a24-0b319265d616" ),add_headers("X-Riot-Token" = API_KEY_TEST )) %>% response_status()
# match_metadata <- lor_match_metadata("44a130ae-12f4-45f8-8a24-0b319265d616","europe",API_KEY_TEST)
# lor_match_metadata(match.id = "44a130ae-12f4-45f8-8a24-0b319265d616",server = "europe",api_key = API_KEY_TEST) # 200
# lor_match_metadata_404 <- lor_match_metadata(match.id = "5c52dab6-4a50-491e-afdd-fcf32cadba0c",server = "europe",api_key = API_KEY_TEST) # 404
# lor_match_metadata_429 <- lor_match_metadata(match.id = "5c52dab6-4a50-491e-afdd-fcf32cadba0c",server = "europe",api_key = API_KEY_vec[1]) # 429

lor_match_metadata_json <- function(match.id,server,api_key) {
  out <- tryCatch( 
    {
      res <- LoR.Metadata.base
      base.url <- get_path_server(server); path <- "/lor/match/v1/matches/";
      
      # metadata.404 <- GET("https://europe.api.riotgames.com", path = paste0("/lor/match/v1/matches/","5c52dab6-4a50-491e-afdd-fcf32cadba0c" ),add_headers("X-Riot-Token" = API_KEY_TEST )) %>% response_status()
      # metadata.404 %>% assignMatch()
      
      metadata <- GET(base.url, path = paste0(path,match.id ),add_headers("X-Riot-Token" = api_key))
      
      
      
      if (metadata$status == 429){ return(  metadata) }
      if (metadata$status != 200){ 
        res <- metadata %>% assignMatch()
        print( paste0("lor_match_metadata / status code: ",metadata$status," / ",match.id)  )
        return(res)
      }
      
      res <- assignMatch(metadata)
      res
      
    },
    error=function(e) {
      message("Match.Metadata / Error / Here's the original error message: \n")
      message(e)
      return(NULL)
    },
    warning=function(w) {
      message("Match.Metadata / Warning / Here's the original warning message: \n")
      message(w)
      return(NULL)
    },
    finally={    }
  )
  return(out)
}


#'**************************************************************************** *

#' Function that apply the metadata search for a vector of Matches 
#' 
# @rate-limit [100 requests every 1 hours]
#' @param matchKeys vector of match_key I'll cycle
#' @param server the server where the game was played *SINGLE VALUE, I want to use this function for a group of matches from the SAME server* 
#' @param api_key to do the calls with Riot's API
#' 
# @example match_1 <- lor_match_metadata(match.id = "f208abc1-a12b-4333-8157-ec0e286e976f",server = "europe",api_key = API_KEY_TEST)
# @example match_2 <- lor_match_metadata(match.id = "001f224a-10ae-435b-9628-a4b8cf5cf608",server = "europe",api_key = API_KEY_TEST)
# @example metadata_n <- lor_match_metadata_update(matchKeys = c("f208abc1-a12b-4333-8157-ec0e286e976f","001f224a-10ae-435b-9628-a4b8cf5cf608"),server = "europe",api_key = API_KEY_TEST)
lor_match_metadata_update <- function(matchKeys,server,api_key) {
  
  # matchKeys = c("f208abc1-a12b-4333-8157-ec0e286e976f","001f224a-10ae-435b-9628-a4b8cf5cf608")
  # server="europe"
  # api_key=API_KEY_TEST
  
  # n <- length(matchKeys)
  df <- data.table( match_key=character(),
                    origin = numeric(),
                    LoR.Metadata.base
  )
  # df <- add_row(df)
  
  # print(server)
  matchKeys <- matchKeys[1:min(100,length(matchKeys))] # I actually always work with group of 100 values to consider and optimize the standard rate-limit (100:120)  
  n <- length(matchKeys)
  
  for (i in 1:n )  {
    # cat(i," ")
    
    match.metadata <- lor_match_metadata(match.id = matchKeys[i],server =  server, api_key = api_key)
    
    if ( match.metadata$status == 429 ) {
      pause <- match.metadata$GET
      if (pause<125) {
        Sys.sleep(pause+1) 
        match.metadata <- lor_match_metadata(match.id = matchKeys[i],server =  server, api_key = api_key)
      } 
      else { 
        assign("reStartMetaTime", (Sys.time()+pause+10), envir = .GlobalEnv)
        break 
      }
    }
    if ( match.metadata$status != 429 ) {
      
      df <- add_row(df,
                    match_key = matchKeys[i],
                    origin = which(API_KEY_vec==api_key),
                    match.metadata)
    }
  }
  df <- as.data.table(df)
  return(df)
}

#'**************************************************************************** *
# MATCHES GET -------------------------------------------------------------
#'**************************************************************************** *

#' #'[Master players]
playerEU   <- LoR.Account[activeShard=="europe" & master=="master"]
# playerEU   <- LoR.Account[activeShard=="europe" & seasonal=="seasonal"]
playerEU   <- playerEU %>% slice_sample(n=min(NROW(playerEU),600), replace = F)
# playerEU   <- playerEU %>% slice_tail(n=600)

playerNA   <- LoR.Account[activeShard=="americas" & master=="master"    ]
# playerNA   <- LoR.Account[activeShard=="americas" & seasonal=="seasonal"]
playerNA   <- playerNA %>% slice_sample(n=min(NROW(playerNA),600), replace = F)
# playerNA   <- playerNA %>% slice_tail(n=600)

playerASIA <- LoR.Account[activeShard=="asia"   & master=="master"]
# playerASIA <- LoR.Account[activeShard=="asia" & seasonal=="seasonal"]
playerASIA <- playerASIA %>% slice_sample(n=min(NROW(playerASIA),600), replace = F)

print("EU_1")
if ( NROW(playerEU) > 000    ) { Update.Match.EU_1100 <- lor_match_list_update(puuid.id = playerEU[ 001:min(100,NROW(playerEU)), puuid_1 ] ,server = "europe"   ,api_key = API_KEY_vec[1] ) }
if ( NROW(playerEU) > 100    ) { Update.Match.EU_2100 <- lor_match_list_update(puuid.id = playerEU[ 101:min(200,NROW(playerEU)), puuid_2 ] ,server = "europe"   ,api_key = API_KEY_vec[2] ) }
if ( NROW(playerEU) > 200    ) { Update.Match.EU_3100 <- lor_match_list_update(puuid.id = playerEU[ 201:min(300,NROW(playerEU)), puuid_3 ] ,server = "europe"   ,api_key = API_KEY_vec[3] ) }
#
print("NA_1")
if ( NROW(playerNA) > 000    ) { Update.Match.NA_1100 <- lor_match_list_update(puuid.id = playerNA[ 001:min(100,NROW(playerNA)), puuid_1 ] ,server = "americas" ,api_key = API_KEY_vec[1] ) }
if ( NROW(playerNA) > 100    ) { Update.Match.NA_2100 <- lor_match_list_update(puuid.id = playerNA[ 101:min(200,NROW(playerNA)), puuid_2 ] ,server = "americas" ,api_key = API_KEY_vec[2] ) }
if ( NROW(playerNA) > 200    ) { Update.Match.NA_3100 <- lor_match_list_update(puuid.id = playerNA[ 201:min(300,NROW(playerNA)), puuid_3 ] ,server = "americas" ,api_key = API_KEY_vec[3] ) }
# 
print("ASIA_1")
if ( NROW(playerASIA) > 000  ) { Update.Match.AS_1100 <- lor_match_list_update(puuid.id = playerASIA[ 001:min(100,NROW(playerASIA)), puuid_1 ] ,server = "asia" ,api_key = API_KEY_vec[1] ) }
if ( NROW(playerASIA) > 100  ) { Update.Match.AS_2100 <- lor_match_list_update(puuid.id = playerASIA[ 101:min(200,NROW(playerASIA)), puuid_2 ] ,server = "asia" ,api_key = API_KEY_vec[2] ) }
if ( NROW(playerASIA) > 200  ) { Update.Match.AS_3100 <- lor_match_list_update(puuid.id = playerASIA[ 201:min(300,NROW(playerASIA)), puuid_3 ] ,server = "asia" ,api_key = API_KEY_vec[3] ) }
# 
print("EU_2")
if ( NROW(playerEU) > 300    ) { Update.Match.EU_1200 <- lor_match_list_update(puuid.id = playerEU[ 301:min(400,NROW(playerEU)), puuid_1 ] ,server = "europe"   ,api_key = API_KEY_vec[1] ) }
if ( NROW(playerEU) > 400    ) { Update.Match.EU_2200 <- lor_match_list_update(puuid.id = playerEU[ 401:min(500,NROW(playerEU)), puuid_2 ] ,server = "europe"   ,api_key = API_KEY_vec[2] ) }
if ( NROW(playerEU) > 500    ) { Update.Match.EU_3200 <- lor_match_list_update(puuid.id = playerEU[ 501:min(600,NROW(playerEU)), puuid_3 ] ,server = "europe"   ,api_key = API_KEY_vec[3] ) }
# 
print("NA_2")
if ( NROW(playerNA) > 300    ) { Update.Match.NA_1200 <- lor_match_list_update(puuid.id = playerNA[ 301:min(400,NROW(playerNA)), puuid_1 ] ,server = "americas" ,api_key = API_KEY_vec[1] ) }
if ( NROW(playerNA) > 400    ) { Update.Match.NA_2200 <- lor_match_list_update(puuid.id = playerNA[ 401:min(500,NROW(playerNA)), puuid_2 ] ,server = "americas" ,api_key = API_KEY_vec[2] ) }
if ( NROW(playerNA) > 500    ) { Update.Match.NA_3200 <- lor_match_list_update(puuid.id = playerNA[ 501:min(600,NROW(playerNA)), puuid_3 ] ,server = "americas" ,api_key = API_KEY_vec[3] ) }
# 
print("ASIA_2")
if ( NROW(playerASIA) > 300  ) { Update.Match.AS_1200 <- lor_match_list_update(puuid.id = playerASIA[ 301:min(400,NROW(playerASIA)), puuid_1 ] ,server = "asia" ,api_key = API_KEY_vec[1] ) }
if ( NROW(playerASIA) > 400  ) { Update.Match.AS_2200 <- lor_match_list_update(puuid.id = playerASIA[ 401:min(500,NROW(playerASIA)), puuid_2 ] ,server = "asia" ,api_key = API_KEY_vec[2] ) }
if ( NROW(playerASIA) > 500  ) { Update.Match.AS_3200 <- lor_match_list_update(puuid.id = playerASIA[ 501:min(600,NROW(playerASIA)), puuid_3 ] ,server = "asia" ,api_key = API_KEY_vec[3] ) }
#
print("END")

endMatchTime  <- Sys.time()
beep(2)

#'**************************************************************************** *
# UPDATE MATCH HISTORY AND DT ---------------------------------------------
#'**************************************************************************** *

Update.match <- do.call(rbind, mget( ls(pattern = 'Update.Match') ))

l0 <- NROW(Update.match);
Update.match <- Update.match %>% distinct(match_id, .keep_all = TRUE) 
l1 <- NROW(Update.match);
Update.match <- Update.match[which(Update.match$match_id %!in% LoR.Match.DT$match_key),] 
l2 <- NROW(Update.match);
LoR.Match.DT <- add_row(LoR.Match.DT, match_key=Update.match$match_id, server=Update.match$server)

print(paste0("Matches found: ",l0," / Unique: ",l1," / New and Unique: ",l2))

fwrite(Update.match,paste0("Update_Match",format(Sys.time(),"%Y-%m-%dT%H%M"),".csv"))
# fwrite(LoR.Match.History,paste0("LoR_HISTORY_",format(Sys.time(),"%Y-%m-%dT%H%M"),".csv"))

rm(list=ls(pattern="Update.Match"))
# ls()
beep("treasure")

#'**************************************************************************** *
# METADATA ------------------------------------------------------------------------
#'**************************************************************************** *

live_patch_min <- LoR.Match.DT[,str_detect(game_mode, 'Seasonal') & str_detect(game_version, '2_10') ] %>% which() %>% min()
# live_patch_min <- LoR.Match.DT[,str_detect(game_version, '2_10') ] %>% which() %>% min()
SearchDT       <- LoR.Match.DT[live_patch_min:NROW(LoR.Match.DT)][is.na(status) | status %!in% c(200,404),c("match_key","server","status")] %>% as_tibble()

#'**************************************************************************** *
# EXTRA ------------------------------------------------------------------------
#'**************************************************************************** *

EXrMatchEU    <- SearchDT %>% filter(server=="europe"   & is.na(status)) %>% select(match_key) %>% slice_sample(n=100) %>% pull()
EXrMatchNA    <- SearchDT %>% filter(server=="americas" & is.na(status)) %>% select(match_key) %>% slice_sample(n=100) %>% pull()
EXrMatchASIA  <- SearchDT %>% filter(server=="asia"     & is.na(status)) %>% select(match_key) %>% slice_sample(n=100) %>% pull()
print("Extra")
Seasonal.Meta.EU <- lor_match_metadata_update(matchKeys = EXrMatchEU,   server = "europe",  api_key = API_KEY_vec[4])
Seasonal.Meta.NA <- lor_match_metadata_update(matchKeys = EXrMatchNA,   server = "americas",api_key = API_KEY_vec[4])
Seasonal.Meta.AS <- lor_match_metadata_update(matchKeys = EXrMatchASIA, server = "asia",    api_key = API_KEY_vec[4])

Seasonal.Meta <- do.call(rbind, mget( ls(pattern = 'Seasonal.Meta')))

Seasonal.Meta[game_mode=="SeasonalTournamentLobby"]

back.Seasonal <- Seasonal.Meta



#'**************************************************************************** *
# METADATA ----------------------------------------------------------------
#'**************************************************************************** *

SeasonalMin <- which(LoR.Match.DT[, game_mode=="SeasonalTournamentLobby"]) %>% min()
SeasonalMax <- which(LoR.Match.DT[, game_mode=="SeasonalTournamentLobby"]) %>% max()
IndexSesonal <- c(SeasonalMin:SeasonalMax)[which(LoR.Match.DT[SeasonalMin:SeasonalMax, game_mode=="SeasonalTournamentLobby"])]

minus2  <- LoR.Match.DT[ IndexSesonal-2, ]
minus1  <- LoR.Match.DT[ IndexSesonal-1, ]
plus1   <- LoR.Match.DT[ IndexSesonal+1, ]
plus2   <- LoR.Match.DT[ IndexSesonal+2, ]
plus3   <- LoR.Match.DT[ IndexSesonal+3, ]

rMatchEU     <- rbind(minus2,minus1,plus1,plus2,plus3) %>% filter(server=="europe"   & is.na(status)) %>% 
  slice_sample(n=300) %>% select(match_key) %>% pull()
rMatchNA     <- rbind(minus2,minus1,plus1,plus2,plus3) %>% filter(server=="americas" & is.na(status)) %>% 
  slice_sample(n=300) %>% select(match_key) %>% pull()
# rMatchASIA   <- rbind(minus1,plus1,plus2,plus3) %>% filter(server=="asia"     & is.na(status)) %>% select(match_key) %>% pull()
#
rm(minus1,plus1,plus2,plus3,SeasonalMax,SeasonalMin,IndexSesonal)

# LoR.Account[str_detect(gameName,"Nunu")]

#'**************************************************************************** *
# GET --------------------------------------------------------------------------
#'**************************************************************************** *

rMatchEU     <- c(
  rMatchEU,
  SearchDT %>% filter(server=="europe"   & status %in% c(503,403,400) ) %>% pull(match_key),
  LoR.Match.DT[Seasonal.Meta[game_mode=="SeasonalTournamentLobby"], on=.(match_key) ][ server=="europe" & status==404, match_key],
  LoR.Match.DT[Seasonal.Meta[game_mode=="SeasonalTournamentLobby"], on=.(match_key) ][ server=="europe" & status==200, match_key],
  # SearchDT %>% filter(server=="europe"   & is.na(status)) %>% select(match_key) %>% slice_tail(n=300) %>% pull(),
  SearchDT %>% filter(server=="europe"   & is.na(status)) %>% select(match_key)   %>% slice_sample(n=300) %>% pull()
)

rMatchNA     <- c(
  rMatchNA,
  SearchDT %>% filter(server=="americas" & status %in% c(503,403,400) ) %>% pull(match_key),
  LoR.Match.DT[Seasonal.Meta[game_mode=="SeasonalTournamentLobby"], on=.(match_key) ][ server=="americas" & status==404, match_key],
  LoR.Match.DT[Seasonal.Meta[game_mode=="SeasonalTournamentLobby"], on=.(match_key) ][ server=="americas" & status==200, match_key],
  # SearchDT %>% filter(server=="americas" & is.na(status)) %>% select(match_key)  %>% slice_tail(n=300) %>% pull(),
  SearchDT %>% filter(server=="americas" & is.na(status)) %>% select(match_key)  %>% slice_sample(n=300) %>% pull()
)

rMatchASIA   <- c(
  SearchDT %>% filter(server=="asia"     & status %in% c(503,403,400) ) %>% pull(match_key),
  # LoR.Match.DT[Seasonal.Meta[game_mode=="SeasonalTournamentLobby"], on=.(match_key) ][ server=="asia", match_key],
  # LoR.Match.DT[(live_patch_min-300000):live_patch_min][server=="asia"][is.na(status) | status %!in% c(200,404),c("match_key","server","status")] %>% as_tibble() %>% select(match_key) %>% slice_tail(n=300) %>% pull()
  SearchDT %>% filter(server=="asia"     & is.na(status)) %>% select(match_key) %>% slice_sample(n=300) %>% pull()
)

print("EU")
if ( length(rMatchEU) > 0    ) { Update.Meta.EU01 <- lor_match_metadata_update(matchKeys = rMatchEU[001:min(100,length(rMatchEU))], server = "europe",  api_key = API_KEY_vec[1]) }
if ( length(rMatchEU) > 100  ) { Update.Meta.EU02 <- lor_match_metadata_update(matchKeys = rMatchEU[101:min(200,length(rMatchEU))], server = "europe",  api_key = API_KEY_vec[2]) }
if ( length(rMatchEU) > 200  ) { Update.Meta.EU03 <- lor_match_metadata_update(matchKeys = rMatchEU[201:min(300,length(rMatchEU))], server = "europe",  api_key = API_KEY_vec[3]) }
print("NA")
if ( length(rMatchNA) > 0    ) { Update.Meta.NA01 <- lor_match_metadata_update(matchKeys = rMatchNA[001:min(100,length(rMatchNA))], server = "americas",api_key = API_KEY_vec[1]) }
if ( length(rMatchNA) > 100  ) { Update.Meta.NA02 <- lor_match_metadata_update(matchKeys = rMatchNA[101:min(200,length(rMatchNA))], server = "americas",api_key = API_KEY_vec[2]) }
if ( length(rMatchNA) > 200  ) { Update.Meta.NA03 <- lor_match_metadata_update(matchKeys = rMatchNA[201:min(300,length(rMatchNA))], server = "americas",api_key = API_KEY_vec[3]) }
print("ASIA")
if ( length(rMatchASIA) > 0    ) { Update.Meta.AS01 <- lor_match_metadata_update(matchKeys = rMatchASIA[001:min(100,length(rMatchASIA)) ], server = "asia",  api_key = API_KEY_vec[1]) }
if ( length(rMatchASIA) > 100  ) { Update.Meta.AS02 <- lor_match_metadata_update(matchKeys = rMatchASIA[101:min(200,length(rMatchASIA)) ], server = "asia",  api_key = API_KEY_vec[2]) }
if ( length(rMatchASIA) > 200  ) { Update.Meta.AS03 <- lor_match_metadata_update(matchKeys = rMatchASIA[201:min(300,length(rMatchASIA)) ], server = "asia",  api_key = API_KEY_vec[3]) }

Update.meta <- do.call(rbind, mget( ls(pattern = 'Update.Meta')))

reStartMetaTime <- Sys.time()+3600
beep(2)

#'**************************************************************************** *
# UPDATE ------------------------------------------------------------------
#'**************************************************************************** *

fwrite(Update.meta,paste0("Update_meta_",format(Sys.time(),"%Y-%m-%dT%H%M"),".csv"))

# cols = c("match_key","server")
# LoR.Match.DT[Update.meta[origin==1,match_key], on=.(match_key), !cols , with=FALSE]
# LoR.Match.DT[Update.meta[origin==1,match_key], on=.(match_key), ..("match_key","server")]
# data.table::setnafill(df,fill = 0, cols = colnames(df)[!(colnames(df) %in% c("Date", thatCol)]))

# print(table(LoR.Match.DT$status, useNA = "ifany"))
# 
# LoR.Match.DT %>%
#   filter( match_key %in% Update.meta[origin==1,match_key] ) %>%
#   mutate_at(vars(-c(match_key,server)), function(x) x = NA)
# 
# print(table(LoR.Match.DT$status, useNA = "ifany"))  

print("Update status:")
print(table(Update.meta$status ,useNA = "ifany"))
print("Date of update:")
print(table(str_sub(Update.meta$game_start_time_utc,1,10)));
print("Game mode of update:")
print(table(Update.meta$game_mode, useNA = "ifany"));

#'**************************************************************************** *
setindex(LoR.Match.DT, NULL)

n <- names(Update.meta)
LoR.Match.DT[Update.meta, on=.(match_key), (n):=mget(paste0("i.", n))]
#'**************************************************************************** *

print("DT status table:")
print(table(LoR.Match.DT$status, useNA = "ifany"))

# print("Status Update by server:")
# LoR.Match.DT %>% filter(server=="europe")   %>% pull(status) %>% table(.,useNA = "ifany") %>% print(.)
# LoR.Match.DT %>% filter(server=="americas") %>% pull(status) %>% table(.,useNA = "ifany") %>% print(.)
# LoR.Match.DT %>% filter(server=="asia")     %>% pull(status) %>% table(.,useNA = "ifany") %>% print(.)

# LoR.Match.DT[match_key %!in% LoR.Match.History[,match_key]]

rm(list=ls(pattern="Update.Meta"))
rm(list=ls(pattern="Seasonal.Meta"))

#'**************************************************************************** *
# ACCOUNT ----------------------------------------------------------------------
#'**************************************************************************** *

EULeaderBoard   <- fromJSON(rawToChar( GET("https://europe.api.riotgames.com",   path = "/lor/ranked/v1/leaderboards/", add_headers("X-Riot-Token" = API_KEY_vec[4] ))$content ))
NALeaderBoard   <- fromJSON(rawToChar( GET("https://americas.api.riotgames.com", path = "/lor/ranked/v1/leaderboards/", add_headers("X-Riot-Token" = API_KEY_vec[4] ))$content ))
ASIALeaderBoard <- fromJSON(rawToChar( GET("https://asia.api.riotgames.com",     path = "/lor/ranked/v1/leaderboards/", add_headers("X-Riot-Token" = API_KEY_vec[4] ))$content ))

masterEU   <- LoR.Account[activeShard=="europe"   & master=="master" ]
masterNA   <- LoR.Account[activeShard=="americas" & master=="master" ]
masterASIA <- LoR.Account[activeShard=="asia"     & master=="master" ]

if (NROW(EULeaderBoard$players$name) > NROW(masterEU) ) {
  print(paste("New EU Master:",NROW(EULeaderBoard$players$name)-NROW(masterEU) ))
  print(vsetdiff(EULeaderBoard$players$name,masterEU$gameName))
}
namesList.EU   <- EULeaderBoard$players$name

if (NROW(NALeaderBoard$players$name) > NROW(masterNA) ) {
  print(paste("New NA Master:",NROW(NALeaderBoard$players$name)-NROW(masterNA)))
  print(vsetdiff(NALeaderBoard$players$name,masterNA$gameName))
}
namesList.NA   <- NALeaderBoard$players$name

if (NROW(ASIALeaderBoard$players$name) > NROW(masterASIA) ) {
  print(paste("New ASIA Master:",NROW(ASIALeaderBoard$players$name)-NROW(masterASIA)))
  print(vsetdiff(ASIALeaderBoard$players$name,masterASIA$gameName))
}
namesList.ASIA <- ASIALeaderBoard$players$name

# LoR.Account <- LoR.Account %>% select(!RiotID)

#'**************************************************************************** *
# QUALITY CHECK -----------------------------------------------------------
#'**************************************************************************** *

# LoR.Account[,.N]
# LoR.Account %>% distinct(gameName,tagLine) %>% NROW()

# LoR.Account[, nchar(gameName) %>% table(.,useNA = "always") ]
# LoR.Account[is.na(gameName), ]

# LoR.Account[is.na(puuid_1),]
# LoR.Account[puuid_1=="FUCK",]
# LoR.Account[puuid_1=="FUCK",puuid_1:=NA]
# LoR.Account[is.na(puuid_2),]
# LoR.Account[puuid_2=="FUCK",]
# LoR.Account[puuid_2=="FUCK",puuid_2:=NA]
# LoR.Account[is.na(puuid_3),]
# LoR.Account[puuid_3=="FUCK",]
# LoR.Account[puuid_3=="FUCK",puuid_3:=NA]
# LoR.Account[is.na(puuid_4),]
# LoR.Account[puuid_4=="FUCK",]
# LoR.Account[puuid_4=="FUCK",puuid_4:=NA]
# 
# LoR.Account %>% filter(gameName == "FUCK") # seems safe
# LoR.Account %>% filter(tagLine  == "FUCK") # seems safe
# LoR.Account %>% filter(game == "FUCK")        # seems safe
# LoR.Account %>% filter(activeShard == "FUCK") # seems safe

#'**************************************************************************** *
# UPDATE ------------------------------------------------------------------
#'**************************************************************************** *

# DT <- newPuuids()

if ( NROW(DT) > 0 ) {
  
  NewPlayers  <- get_account_by_puuid(DT$puuid,API_KEY_vec,DT$origin)
  
  # NewPlayers  <- get_account_by_puuid(newmaster,API_KEY_vec,1)
  
  LoR.Account <- rbind(LoR.Account,NewPlayers)
  # LoR.Account <- update_lor_account(NewPlayers,LoR.Account)
  print("Key 1:")
  update_missing_puuid(API_KEY_vec[1], puuid_1, LoR.Account) #'[UPDATE the puuid - MAOUVIVI]
  print("Key 2:")
  update_missing_puuid(API_KEY_vec[2], puuid_2, LoR.Account) #'[UPDATE the puuid - LEGNAVV]
  print("Key 3:")
  update_missing_puuid(API_KEY_vec[3], puuid_3, LoR.Account) #'[UPDATE the puuid - JARODPARKER]
  print("Key 4:")
  update_missing_puuid(API_KEY_vec[4], puuid_4, LoR.Account) #'[UPDATE the puuid - HARRYJP78]
  print("Shard / Game:")
  update_missing_activeShard(LoR.Account) #'[UPDATE SHARDS]
  
  LoR.Account <- LoR.Account %>% distinct(gameName,tagLine,.keep_all = T)
  
}

LoR.Account
LoR.Account

#'**************************************************************************** *
# PREPARE -----------------------------------------------------------------
# I search the Master Puuid among the ranked games and the Seasonal
#'**************************************************************************** *

# LoR.Match.DT[ game_version>="live_2_7_5" ] 

# Seasonal
# HighRanked.puuid <- LoR.Match.DT[ game_type=="Ranked" | game_mode=="SeasonalTournamentLobby", .(match_key,puuid_1,puuid_2,origin,server) ]
HighRanked.puuid <- LoR.Match.DT[ game_type=="Ranked" & game_version>"live_2_10", .(match_key,puuid_1,puuid_2,origin,server) ]
HighRanked.puuid.Melt <- HighRanked.puuid %>% melt(., id.vars = c("match_key","server"), measure.vars=c("puuid_1","puuid_2"),value.name=c("puuid") ) %>% distinct(puuid,.keep_all = T)

if ( NROW(HighRanked.puuid.Melt %>% filter(puuid=="FUCK")) > 0 ) {
  stop("ATTENTION!!! A troublesome username may start to mess with the process, resolve it fast!")
}


LoR.Account.Melt <- LoR.Account %>% melt(., id.vars = c("gameName","tagLine","master"), measure.vars=c("puuid_1","puuid_2","puuid_3"),value.name=c("puuid"),variable.name="origin" )
LoR.Account.Melt$origin <- as.numeric(LoR.Account.Melt$origin)


#'**************************************************************************** *
# EUROPE ----------------------------------------------------------------
#'**************************************************************************** *

missingEU <- EULeaderBoard$players$name[EULeaderBoard$players$name %!in% masterEU$gameName]

if ( length(missingEU) > 0 ) {
  
  # Take the players from EU not yet declared master (because of accounts with same name)
  JoinEU <- left_join(HighRanked.puuid.Melt,LoR.Account.Melt, by="puuid") %>% filter( server=="europe" )
  JoinEU.master <- JoinEU %>% filter(gameName %in% missingEU) %>% distinct(gameName,tagLine,.keep_all = T) %>% filter( is.na(master) ) %>% select(gameName,tagLine,master)
  # print(JoinEU.master[,gameName ])
  JoinEU.master[,master:="master"]
  
  # Update and remove the one I'm not sure
  LoR.Account[JoinEU.master, on = c("gameName","tagLine"), names(JoinEU.master) %>% .[!. %in% c("gameName","tagLine")] := mget(paste0("i.", names(JoinEU.master) %>% .[!. %in% c("gameName","tagLine")])) ]
  
  # LoR.Account[ activeShard=="europe" & master=="master" & gameName %!in% namesList.EU,  ]
  # LoR.Account[ activeShard=="europe" & master=="master" & gameName %!in% namesList.EU, master:=NA ]
}

#'**************************************************************************** *
# AMERICAS ----------------------------------------------------------------
#'**************************************************************************** *

missingNA <- NALeaderBoard$players$name[NALeaderBoard$players$name %!in% masterNA$gameName]

if ( length(missingNA) > 0 ) {
  
  JoinNA <- left_join(HighRanked.puuid.Melt,LoR.Account.Melt, by="puuid") %>% filter( server=="americas")
  JoinNA.master <- JoinNA %>% filter(gameName %in% missingNA) %>% distinct(gameName,tagLine,.keep_all = T) %>% filter( is.na(master) ) %>% select(gameName,tagLine,master)
  # print(JoinNA.master[,gameName ])
  JoinNA.master[,master:="master"]
  
  # Update and remove the one I'm not sure
  LoR.Account[JoinNA.master, on = c("gameName","tagLine"), names(JoinNA.master) %>% .[!. %in% c("gameName","tagLine")] := mget(paste0("i.", names(JoinNA.master) %>% .[!. %in% c("gameName","tagLine")])) ]
  
  # LoR.Account[ activeShard=="americas" & master=="master" & gameName %!in% namesList.NA,  ]
  # LoR.Account[ activeShard=="americas" & master=="master" & gameName %!in% namesList.NA, master:=NA ]
  
}

#'**************************************************************************** *
# ASIA --------------------------------------------------------------------
#'**************************************************************************** *

missingASIA <- ASIALeaderBoard$players$name[ASIALeaderBoard$players$name %!in% masterASIA$gameName]

if ( length(missingASIA) > 0 ) {
  
  JoinASIA <- left_join(HighRanked.puuid.Melt,LoR.Account.Melt, by="puuid") %>% filter( server=="asia")
  JoinASIA.master <- JoinASIA %>% filter(gameName %in% missingASIA) %>% distinct(gameName,tagLine,.keep_all = T) %>% filter( is.na(master) ) %>% select(gameName,tagLine,master)
  # print(JoinASIA.master[,gameName ])
  JoinASIA.master[,master:="master"]
  
  # Update and remove the one I'm not sure
  LoR.Account[JoinASIA.master, on = c("gameName","tagLine"), names(JoinASIA.master) %>% .[!. %in% c("gameName","tagLine")] := mget(paste0("i.", names(JoinASIA.master) %>% .[!. %in% c("gameName","tagLine")])) ]
  
  # LoR.Account[ activeShard=="asia" & master=="master" & gameName %!in% namesList.ASIA,  ]
  # LoR.Account[ activeShard=="asia" & master=="master" & gameName %!in% namesList.ASIA, master:=NA ]
  
}

#'**************************************************************************** *
# UPDATE THE LADDER IN A CSV FOR EACH REGION ------------------------------
#'**************************************************************************** *

masterEU   <- LoR.Account[activeShard=="europe"   & master=="master" ]
masterNA   <- LoR.Account[activeShard=="americas" & master=="master" ]
masterASIA <- LoR.Account[activeShard=="asia"     & master=="master" ]

# LoR.Account[activeShard=="asia"     & master=="master" ] %>% View()

if ( NROW(namesList.EU)>=1 ) { 
  # fwrite(EULeaderBoard$players,  paste0("LoR_LADDER_EU.csv"));
  print(paste0("EU Master players in the ladder: "  ,NROW(namesList.EU),   " / Number of Master players I recovered from matches: ",NROW(masterEU) )) 
  print(paste0("Missing: ",NROW(namesList.EU)-NROW(masterEU) ))
  # print(vsetdiff(namesList.EU,LoR.Account[ activeShard=="europe" & master=="master",gameName ]))
}
if ( NROW(namesList.NA)>=1 ) { 
  # fwrite(NALeaderBoard$players,  paste0("LoR_LADDER_NA.csv"))
  print(paste0("NA Master players in the ladder: "  ,NROW(namesList.NA),   " / Number of Master players I recovered from matches: ",NROW(masterNA) ))
  print(paste0("Missing: ",NROW(namesList.NA)-NROW(masterNA) ))
  # print(vsetdiff(namesList.NA,LoR.Account[ activeShard=="americas" & master=="master",gameName ]))
}
if ( NROW(namesList.ASIA)>=1 ) { 
  # fwrite(ASIALeaderBoard$players,paste0("LoR_LADDER_ASIA.csv"))
  print(paste0("ASIA Master players in the ladder: ",NROW(namesList.ASIA),   " / Number of Master players I recovered from matches: ",NROW(masterASIA)  ))
  print(paste0("Missing: ",NROW(namesList.ASIA)-NROW(masterASIA) ))
  # print(vsetdiff(namesList.ASIA,LoR.Account[ activeShard=="asia" & master=="master",gameName ]))
}

#'**************************************************************************** *
# UPDATE SEASONAL ACCOUNTS ------------------------------------------------
#'**************************************************************************** *

Seasonal        <- LoR.Match.DT[ str_detect(game_mode, 'Seasonal') & str_detect(game_version, '2_10') ] %>% copy()
SeasonalPuuid   <- Seasonal %>% select(puuid_1,puuid_2) %>% unlist(.,use.names = F) %>% unique()

# LoR.Account.Melt <- LoR.Account %>%
#   mutate( RiotID = paste(gameName,tagLine) ) %>%
#   melt(., id.vars = c("RiotID","master"), measure.vars=c("puuid_1","puuid_2","puuid_3"),value.name=c("puuid"),variable.name="origin" ) %>%
#   mutate( origin = as.numeric(origin) ) %>%
#   copy() 

print(paste0("#Player / Seasonal / PreUpdate: ", LoR.Account[ seasonal=="seasonal", .N ] ))
# LoR.Account[ puuid_1 %in% SeasonalPuuid, seasonal ]
LoR.Account[ puuid_1 %in% SeasonalPuuid, seasonal:="seasonal" ]
# LoR.Account[ puuid_2 %in% SeasonalPuuid, seasonal ]
LoR.Account[ puuid_2 %in% SeasonalPuuid, seasonal:="seasonal" ]
# LoR.Account[ puuid_3 %in% SeasonalPuuid, seasonal ]
LoR.Account[ puuid_3 %in% SeasonalPuuid, seasonal:="seasonal" ]
print(paste0("#Player / Seasonal / PostUpdate: ", LoR.Account[ seasonal=="seasonal", .N ] ))

#'**************************************************************************** *
# RMV --------------------------------------------------------------------------
#'**************************************************************************** *

rm(list=c(
  ls(pattern="Join"),
  ls(pattern="HighRanked"),
  ls(pattern="Melt"),
  ls(pattern="LeaderBoard")
) %>% unique() )
