---
title: "MATCH UP TABLE - PATCH 2.12/2.13"
description: |
base_url: https://llorr-stats.netlify.app
# preview: "https://static.wikia.nocookie.net/leagueoflegends/images/d/df/03NX007T1_Sentinel-full.png"
# date: 07-21-2021
output: distill::distill_article
    # toc: true
    # toc_float: true
    # toc_depth: 3
    # self_contained: false
draft: false
twitter:
  site: "@Maou_Legna"
  creator: "@Maou_Legna"
params:
  # prev:  "2021-07-07 21:00:00" #UTC tz / 'previous' week start
  start: "2021-07-14 21:00:00" #UTC tz / 'current' week start
  # end:   "2021-07-21 21:00:00" #UTC tz / 'current' week end
  skip:  1888233  # Patch 2.11 - after removing a few games
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  warning = FALSE,
  error = FALSE,
  message = FALSE,
  dev.args = list(bg = 'transparent'),
  # dev='svglite',
  fig.align='center',
  #out.width='75%', fig.asp=.75,
  cache.rebuild = F,
  cache = F
)

# source(file.path("C:","LlorR","scripts","lor_main.R" ))
options(digits.secs = 6)
options(scipen=999)

#' R Option
xaringanExtra::use_panelset()

pacman::p_load(tidyverse,data.table,DT,reactable,crosstalk)
```

```{r panelset-style}
xaringanExtra::style_panelset_tabs(font_family = "Roboto",
                                   active_foreground = "white",
                                   hover_foreground = "black",
                                   hover_border_color = "black",
                                   active_background = "#007fff"
                                   )
```

```{r load-data}
#' load DeckDT
#'############
LoR.Deck        <- fread(file.path("C:","LlorR","data","raw","LoR_DECK.csv"),na.strings = c("",NA))

file.DT <- file.path("C:","LlorR","data","raw","LoR_MatchDT.csv")
header        <- fread(file.DT, header = FALSE, na.strings = c("",NA), nrows = 1, stringsAsFactors = FALSE)
LoR.Match.RMD <- fread(file.DT, header = FALSE, na.strings = c("",NA), skip = 1850000 )
colnames(LoR.Match.RMD) <- unlist(header,use.names = F)

#' Metl tbl
#'#########
LoR.Melt.Matches.RMD <- LoR.Match.RMD %>%
  #' Base filters
  filter( game_type=="Ranked" ) %>%
  filter( game_start_time_utc >= as.POSIXct(params$start, tz = "UTC") ) %>%
  #' 'process' data
  left_join(.,LoR.Deck[,.(deck_code,archetype)] %>% setnames(old = "archetype", new = "player_1")   ,by=c("deck_code_1"="deck_code")) %>%
  left_join(.,LoR.Deck[,.(deck_code,archetype)] %>% setnames(old = "archetype", new = "opponent_1") ,by=c("deck_code_2"="deck_code")) %>%
  mutate( player_2 = opponent_1, opponent_2 = player_1, oppoppuid_1 = puuid_2, oppoppuid_2 = puuid_1 ) %>%
  select( match_key,server,game_start_time_utc,game_version,total_turn_count,
          ends_with("_1"),ends_with("_2"),-ends_with("_3"),-ends_with("_4"),-contains("deck_id"),-contains("participants") ) %>%
  #' melt data
  melt(id.vars=c("match_key","server","game_start_time_utc","game_version","total_turn_count"), measure.vars=patterns(
    str_sub(
      names(select(.,ends_with("_1")))
      ,end = -3)
  ),
  value.name = str_sub(
    names(select(.,ends_with("_1")))
    ,end = -3)
  ) 
# %>%
#   #' finish 'process' data
#   left_join(. , LoR.Account.RMD[,c("puuid","RiotID","refID")] %>% setnames(old = "RiotID", new = "userID")     ,by=c("puuid"="puuid")) %>%
#   left_join(. , LoR.Account.RMD[,c("puuid","RiotID")] %>% setnames(old = "RiotID", new = "opponentID") ,by=c("oppoppuid"="puuid")) %>%
#   left_join(.,LoR.Deck %>% select(!archetype),by=c("deck_code","factions")) %>%
#   select(-ends_with("puuid"),-refID,-contains("puuid"))

#' WR tbl
#'#######
WR.DT <- LoR.Melt.Matches.RMD %>%
  filter(game_outcome!="tie") %>%
  select( player,opponent,game_outcome ) %>%
  group_by(player) %>%
  summarise( nWin   = sum(game_outcome=="win"),
             nGames = n(),
             WR=mean(game_outcome=="win")
  ) %>%
  ungroup() %>%
  mutate( playrate = nGames/sum(nGames) )

#' MU tbl the date is already filtered
#'####################################
MUtbl <- LoR.Melt.Matches.RMD %>%
  # filter(game_version>"live_2_9" ) %>%
  filter( game_outcome != "tie" ) %>%
  select( player,opponent,game_outcome,server,game_version,factions ) %>%
  # mutate( factions = str_replace_all(factions, pattern="faction_",replacement = "") %>% str_replace_all(.,pattern="_Name",replacement = "") %>% factor() ) %>%
  group_by(player,opponent) %>%
  summarise( muWin   = sum(game_outcome=="win"),
             muGames = n(),
             muWR=mean(game_outcome=="win"),
             factions = unique(str_replace_all(factions, pattern="faction_",replacement = "") %>% str_replace_all(.,pattern="_Name",replacement = "") ) ) %>%
  ungroup() %>%
  mutate( CI   = map2_df(.x=muWin,.y = muGames, .f = ~binom::binom.confint(.x,.y,0.95,methods="exact")[,c("lower","upper")] ) ) %>%
  chop(CI) %>%
  unnest(CI) %>%
  mutate( okCI = map2_lgl(.x = lower,.y = upper, ~ !between(0.50,.x,.y) ) ) %>%
  mutate( direction = ifelse(muWR>0.50,"POS","NEG") ) %>%
  mutate( CI := glue::glue("({scales::percent(lower,accuracy = 0.1)}-{scales::percent(upper,accuracy = 0.1)})" ) )

MUtbl <- left_join(MUtbl,WR.DT[,c("player","playrate")],by="player")
```

```{r load-MU}
# file.MU.DT   <- list.files(path = file.path("C:","LlorR","data","clean" ), pattern = "MUtbl_", full.names = T) %>% max()
# MUtbl <- fread(file.MU.DT, header = T, na.strings = c("", NA))
```

```{r get-WR-Top10}
mu <- 20

Top10CC <- MUtbl %>%
  group_by(player) %>%
  summarise(nGames = sum(muGames)) %>% 
  arrange(desc(nGames)) %>% 
  slice_head(.,n = mu) %>% 
  select(player) %>% 
  pull() %>% 
  sort()

WRTop10 <- MUtbl %>%
  filter(player %in% Top10CC & opponent %in% Top10CC) %>%
  arrange(player,opponent)
```

```{r top30}
m = 30
fct_values <- LoR.Melt.Matches.RMD %>%
  mutate( top5 = fct_lump_n(player,n = m) %>% fct_infreq() ) %>%
  pull(top5) %>% levels()

if ( any(fct_values=="Soraka / Tahm Kench") ) {
  fct_values <- fct_values[-1]
} else {
  fct_values <- c(fct_values[c(-1,-30)],"Soraka / Tahm Kench")
}

MU30tbl <- tibble(player   = rep(fct_values,each = 30),
                  opponent = rep(fct_values,30)
) %>%
  left_join(.,MUtbl,by = c("player","opponent"))

# MU30tbl %>%
#   distinct(opponent) %>%
#   pull(opponent) %>%
#   sort()

fwrite(MU30tbl, file.path("C:","LlorR","scripts","shiny","Bo3-helper","MU30tbl.csv"))
```


# Match Up Table

Number of **matches**: `r sum(MUtbl$muGames)/2` / **games** : `r sum(MUtbl$muGames)`

Last Update: `r Sys.time()`

`r kableExtra::text_spec("UPDATE 1:", color = "red")` added an "alternative" version to the same MU table. Should result a bit cleaner. Potentially I may turn it into the standard version once I know how to improve a few things like the slider-input bur for now I leave both options. Also the removed cases with less than 10 games (that alone is enough to reduce to 1/10th of the original rows). The "standard" one is still with everything.

`r kableExtra::text_spec("UPDATE 2:", color = "red")` while I may find the MU table vastly more useful I always forget about the "common user" who may find the grid easier. While I actually like the grid, a reason why I don't often try to improve it or make it more visible is that I force too much by myself the concept of avoiding forcing the meta and by showing only top played deck I feared this. But, I must admit this is being overcareful and ignoring the help I can provide. So I added the grid here too, expanded to 20 decks as I have the space.

`r kableExtra::text_spec("UPDATE 3:", color = "red")` while I thought leaving all data would give more freedom to the user, again it's not really helpful if I force to filter all the dirt to almost all people just to let very few fully explore the data. Both tables are again filtered at 100 min games and so making each row at least worth considering. `r kableExtra::text_spec("I also just changed the priority of the table format to display", color = "red")` it seems that indeed the new one if easier to use and better to the eyes, again I left the older one available `r kableExtra::text_spec("just click on the second tab", color = "red")`


::: l-page
::::: {.panelset}

::: {.panel}
## Match-up Table {.panel-name}

```{r reactable-tbl}
require(reactable)
require(htmltools)
require(crosstalk)

#'Quick link for a MUtbl for testing
#'##################################
# file.MU.DT   <- list.files(path = file.path("C:","LlorR","data","clean" ), pattern = "MUtbl_", full.names = T) %>% max()
# MUtbl <- fread(file.MU.DT, header = T, na.strings = c("", NA))

# The fs object will inject css into your page.
# if (requireNamespace("crosstalk", quietly = TRUE)) {
data <- crosstalk::SharedData$new(MUtbl %>%
                       filter(muGames>=100) %>%
                       select(-lower,-upper,-okCI))

bscols(
  widths = c(2, 10),
  list(
    crosstalk::filter_select("player", "Player", data, ~player),
    crosstalk::filter_select("opponent", "Opponent", data, ~opponent),
    crosstalk::filter_slider("muWin",   "#Win", data, ~muWin, width = "100%",step = 50,min = 0),
    crosstalk::filter_slider("muGames", "#Games", data, ~muGames, width = "100%",step = 100,min = 0),
    crosstalk::filter_slider("muWR", "WinRate", data, ~muWR, width = "100%",step=0.01,min = 0,max = 1),
    crosstalk::filter_slider("playrate", "PlayRate", data, ~playrate, width = "100%",step=0.01,min = 0,max = round(max(MUtbl$playrate),4) ), 
    crosstalk::filter_select("direction", "MU-Direction", data, ~direction)
    # crosstalk::filter_select("okCI", "Result-Test", data, ~okCI)
  ),
  reactable(data,
            bordered = TRUE,
            highlight = TRUE,
            striped = TRUE,
            searchable = TRUE,
            compact = TRUE, # compact the table
            fullWidth = FALSE, # don't fill the page
            defaultPageSize = 20,
            # filterable = TRUE,
             defaultColDef = colDef(
              style = list(fontFamily = "Roboto", fontSize = "11px"),
              align = "center",
              # minWidth = 120,
              headerStyle = list(background = "steelblue",color="white", fontSize = "14px")
            ),
            columns = list(
              player   = colDef(name = "Player",minWidth = 120, style = list(fontSize = "11px", fontWeight = 600, color="black") ),
              opponent = colDef(name = "Opponent"  ,minWidth = 120, style = list(fontSize = "11px", fontWeight = 600, color="black")),
              muWin    = colDef(name = "#Win", style = list( fontSize = "15px") ),
              muGames  = colDef(name = "#Games", style = list( fontSize = "15px")),
              muWR     = colDef(name = "WinRate",format = colFormat(percent = TRUE,digits = 1), style = list( fontSize = "15px") ),
              CI       = colDef(name = "CI",minWidth = 120, style = list(fontSize = "13px")),
              playrate = colDef(name = "PlayRate",format = colFormat(percent = TRUE,digits = 1), style = list( fontSize = "15px") ),
              factions = colDef(name = "Regions", style = list(fontSize = "11px", fontWeight = 600, color="black")),
              direction = colDef(name = "MU-Direction")
              # okCI     = colDef(name = "Result-Test")
              ),
            theme = reactableTheme(
                borderColor = "#dfe2e5",
                stripedColor = "#f6f8fa",
                highlightColor = "#f0f5f9",
                cellPadding = "8px 12px",
                style = list(fontFamily = "-apple-system, BlinkMacSystemFont, Segoe UI, Helvetica, Arial, sans-serif"),
                searchInputStyle = list(width = "100%"))
    )
  )
```
:::

::: {.panel}
## Match-up Table (old format) {.panel-name}

```{r}
MUtbl %>%
  filter(muGames>100) %>%
  mutate( player = factor(player) ) %>%
  mutate( opponent = factor(opponent) ) %>%
  # arrange(desc(games)) %>%
  select(player,opponent,muWR,muWin,muGames,CI) %>%
  datatable(., rownames = FALSE, colnames = c('Player'='player','Opponent'='opponent','Win Rate'='muWR','#Wins'='muWin','#Games'='muGames'),
            options = list(search = list(regex = TRUE, caseInsensitive = FALSE)),
            filter = list(position = 'top', clear = FALSE)
  ) %>%
  formatPercentage('Win Rate', 1)
```
:::


::: {.panel}

## Match-up Grid {.panel-name}

The win rates on the grid are among the `r mu` most played champion combination.

```{r prepare-flex}
require(flextable)
require(officer)
require(scales)

big_border   = fp_border(color="darkgray", width = 2)
small_border = fp_border(color="gray", width = 1)

dummy_fun <- function(x){
  ifelse( !is.na(x),sprintf( "%.0f%%", x*100 ),NA )
}
```

```{r prepare-flex-grid}
grid <- matrix(WRTop10$muWR, nrow = mu, ncol = mu, byrow = T)
diag(grid) <- NA

colnames(grid) <- Top10CC
colourer <- col_numeric(
  palette = c("#D73027", # red
          # "#f9ccac", # red/orange
          "white",
          # "#e3eaa7", # green
          "#1A9850" # darker green
          ),
  domain = c(0, 1))

funs <- setNames(rep(list(dummy_fun), mu), Top10CC)
```

```{r print-flex}
ft <- grid %>% 
  as_tibble() %>%
  # mutate(across(everything(),~scales::percent(.x, accuracy = 0.1 ))) %>%
  add_column(.,Top10CC,.before = Top10CC[1]) %>%
  rename("MatchUps"="Top10CC") %>%
  flextable::flextable(.) %>% 
  theme_vanilla( ) %>%
  # theme_booktabs(bold_header = TRUE) %>% 
  flextable::align(.,align = "center", part = "all") %>%
  flextable::bg(.,
    bg = colourer,
    j = ~ . -MatchUps,
    part = "body") %>% 
  border_remove(x = .) %>%
  border_outer(., part="all", border = big_border ) %>%
  border_inner_h(., part="all", border = small_border ) %>%
  border_inner_v(., part="all", border = small_border ) %>%
  set_formatter(values = funs) %>%
  fontsize(., size = 8, part = "header") %>%
  fontsize(., j=1, size = 8) %>%
  bg(., part = "header", bg = "white"  ) %>%
  bg(., j = 1, bg = "white"  ) %>%
  autofit() 

ft
```
:::


:::::
<!-- Close MU panelset -->
:::

The format of the table is the usual way I display the match-ups data but I also displayed additional variables that I normally remove in the report:

* **Regions** - regions of the 'Player' deck. In case I may add an 'Oppo-Region' additional column.

* **MU Direction** - simply if the MU is positive or negative for the 'Player' (or tie in case the win rate is exactly 0.5)

I'm planning to improve and expand the options once I decide how to implement the ideas I have.