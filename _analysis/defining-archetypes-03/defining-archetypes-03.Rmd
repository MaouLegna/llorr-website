---
params:
  ind: "03"
  title: "Defining Archetypes #3: "
  description: ""
title: | 
  `r params$title`
description: |
  `r params$description`
# preview: 
base_url: https://www.llorr-stats.com
author:
  - name: Valentino (Legna) Vazzoler
date: 11-11-2021
output:
 distill::distill_article:
    toc: true
    toc_float: true
    toc_depth: 3
    self_contained: false
citation: false
bibliography: references.bib
draft: FALSE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  eval = TRUE,
  warning = FALSE,
  error = FALSE,
  message = FALSE,
  comment = NA,
  R.options = list(width = 140,
                   digits.secs=6),
  dev.args = list(bg = 'transparent'), # make graphics with transparent background
  fig.align = 'center',
  fig.width=6,
  fig.height=4,
  engine.path = list(
    python = 'C:/anaconda/'   # -> use_python("C:/anaconda/")
  ),
  #'distill options
  layout="l-body-outset",
  preview=FALSE
)

#' R Option
options(scipen = 999)
source(file.path("C:","LlorR","scripts","lor_main.R" ))
xaringanExtra::use_panelset()

pacman::p_load(apcluster,dbscan,fpc,factoextra)
```

```{r panelset-style}
xaringanExtra::style_panelset_tabs(
  font_family = "Helvetica",
  active_foreground = "white",
  hover_foreground = "black",
  hover_border_color = "black",
  active_background = "#007fff"
  )
```

```{r raw-data}
#' load DeckDT
#'############
LoR.Deck.RMD        <- fread(file.path("C:","LlorR","data","raw","LoR_DECK.csv"),na.strings = c("",NA))

set.seed(123)
Archetype3 <- LoR.Deck.RMD |>
  group_by(factions) |>
  slice_sample( n = 300 )
# Archetype3 |> tabyl(archetype)

# fwrite(Archetype3,"./data/example_archetye_03.csv")
# fread("./data/example_archetye_03.csv")

Archetype3.mini <- LoR.Deck.RMD |>
  group_by(factions) |>
  slice_sample( n = 20 )

cos.dsim.arch3 <- cos.dsimMatrix(Archetype3.mini$deck_code)
# object.size(cos.dsim.arch3)

library("factoextra")
MDist <- fviz_dist(cos.dsim.arch3,show_labels = F) +
  theme(legend.position = "none")

# factions <- LoR.Deck.RMD |>
#   distinct(factions) |>
#   arrange(factions) |>
#   pull(factions) 
# 
# prova <- tibble(
#   f1 = rep(factions, each = length(factions)),
#   f2 = rep(factions, times = length(factions)),
#   f3 = map2(.x=f1,.y=f2,~c(.x,.y)),
#   # f3 = glue("{f1},{f2}")
# )
# 
# prova$f3 <- lapply(prova$f3, function(x) sort(x) )
# 
# prova |>
#   distinct(f3,.keep_all = T) |>
#   mutate(
#     f1 = map_chr(.x = f1, ~str_remove_all(.x, paste(c("_Name","faction_", ""), collapse = "|") ) ),
#     f2 = map_chr(.x = f2, ~str_remove_all(.x, paste(c("_Name","faction_", ""), collapse = "|") ) )
#   ) |>
#   separate(f1,sep = ",",into = c("f11","f12"))



```

# Introduction



## The Shuriman Desert is Sparse

The first thing to do in any cluster analysis that we actually forgot to even do the most basic step and it is to display the distance matrix

## Sparse Regions

```{r}
#' region to find the percentage all cases of "interceptions" between elements like factions. For example BC/NX does correlate with all BC and all NX cases
regionComboInterception <- function(n) {
  # n = 10
  dim <- n*(n+1)/2
  total = 0
  for ( i in 1:n ) {
    p1 <- i*(i+1)/2
    p2 <- (i-1)^2
    total <- total + p1 + p2
  }
  total/(dim*(dim+1)/2)
}
  
# map_dbl(1:10, ~regionComboInterception(.x))



  
```

