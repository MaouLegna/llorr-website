---
params:
  ind: "02"
  patch: "Patch 2.17 - Week 1"
  title: "Defining Archetypes #2: xxx xxx xxx"
  description: "xxx xxx xxx xxx"
  cardlurl: "https://dd.b.pvp.net/latest/set5/en_us/img/cards/05BC116.png"
  # prev:  "2021-09-29 21:00:00" #UTC tz / 'current' previous week start
  start: "2021-09-01 21:00:00" #UTC tz / 'current' week start
  end:   "2021-09-15 21:00:00" #UTC tz / 'current' week end
  skip:  2800000  # ~ Patch 2.16

title: | 
  `r params$title`
description: |
  `r params$patch` - `r params$description`
base_url: https://www.llorr-stats.com
preview: |
  `r params$cardlurl`
author:
  - name: Valentino (Legna) Vazzoler
date: 10-06-2021
output:
 distill::distill_article:
    toc: true
    toc_float: true
    toc_depth: 3
    self_contained: false
citation: false
draft: TRUE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  eval = TRUE,
  warning = FALSE,
  error = FALSE,
  message = FALSE,
  comment = NA,
  R.options = list(width = 140,
                   digits.secs=6),
  dev.args = list(bg = 'transparent'), # make graphics with transparent background
  fig.align = 'center',
  fig.width=12,
  fig.height=8,
  engine.path = list(
    python = 'C:/anaconda/'   # -> use_python("C:/anaconda/")
  ),
  #'distill options
  layout="l-body-outset",
  preview=FALSE
)

#' R Option
options(scipen = 999)
source(file.path("C:","LlorR","scripts","lor_main.R" ))
xaringanExtra::use_panelset()
```

```{r panelset-style}
xaringanExtra::style_panelset_tabs(
  font_family = "Helvetica",
  active_foreground = "white",
  hover_foreground = "black",
  hover_border_color = "black",
  active_background = "#007fff"
  )
```

```{r functions}
#' extract the top n most played list for 'archetypes provided'
top_n_codes <- \(DT = LoR.Melt.Matches.RMD,archetypes,n,dopull=T) DT |>
  dplyr::filter(archetype%in%{{archetypes}}) |>
  dplyr::group_by(archetype) |>
  dplyr::count(deck_code) |>
  dplyr::slice_max(deck_code,n=n,with_ties=F) |>
  ungroup()|>{\(x) if( dopull==T ) dplyr::pull(x,deck_code) else x}()


#' distance Matrix given deck_codes
dsimMatrix <- function( codes ) {
  deck.matrix <- LoR.Card$cardCode |> purrr::map_dfc(setNames, object = list(numeric()))
  for (i in 1:length(codes)) {
    if (i%%100==0) glue::glue("Fill parse matrix #{i} - {Sys.time()}") |> message()
    decklist <- codes[i] |> lordecks::get_decklist_from_code()
    deck.matrix[NROW(deck.matrix)+1, decklist$cardcode] <- as.list(decklist$count)
  }
  deck.matrix |> mutate( across(everything(), ~replace_na(.x, 0)) ) 
}

#' distance Matrix given deck_codes
cos.dsimMatrix <- function( codes ) {
  deck.matrix <- LoR.Card$cardCode |> purrr::map_dfc(setNames, object = list(numeric()))
  for (i in 1:length(codes)) {
    if (i%%500==0) glue::glue("Fill parse matrix #{i} - {Sys.time()}") |> message()
    decklist <- codes[i] |> lordecks::get_decklist_from_code()
    deck.matrix[NROW(deck.matrix)+1, decklist$cardcode] <- as.list(decklist$count)
  }
  deck.matrix <- deck.matrix |> mutate( across(everything(), ~replace_na(.x, 0)) ) 
  eisen_cos.sim(deck.matrix)
}
```


```{r raw-data-all}
# skip.dt <-fread(file.path("C:","LlorR","data","raw","skip_row.csv")  )
# skip.dt

#' load gameDT
#'############
file.DT <- file.path("C:","LlorR","data","raw","LoR_MatchDT.csv")
header        <- fread(file.DT, header = FALSE, na.strings = c("",NA), nrows = 1, stringsAsFactors = FALSE)
LoR.Match.RMD <- fread(file.DT, header = FALSE, na.strings = c("",NA), skip = params$skip )
colnames(LoR.Match.RMD) <- unlist(header,use.names = F)

#' load Account
#'#############
LoR.Account.RMD <- fread(file.path("C:","LlorR","data","raw","LoR_ACCOUNT.csv"),
                         header=T, na.strings = c("",NA), encoding = 'UTF-8') |>
  mutate( RiotID = sprintf("%s#%s",gameName,tagLine) )

#' load DeckDT
#'############
LoR.Deck.RMD        <- fread(file.path("C:","LlorR","data","raw","LoR_DECK.csv"),na.strings = c("",NA))[ !is.na(archetype_pretty), archetype:=archetype_pretty ]

#' patch 2.14 to 2.15
#'###################
patch214215code <- LoR.Match.RMD |>
  filter( game_type=="Ranked" ) |>
  filter( game_start_time_utc >= as.POSIXct(params$start, tz = "UTC") & game_start_time_utc < as.POSIXct(params$end, tz = "UTC") ) |>
  select( -ends_with("_3"),-ends_with("_4")  ) |>
  select( starts_with("deck_code") ) |>
  pivot_longer(cols = c(ends_with("_1"),ends_with("_2")),
               names_to = c(".value"),
               names_pattern = "(.*)_[0-9]"
               ) |>
  left_join(LoR.Deck.RMD[,.(deck_code,archetype)],  by=c("deck_code") )

# NROW(patch214215code) # 155214
# patch214215code |> fwrite(file.path("C:","LlorR","data","clean","deckcode_patch214215.csv")  )

# length(unique(patch214215code$deck_code)) # 17772
# NROW(DSim_patch214215) # 17772

#' load parse Matrix
#'##################
DSim_patch214215 <- fread(file.path("C:","LlorR","data","clean","DSimMatrix_0214to0215.csv"))
cos.DSim_patch214215 <- fread(file.path("C:","LlorR","data","clean","cos.DSimMatrix_0215to0216.csv"), header=T) |> as.matrix()
# fwrite(DSim_patch215216,file.path("C:","LlorR","data","clean","DSimMatrix_0215to0216.csv"))

# cos.DSim_patch214215[1:10,1:10]
# DSim_patch214215[1:10] |> eisen_cos.sim()
```
```{r}
# how I selecter the decks, it is reproducible as more decks will be inserted in the DB

# set.seed(123)
# Mist1 <- LoR.Deck.RMD |>
#   filter( archetype_pretty == "Mistwraith Allegiance" & str_detect(factions,"Targon") ) |>
#   slice_sample(n = 50) |>
#   pull(deck_code)
# 
# set.seed(123)
# Mist2 <- LoR.Deck.RMD |>
#   filter( archetype_pretty == "Mistwraith Allegiance" & str_detect(factions,"Piltover") ) |>
#   slice_sample(n = 50) |>
#   pull(deck_code)
# 
# set.seed(123)
# Dragon1 <- LoR.Deck.RMD |>
#   filter( archetype == "Aurelion Sol/Jarvan IV/Shyvana" ) |>
#   slice_sample(n = 30) |>
#   pull(deck_code)
# 
# set.seed(123)
# Dragon2 <- LoR.Deck.RMD |>
#   filter( archetype == "Aurelion Sol/Shyvana" ) |>
#   slice_sample(n = 70) |>
#   pull(deck_code)
# 
# set.seed(123)
# Sion1 <- LoR.Deck.RMD |>
#   filter( archetype == "Draven/Sion (NX/PZ)" & is.na(archetype_pretty) ) |>
#   slice_sample(n = 80) |>
#   pull(deck_code)
# 
# set.seed(123)
# Sion2 <- LoR.Deck.RMD |>
#   filter( archetype_pretty == "RubinBait - Draven/Sion", ) |>
#   slice_sample(n = 20) |>
#   pull(deck_code)
# 
# set.seed(123)
# AI <- LoR.Deck.RMD |>
#   filter( archetype == "Azir/Irelia", ) |>
#   slice_sample(n = 100) |>
#   pull(deck_code)
# 
# set.seed(123)
# Rep1 <- LoR.Deck.RMD |>
#   filter( archetype == "Ashe/LeBlanc" & is.na(archetype_pretty) ) |>
#   slice_sample(n = 75) |>
#   pull(deck_code)
# 
# set.seed(123)
# Rep2 <- LoR.Deck.RMD |>
#   filter( archetype_pretty == "Marauder" ) |>
#   slice_sample(n = 25) |>
#   pull(deck_code)
```

```{r prepare-examples}
#' archetypes names
archetypes <- c( 
  "Ashe/LeBlanc",           # 75/25 noMarauder/Marauder
  "Azir/Irelia",            # 100
  "Dragons (DE/MT)",        # 30/70 J4/PureDrake "Aurelion Sol/Jarvan IV/Shyvana",  "Aurelion Sol/Shyvana",
  "Draven/Sion (NX/PZ)",    # 80/20 DravenSion/RubinBait
  "Mistwraith Allegiance"   # 50/50 Targon/Piltover
)

LoR.Archetype.Exe[ !is.na(archetype_pretty), archetype:=archetype_pretty ]
LoR.Archetype.Exe[ archetype == "RubinBait - Draven/Sion" , archetype:="Draven/Sion (NX/PZ)" ]
LoR.Archetype.Exe[ archetype == "Marauder" , archetype:="Ashe/LeBlanc" ]

mini.ex <- c(Rep1[1:7],Rep2[1:3],AI[1:10],Dragon1[1:3],Dragon2[1:7],Sion1[1:8],Sion2[1:2],Mist1[1:5],Mist2[1:5])

LoR.Archetype.Mini <- LoR.Archetype.Exe |>
  filter(deck_code %in% mini.ex )

# LoR.Archetype.Exe |>
#   filter(deck_code %in% mini.ex ) |>
#   fwrite("example_archetye_mini.csv")
# 
# LoR.Archetype.Exe |>
#   fwrite("example_archetye.csv")

# #' distance matrix
DSim_ex   <- cos.dsimMatrix(LoR.Archetype.Exe$deck_code)
DSim_mini <- cos.dsimMatrix(codes =  LoR.Archetype.Mini$deck_code )
```

```{r}
# DSim_patch215216 <- unique(patch215216code$deck_code) |> dsimMatrix()
# fwrite(DSim_patch215216,file.path("C:","LlorR","data","clean","DSimMatrix_0215to0216.csv"))

# DSim <- DSim_patch215216 |> eisen_cos.sim()

# fwrite(as.matrix(DSim),file.path("C:","LlorR","data","clean","cos.DSimMatrix_0215to0216.csv"))
```

# Introduction

Defining archetypes on Legends of Runeterra is both a complex and simple problem. It's simple if we consider that it's possible to define decks by the combination of champions and regions of choice but it's also complex by the fact that such definition is quite limited.

On our [previous article/analysis](https://llorr-stats.netlify.app/analysis/defining-archetypes-01/) we gave a possible method about how to compare archetypes and see if they can be considered from a shared common archetype or not. The proposed method makes use of inferential statistical analysis to reach a conclusion and so giving the results a certain robustness (not in the statistical meaning) with precise decision parameters. Sadly, it's also a methodology that's more fitting a posterior analysis, when hypothetical archetypes are already defined, a tool more fitted to refine the results.

A more fitting methodology to find archetype is a form of exploratory data analysis (EDA) known as *Clustering Analysis* (CA). Its aim is to find subgroups (or clusters) in our data without relying on a *response variable* which is fitting to our problem.

As it's not possible check out the quality of the results of a CA there is no clear pathway to solve a problem and it's no stretch to say a CA is more akin to a form of art than a strict inferential analysis.
This also means that finding the the "correct" way to use a CA to define archetypes (which was supposed to be the aim of this article) is not really perfectly possible. Surely some choices are better than others but there is no perfect answer and to be fair, this was making us, was making me, procrastinating the writing of this article.


# Data

The sample is reduced to `r NROW(LoR.Melt.Matches.RMD)` games

## Examples

* Five archetypes with Different regions & different play style
  1. Azir/Irelia
  2. Ashe/LeBlanc
  3. Dragons (DE/MT)
  4. Draven/Sion (NX/PZ)
  5. Mistwraith Alligiance
  
* xxx Decks played from xxx to xxx

# Methods

## Aggregating Data - Clustering

### Hierarchical Clustering

It is good to find small subgroups




```{r Example1}
ex.hc.complete <- hclust(DSim_mini, method = "complete")
set.seed(123)
ex.hc.complete.n <- hclust(DSim_mini, method = "complete", members = sample(1:5000,NROW(DSim_mini) ))

ex.hc.single   <- hclust(DSim_mini, method = "single")

ex.hc.average  <- hclust(DSim_mini, method = "average")
set.seed(123)
ex.hc.average.n  <- hclust(DSim_mini, method = "average", members = sample(1:5000,NROW(DSim_mini)))

ex.hc.centroid <- hclust(DSim_mini, method = "centroid")
set.seed(123)
ex.hc.centroid.n <- hclust(DSim_mini, method = "centroid", members = sample(1:5000,NROW(DSim_mini)))

ex.hc.complete$labels <- LoR.Archetype.Mini$archetype
fviz_dend(ex.hc.complete, cex = 0.5 ) +
fviz_dend(ex.hc.complete.n, cex = 0.5 )

fviz_dend(ex.hc.average, cex = 0.5 ) +
fviz_dend(ex.hc.average.n, cex = 0.5 )

fviz_dend(ex.hc.centroid, cex = 0.5 ) +
fviz_dend(ex.hc.centroid.n, cex = 0.5 )
```

```{r Example3}
ex3.hc.complete   <- hclust(DSim_ex3, method = "complete")
set.seed(123)
ex3.hc.complete.n <- hclust(DSim_ex3, method = "complete", members = sample(1:5000,40))

ex3.hc.single     <- hclust(DSim_ex3, method = "single")

ex3.hc.average    <- hclust(DSim_ex3, method = "average")
set.seed(123)
ex3.hc.average.n  <- hclust(DSim_ex3, method = "average", members = sample(1:5000,40))

ex3.hc.centroid   <- hclust(DSim_ex3, method = "centroid")
set.seed(123)
ex3.hc.centroid.n <- hclust(DSim_ex3, method = "centroid", members = sample(1:5000,40))

abb.archetypes3 <- c(
  "OG Sion",
  "Bait1",
  "Bait2",
  "Bait3"
)

ex3.hc.complete$labels <- rep(abb.archetypes3,each=10)
ex3.hc.complete.n$labels <- rep(abb.archetypes3,each=10)
ex3.hc.average$labels <- rep(abb.archetypes3,each=10)
ex3.hc.average.n$labels <- rep(abb.archetypes3,each=10)

fviz_dend(ex3.hc.complete, cex = 0.5 ) +
fviz_dend(ex3.hc.complete.n, cex = 0.5 )

fviz_dend(ex3.hc.average, cex = 0.5 ) +
fviz_dend(ex3.hc.average.n, cex = 0.5 )

fviz_dend(ex3.hc.centroid, cex = 0.5 ) +
fviz_dend(ex3.hc.centroid.n, cex = 0.5 )
```


```{r Example1}
# label_cols =  rep(1:5,each=5)

# plot(hc.complete)

fviz_dist(DSim_ex,
          gradient = list(low = "#00AFBB", mid = "white", high = "#FC4E07")) +
  labs(title = "Distance Matrix")


# Gap statistic plot
fviz_gap_stat(res.km$gap_stat)
# Optimal number of clusters using gap statistics
res.km$nbclust

# Silhouette plot
fviz_silhouette(res.km)

# Print result
res.km

# Enhanced hierarchical clustering
res.hc <- eclust(df, "hclust") # compute hclust
fviz_dend(res.hc, rect = TRUE) # dendrogam


fviz_dend(hc, cex = 0.5)



       
```



```{r}
# Cut the tree
fviz_dend(res.hc, cex = 0.5, k = 4, color_labels_by_k = TRUE)


# Don't color labels, add rectangles
fviz_dend(res.hc, cex = 0.5, k = 4,
 color_labels_by_k = FALSE, rect = TRUE)

# Change the color of tree using black color for all groups
# Change rectangle border colors
fviz_dend(res.hc, rect = TRUE, k_colors ="black",
rect_border = 2:5, rect_lty = 1)
```


```{r fig.width=12, fig.height=8 }
ex1DT <- top_n_codes(archetypes = archetypes1,n = 10,dopull = F) |>
  mutate( origin = as.numeric(as.factor(player)) )

hc.complete <- hclust(DSim_ex, method = "average")
# plot(hc.complete)

fviz_dist(DSim_ex,
          gradient = list(low = "#00AFBB", mid = "white", high = "#FC4E07")
          ) +
  labs(title = "Distance Matrix")
  
# Customized color for groups
fviz_dend(res.hc, k = 4,
 k_colors = c("#1B9E77", "#D95F02", "#7570B3", "#E7298A"))

# Color labels using k-means clusters
km.clust <- kmeans(df, 4)$cluster
fviz_dend(res.hc, k = 4,
 k_colors = c("blue", "green3", "red", "black"),
 label_cols =  km.clust[res.hc$order], cex = 0.6)


ExampleDT1 |>
  distinct(player,.keep_all = T) >
  select(player,origin)
plot(hc.complete, labels = ExampleDT1$player)

library("factoextra")


# ggplot(DSim_ex)+
#       geom_tile()
# 
# # Compute cophentic distance
# res.coph <- cophenetic(hc.complete)
# # Correlation between cophenetic distance and the original distance
# cor(DSim_ex, res.coph)

data(USArrests)
df <- scale(USArrests)
# Hierarchical clustering
res.hc <- hclust(dist(df))
# Default plot
fviz_dend(res.hc)


archetypes1.pretty <- c("Draven/Sion","StarFish","Darkness","Ping City","Poppy/Ziggs")
ex.hc.complete$labels <- rep(archetypes1.pretty,each=10)
ex.hc.single$labels <- rep(archetypes1.pretty,each=10)

fviz_dend(ex.hc.complete, cex = 0.5,
          label_cols = rep(1:5,each=10) ) + 
  labs(title = "Complete") +
  
fviz_dend(ex.hc.single, cex = 0.5,
        label_cols = rep(1:5,each=10) ) + 
  labs(title = "Single") +
  
fviz_dend(ex.hc.average, cex = 0.5,
        label_cols = rep(1:5,each=10) ) + 
  labs(title = "Average") +
  
fviz_dend(ex.hc.centroid, cex = 0.5,
        label_cols = rep(1:5,each=10) ) + 
  labs(title = "Centroid")  
  


iris0 <- iris %>%  
  group_by(Species) %>%  
  nest() %>%  
  mutate(
    gg1 = purrr::map(data, ~ ggplot(., aes(Sepal.Length, Sepal.Width)) + geom_point()),
    gg2 = purrr::map(data, ~ ggplot(., aes(Sepal.Length, Petal.Width)) + geom_point()),
    gg3 = purrr::map(data, ~ ggplot(., aes(Sepal.Length, Petal.Length)) + geom_point()),
    g = purrr::pmap(list(gg1, gg2, gg3), ~ gridExtra::grid.arrange(..1, ..2, ..3))
  )




  

# Color labels using k-means clusters
km.clust <- kmeans(df, 4)$cluster
fviz_dend(res.hc, k = 4,
 k_colors = c("blue", "green3", "red", "black"),
 label_cols =  km.clust[res.hc$order], cex = 0.6)



#' distance Matrix given deck_codes
cos.dsimMatrix <- function( codes ) {
  deck.matrix <- LoR.Card$cardCode |> purrr::map_dfc(setNames, object = list(numeric()))
  for (i in 1:length(codes)) {
    decklist <- codes[i] |> lordecks::get_decklist_from_code()
    deck.matrix[NROW(deck.matrix)+1, decklist$cardcode] <- as.list(decklist$count)
  }
  deck.matrix <- deck.matrix |> mutate( across(everything(), ~replace_na(.x, 0)) ) 
  eisen_cos.sim(deck.matrix)
}



```



```{r}
library(dbscan)

data(iris)
iris <- as.matrix(iris[,1:4])
```

```{r}
library(dplyr)
library(tidyr)
library(purrr)
library(ggplot2)
iris0 <- iris %>%  
  group_by(Species) %>%  
  nest() %>%  
  mutate(
    gg1 = purrr::map(data, ~ ggplot(., aes(Sepal.Length, Sepal.Width)) + geom_point()),
    gg2 = purrr::map(data, ~ ggplot(., aes(Sepal.Length, Petal.Width)) + geom_point()),
    gg3 = purrr::map(data, ~ ggplot(., aes(Sepal.Length, Petal.Length)) + geom_point()),
    g = purrr::pmap(list(gg1, gg2, gg3), ~ gridExtra::grid.arrange(..1, ..2, ..3))
  )
```


```{r}
kNNdistplot(iris, k = 5)
abline(h=.5, col = "red", lty=2)
```
```{r}
res <- dbscan(iris, eps = .5, minPts = 5)
res
```
```{r}
pairs(iris, col = res$cluster + 1L)
```

```{r}
hullplot(x = iris, cl = res) # grafico delle aree convesse
```

```{r}
# if(!require(devtools)) install.packages("devtools")
# devtools::install_github("kassambara/factoextra")

library(factoextra)
data("multishapes")
df <- multishapes[, 1:2]
set.seed(123)
km.res <- kmeans(df, 5, nstart = 25)
fviz_cluster(km.res, df, frame = FALSE, geom = "point")

# install.packages("fpc")
# install.packages("dbscan")
```

```{r}
# Load the data 
# Make sure that the package factoextra is installed
data("multishapes", package = "factoextra")
df <- multishapes[, 1:2]
```

```{r}
library("fpc")
# Compute DBSCAN using fpc package
set.seed(123)
db <- fpc::dbscan(df, eps = 0.15, MinPts = 5)
# Plot DBSCAN results
plot(db, df, main = "DBSCAN", frame = FALSE)
```
```{r}
library("factoextra")
fviz_cluster(db, df, stand = FALSE, frame = FALSE, geom = "point")
```

```{r}
# Print DBSCAN
print(db)
```

```{r}
# Cluster membership. Noise/outlier observations are coded as 0
# A random subset is shown
db$cluster[sample(1:1089, 50)]
```
```{r}
dbscan::kNNdistplot(df, k =  5)
abline(h = 0.15, lty = 2)
```

```{r}
#The iris dataset is used:

# Load the data
data("iris")
iris <- as.matrix(iris[, 1:4])
#The optimal value of “eps” parameter can be determined as follow:

dbscan::kNNdistplot(iris, k =  4)
abline(h = 0.4, lty = 2)
# Compute DBSCAN using fpc::dbscan() and dbscan::dbscan(). Make sure that the 2 packages are installed:

set.seed(123)
# fpc package
res.fpc <- fpc::dbscan(iris, eps = 0.4, MinPts = 4)
# dbscan package
res.db <- dbscan::dbscan(iris, 0.4, 4)
# The result of the function fpc::dbscan() provides an object of class ‘dbscan’ containing the following components:
# cluster: integer vector coding cluster membership with noise observations (singletons) coded as 0
# isseed: logical vector indicating whether a point is a seed (not border, not noise)
# eps: parameter eps
# MinPts: parameter MinPts
# The result of the function dbscan::dbscan() is an integer vector with cluster assignments. Zero indicates noise points.
# Note that the function dbscan:dbscan() is a fast re-implementation of DBSCAN algorithm. The implementation is significantly faster and can work with larger data sets than the function fpc:dbscan().

# Make sure that both version produce the same results:

all(res.fpc$cluster == res.db)
## [1] TRUE
#The result can be visualized as follow:

fviz_cluster(res.fpc, iris, geom = "point")
```

```{r twitter-meta, echo = FALSE}
library(metathis)
meta() %>%
  meta_description(
    "First entry on a series of article that will gather my explorations over different way to define archetypes in Legends of Runeterra"
  ) %>% 
  meta_viewport() %>% 
  meta_social(
    title = "Defining Archetypes #1: Looking at the similarity of Akshan/Sivir/Zed with similar archetypes",
    url = "https://llorr-stats.netlify.app/",
    image = "images/archetypes/A01-ASZSZ.png",
    image_alt = "ASZSZ",
    og_type = "website",
    og_author = "Legna",
    twitter_card_type = "summary",
    twitter_creator = "@Maou_Legna"
  )
```

# Legal bla bla {.unnumbered}

This content was created under Riot Games' "Legal Jibber Jabber" policy using assets owned by Riot Games. Riot Games does not endorse or sponsor this project.
