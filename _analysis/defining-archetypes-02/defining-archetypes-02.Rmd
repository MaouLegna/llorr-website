---
title: "Defining Archetypes #2: Application of Hierarchical clustering algorithms to decklist"
description: | 
  . Second entry on my exploration about how to define archetypes in Legends of Runeterra
base_url: https://www.llorr-stats.com
preview:
author:
  - name: Valentino (Legna) Vazzoler
date: 09-23-2021
output:
 distill::distill_article:
    toc: true
    toc_float: true    
    toc_depth: 3
    self_contained: false
citation: false
draft: FALSE
params:
  start: "2021-09-01 21:00:00" #UTC tz / start of emergency patch 2.14
  end:   "2021-09-22 21:00:00" #UTC tz / end of patch 2.15
  skip:  2800000  # Patch 2.11 - after removing a few games  
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  eval = TRUE,
  warning = FALSE,
  error = FALSE,
  message = FALSE,
  comment = NA,
  R.options = list(width = 140,
                   digits.secs=6),
  dev.args = list(bg = 'transparent'), # make graphics with transparent background
  fig.align = 'center',
  fig.width=9,
  fig.height=6,
  engine.path = list(
    python = 'C:/anaconda/'   # -> use_python("C:/anaconda/")
  ),
  #'distill options
  layout="l-body-outset",
  preview=FALSE
)

#' R Option
source(file.path("C:","LlorR","scripts","lor_main.R" ))
require("factoextra")

# require(Hmisc)    # provides knitrSet and other functions
xaringanExtra::use_panelset()
```

```{r panelset-style}
xaringanExtra::style_panelset_tabs(font_family = "Roboto",
                                   active_foreground = "white",
                                   hover_foreground = "black",
                                   hover_border_color = "black",
                                   active_background = "#007fff"
                                   )
```

```{r twitter-meta, echo = FALSE}
library(metathis)
meta() %>%
  meta_description(
    "First entry on a series of article that will gather my explorations over different way to define archetypes in Legends of Runeterra"
  ) %>% 
  meta_viewport() %>% 
  meta_social(
    title = "Defining Archetypes #1: Looking at the similarity of Akshan/Sivir/Zed with similar archetypes",
    url = "https://llorr-stats.netlify.app/",
    image = "images/archetypes/A01-ASZSZ.png",
    image_alt = "ASZSZ",
    og_type = "website",
    og_author = "Legna",
    twitter_card_type = "summary",
    twitter_creator = "@Maou_Legna"
  )
```
```{r functions}
#' extract the top n most played list for 'archetypes provided'
top_n_codes <- \(DT = LoR.Melt.Matches.RMD,archetypes,n,dopull=T) DT|>filter(player%in%{{archetypes}})|>group_by(player)|>count(deck_code)|>slice_max(deck_code,n=n,with_ties=F)|>ungroup()%>%{if( dopull==T ) pull(.,deck_code) else .}

#' distance Matrix given deck_codes
cos.dsimMatrix <- function( codes ) {
  deck.matrix <- LoR.Card$cardCode |> purrr::map_dfc(setNames, object = list(numeric()))
  for (i in 1:length(codes)) {
    decklist <- codes[i] |> lordecks::get_decklist_from_code()
    deck.matrix[NROW(deck.matrix)+1, decklist$cardcode] <- as.list(decklist$count)
  }
  deck.matrix <- deck.matrix |> mutate( across(everything(), ~replace_na(.x, 0)) ) 
  eisen_cos.sim(deck.matrix)
}
```


```{r raw-data}
#' load gameDT
#'############
file.DT <- file.path("C:","LlorR","data","raw","LoR_MatchDT.csv")
header        <- fread(file.DT, header = FALSE, na.strings = c("",NA), nrows = 1, stringsAsFactors = FALSE)
LoR.Match.RMD <- fread(file.DT, header = FALSE, na.strings = c("",NA), skip = params$skip )
colnames(LoR.Match.RMD) <- unlist(header,use.names = F)

#' load Account
#'#############
file.Account <- file.path("C:","LlorR","data","raw","LoR_ACCOUNT.csv")
LoR.Account.RMD <- fread(file.Account, header=T, na.strings = c("",NA), encoding = 'UTF-8') |>
  mutate( RiotID = paste(gameName,tagLine),refID = puuid_4 ) |>
  pivot_longer(
  cols = contains("puuid"),
  names_to = "origin",
  values_to = "puuid"
)

#' load DeckDT
#'############
LoR.Deck        <- fread(file.path("C:","LlorR","data","raw","LoR_DECK.csv"),na.strings = c("",NA))
```
```{r Rubin-fix}
deck_filter <- LoR.Match.RMD |>
  #' Base filters
  filter( game_type=="Ranked" ) |>
  filter( game_start_time_utc > as.POSIXct(params$start, tz = "UTC") ) |>
  select(deck_code_1,deck_code_2) |>
  pivot_longer( cols = contains("deck_code"),values_to = "decks" ) |>
  filter(decks!="") |>
  distinct(decks)

LoR.Deck <- LoR.Deck[ deck_code %in% deck_filter$decks  ]

#' ASZ
LoR.Deck[ archetype %in% c("Akshan / Sivir (IO/SH)","Sivir / Zed","Akshan / Sivir / Zed"), archetype := "ASZ - Sivir Ionia"  ] 

#' Sion
RubinBait_deckCode_1 <- LoR.Deck %>%
  filter(factions == "faction_Noxus_Name,faction_Piltover_Name") %>%
  filter(archetype %in% c("Draven / Sion (NX/PZ)") ) %>%
  rowwise() %>%
  mutate(nCard = sum(str_detect(c_across(contains("Card")), getCardCode("Decimate")),na.rm = T)) %>% # "04FR018" # Abominable Guardian
  filter(nCard==3) %>%
  pull(deck_code)

LoR.Deck[deck_code %in% RubinBait_deckCode_1, archetype:="RubinBait - Draven / Sion" ]

#' Ezreal
RubinBait_deckCode_2 <- LoR.Deck %>%
  filter(factions == "faction_Noxus_Name,faction_Piltover_Name") %>%
  filter(archetype %in% c("Draven / Ezreal") ) %>%
  rowwise() %>%
  mutate(nCard = sum(str_detect(c_across(contains("Card")), getCardCode("Decimate")),na.rm = T)) %>% # "04FR018" # Abominable Guardian
  filter(nCard==3) %>%
  pull(deck_code)

LoR.Deck[deck_code %in% RubinBait_deckCode_2, archetype:="RubinBait - Draven / Ezreal" ]

#' Cait 
RubinBait_deckCode_3 <- LoR.Deck %>%
  filter(factions == "faction_Noxus_Name,faction_Piltover_Name") %>%
  filter(archetype %in% c("Caitlyn / Draven") ) %>%
  rowwise() %>%
  mutate(nCard = sum(str_detect(c_across(contains("Card")), getCardCode("Decimate")),na.rm = T)) %>% # "04FR018" # Abominable Guardian
  filter(nCard==3) %>%
  pull(deck_code)

LoR.Deck[deck_code %in% RubinBait_deckCode_3, archetype:="RubinBait - Caitlyn / Draven" ]

#' Bandle
# RubinBait_deckCode_4 <- LoR.Deck |>
#   filter(factions =="faction_BandleCity_Name,faction_Noxus_Name") |>
#   rowwise() |>
#   mutate(key_search = sum(str_detect(c_across(contains("Card")), getCardCode("Decimate")),na.rm = T)) |>
#   filter(key_search==3) |>
#   mutate(key_search = sum(str_detect(c_across(contains("Card")), getCardCode("Noxian Fervor")),na.rm = T)) |>
#   filter(key_search==3) |>
#   pull(deck_code)
# 
# LoR.Deck[deck_code %in% RubinBait_deckCode_4, archetype:="RubinBait - BandleBurn" ]
```

```{r prepare-data}
LoR.Melt.Matches.RMD <- LoR.Match.RMD |>
  #' Base filters
  filter( game_type=="Ranked" ) |>
  filter( game_start_time_utc >= as.POSIXct(params$start, tz = "UTC") & game_start_time_utc < as.POSIXct(params$end, tz = "UTC") ) |>
  #' 'process' data
  left_join(LoR.Deck[,.(deck_code,archetype)] |> setnames(old = "archetype", new = "player_1")   ,by=c("deck_code_1"="deck_code")) |>
  left_join(LoR.Deck[,.(deck_code,archetype)] |> setnames(old = "archetype", new = "opponent_1") ,by=c("deck_code_2"="deck_code")) |>
  mutate( player_2 = opponent_1, opponent_2 = player_1, oppoppuid_1 = puuid_2, oppoppuid_2 = puuid_1 ) |>
  select( match_key,server,game_start_time_utc,game_version,total_turn_count,
          ends_with("_1"),ends_with("_2"),-ends_with("_3"),-ends_with("_4"),-contains("deck_id"),-contains("participants") ) %>%
  #' melt data
  melt(id.vars=c("match_key","server","game_start_time_utc","game_version","total_turn_count"), measure.vars=patterns(
    str_sub(
      names(select(.,ends_with("_1")))
      ,end = -3)
  ),
  value.name = str_sub(
    names(select(.,ends_with("_1")))
    ,end = -3)
  ) |>
  #' finish 'process' data
  left_join(LoR.Account.RMD[,c("puuid","RiotID","refID")] |> setnames(old = "RiotID", new = "userID")     ,by=c("puuid"="puuid")) |>
  left_join(LoR.Account.RMD[,c("puuid","RiotID")] |> setnames(old = "RiotID", new = "opponentID") ,by=c("oppoppuid"="puuid")) |>
  left_join(LoR.Deck |> select(!archetype),by=c("deck_code","factions")) |>
  select(-ends_with("puuid"),-refID)
```

```{r Rubin-fix}
#' ASZ
LoR.Melt.Matches.RMD[ player %in% c("Akshan / Sivir (IO/SH)","Sivir / Zed","Akshan / Sivir / Zed"), player := "ASZ - Sivir Ionia"  ] 

#' RubinBaits decks
LoR.Deck <- LoR.Deck[ deck_code %in%  (LoR.Melt.Matches.RMD |> distinct(deck_code) |> pull()) ]

#' Sion
RubinBait_deckCode_1 <- LoR.Deck |>
  filter(factions == "faction_Noxus_Name,faction_Piltover_Name") |>
  filter(archetype %in% c("Draven / Sion (NX/PZ)") ) |>
  rowwise() |>
  mutate(nCard = sum(str_detect(c_across(contains("Card")), getCardCode("Decimate")),na.rm = T)) |> # "04FR018" # Abominable Guardian
  filter(nCard==3) |>
  pull(deck_code)

LoR.Melt.Matches.RMD[deck_code %in% RubinBait_deckCode_1, player:="RubinBait - Draven / Sion" ]

#' Ezreal
RubinBait_deckCode_2 <- LoR.Deck |>
  filter(factions == "faction_Noxus_Name,faction_Piltover_Name") |>
  filter(archetype %in% c("Draven / Ezreal") ) |>
  rowwise() |>
  mutate(nCard = sum(str_detect(c_across(contains("Card")), getCardCode("Decimate")),na.rm = T)) |> # "04FR018" # Abominable Guardian
  filter(nCard==3) |>
  pull(deck_code)

LoR.Melt.Matches.RMD[deck_code %in% RubinBait_deckCode_2, player:="RubinBait - Draven / Ezreal" ]

#' Cait 
RubinBait_deckCode_3 <- LoR.Deck |>
  filter(factions == "faction_Noxus_Name,faction_Piltover_Name") |>
  filter(archetype %in% c("Caitlyn / Draven") ) |>
  rowwise() |>
  mutate(nCard = sum(str_detect(c_across(contains("Card")), getCardCode("Decimate")),na.rm = T)) |> # "04FR018" # Abominable Guardian
  filter(nCard==3) |>
  pull(deck_code)

#' Bandle
RubinBait_deckCode_4 <- LoR.Deck |>
  filter(factions =="faction_BandleCity_Name,faction_Noxus_Name") |>
  rowwise() |>
  mutate(key_search = sum(str_detect(c_across(contains("Card")), getCardCode("Decimate")),na.rm = T)) |>
  filter(key_search==3) |>
  mutate(key_search = sum(str_detect(c_across(contains("Card")), getCardCode("Noxian Fervor")),na.rm = T)) |>
  filter(key_search==3) |>
  pull(deck_code)

LoR.Melt.Matches.RMD[deck_code %in% RubinBait_deckCode_4, player:="RubinBait - BandleBurn" ]
```

```{r distances}

# example <- matrix( c(3,1,0,0,0,
#                      0,2,0,0,0,
#                      3,0,0,0,0), ncol = 5, byrow=T )
# 
# dist(example, method = "manhattan")

```


```{r prepare-examples}
#' archetypes names
archetypes1 <- c( "Draven / Sion (NX/PZ)",
                  "Nami / Zoe",
                  "Senna / Veigar (BC/SI)",
                  "Gangplank / Twisted Fate (BC/BW)",
                  "Poppy / Ziggs (BC/NX)" )

archetypes2 <- c( "Draven / Sion (NX/PZ)",
                  "Poppy / Ziggs (BC/NX)",
                  "Braum / Vladimir",
                  # "Caitlyn / Draven",
                  "Gangplank / Miss Fortune (BW/NX)",
                  "Swain / Twisted Fate" )

archetypes3 <- c( "Draven / Sion (NX/PZ)",
                  "RubinBait - Draven / Sion",
                  "RubinBait - Caitlyn / Draven",
                  "RubinBait - BandleBurn" )

set.seed(7998)
archetypes4 <- LoR.Melt.Matches.RMD |>
  tabyl(player) |>
  arrange(desc(n)) |>
  filter(n >= 100) |>
  select(player) |>
  slice_sample(n = 15) |>
  pull()

#' codes
exCodes1 <- top_n_codes(archetypes = archetypes1,n = 10,dopull = T)
exCodes2 <- top_n_codes(archetypes = archetypes2,n = 10,dopull = T)
exCodes3 <- top_n_codes(archetypes = archetypes3,n = 10,dopull = T)

#' distance matrix
DSim_ex1 <- dsimMatrix(exCodes1)
DSim_ex2 <- dsimMatrix(exCodes2)
DSim_ex3 <- dsimMatrix(exCodes3)
```

# Introduction

Defining archetypes on Legends of Runeterra is both a complex and simple problem. It's simple if we consider that it's possible to define decks by the combination of champions and regions of choice but it's also complex by the fact that such definition is limited 

On our [previous article/analysis](https://llorr-stats.netlify.app/analysis/defining-archetypes-01/) we gave a possible method about how to compare archetypes and see if they can be considered from a shared common archetype or not. The proposed method makes use of inferential statistical analysis to reach a conclusion and so giving the results a certain robustness (not in the statistical meaning) with precise decision parameters. Sadly, it's also a methodology that's more fitting a posterior analysis, when hypothetical archetypes are already defined, a tool more fitted to refine the results.

# Data

The sample is reduced to `r NROW(LoR.Melt.Matches.RMD)` games

```{r}
# tbl1 <- LoR.Match.RMD |>
#   #' Stay only 'among' the row with the games in the time-frame I want
#   ####################################################################
#   slice(minrow_live:maxrow_live) |>
#   #' Extrapolate Friendly and 'to Scrap' matches
#   ##############################################
#   mutate( game_type = case_when(
#     status==404   ~ "Friendly",
#     is.na(status) ~ "to Scrap",
#     TRUE ~ as.character(game_type)
#     )) |>
#   #' Give to the new game_types a game_start_time_utc among the timeframe on interest
#   #' so it can be used a filter without worrying about other parameter like status and so on
#   ##########################################################################################
#   mutate( game_start_time_utc = replace( game_start_time_utc, game_type %in% c("Friendly","to Scrap"),  as.POSIXct(params$start, tz = "UTC")+days(3) ) ) |>
#   filter( game_start_time_utc >= as.POSIXct(params$start, tz = "UTC") & game_start_time_utc < as.POSIXct(params$end, tz = "UTC") ) |>
#   mutate( game_type = fct_other(factor(game_type),keep = c("Ranked","Friendly","to Scrap")) |> fct_infreq() ) |>
#   select(Status=game_type,Server=server) |>
#   #' Create tbl
#   #############
#   tbl_summary()
# 
# 
# LoR.Melt.Matches.RMD |>
#   gt() |>
#   tab_header(
#     title = "by the Numbers",
#     subtitle = "Ranked Games - Patch 2.15 second week / Master players"
#     #'**************************************************************************** *
#     # Update che patch-week!
#     #'**************************************************************************** *
#   ) |>
#   tab_footnote(
#     footnote = md(glue::glue("Max datetime recovered: {max_time} UTC from {params$start} to {params$end} UTC" )),
#     locations = cells_title(groups = c("subtitle"))
#     ) |>
#   tab_footnote(
#     footnote = md(glue::glue("EU Master players in the ladder: {length(namesList.EU.RMD)} while number of possible Master players recovered is: {masterEU} \n
#                               NA Master players in the ladder: {length(namesList.NA.RMD)} while number of possible Master players recovered is: {masterNA} \n
#                               ASIA Master players in the ladder: {length(namesList.ASIA.RMD)} while number of possible Master players recovered is: {masterASIA}" )),
#     locations = cells_title(groups = c("subtitle"))
#   ) |>
#   tab_options(data_row.padding = px(1.2))
#   
# nGames_tbl |>
#  tab_options(
#     table.background.color = "transparent",
#     table.font.color = "black",
#     table.font.color.light = "black"
#    )
```


## Complete Data

## Examples

In this article we will use 4 different examples:

1. Five archetypes with Different regions & different play style
  - Draven / Sion (NX/PZ)
  - Starfish - Nami / Zoe
  - Darkness - Senna / Veigar (BC/SI)
  - Ping City - Gangplank / Twisted Fate (BC/BW)
  - Poppy / Ziggs (BC/NX)
  
2. Five archetypes with a common regions & different play style
  - Draven / Sion (NX/PZ)
  - Poppy / Ziggs (BC/NX)
  - Braum / Vladimir
  - Ping City - Gangplank / Twisted Fate (BC/BW)
  - Poppy / Ziggs (BC/NX)


3. Four Similar regions & similar play style
  - RubinBait - Draven / Sion
  - RubinBait - Caitlyn / Draven
  - RubinBait - BandleBurn
  - Draven / Sion (NX/PZ)[^1]
  
4. Random selection of 15 archetypes
  
[^1]: much different from the other burn 3 burn decks but has the role of highlightiun

```{r}
archetypes1 <- c( "Draven / Sion (NX/PZ)",
                  "Nami / Zoe",
                  "Senna / Veigar (BC/SI)",
                  "Gangplank / Twisted Fate (BC/BW)",
                  "Poppy / Ziggs (BC/NX)" )

archetypes2 <- c( "Draven / Sion (NX/PZ)",
                  "Poppy / Ziggs (BC/NX)",
                  "Braum / Vladimir",
                  # "Caitlyn / Draven",
                  "Gangplank / Miss Fortune (BW/NX)",
                  "Swain / Twisted Fate" )

archetypes3 <- c( "Draven / Sion (NX/PZ)",
                  "RubinBait - Draven / Sion",
                  "RubinBait - Caitlyn / Draven",
                  "RubinBait - BandleBurn" )



```


```{r microbenchark }
set.seed(123)
microTimes <- microbenchmark::microbenchmark(
  hclust(DSim_ex1, method = "complete"),
  hclust(DSim_ex1, method = "single"),
  hclust(DSim_ex1, method = "average"),
  hclust(DSim_ex1, method = "centroid"),
  times = 50
)

microTimes
```

# Methods

## Aggregating Data - Clustering

### Hierarchical Clustering

It is good to find small subgroups

#### Complete

#### Single

### DBSCAN

# Analysis

## Hierchical Clustering

### Example 1 - Different regions & different win conditions

### Example 2 - Similar regions & different win conditions

### Example 3 - Similar regions & similar win conditions

## DBSCAN

# Conclusion


```{r Example1}
ex1.hc.complete <- hclust(DSim_ex1, method = "complete")
ex1.hc.single   <- hclust(DSim_ex1, method = "single")
ex1.hc.average  <- hclust(DSim_ex1, method = "average")
ex1.hc.centroid <- hclust(DSim_ex1, method = "centroid")



hc.complete$labels <- ExampleDT1$player
fviz_dend(hc.complete, cex = 0.5,
          label_cols =  ExampleDT1$origin )


# plot(hc.complete)

fviz_dist(DSim_ex1,
          gradient = list(low = "#00AFBB", mid = "white", high = "#FC4E07")) +
  labs(title = "Distance Matrix")


# Gap statistic plot
fviz_gap_stat(res.km$gap_stat)
# Optimal number of clusters using gap statistics
res.km$nbclust

# Silhouette plot
fviz_silhouette(res.km)

# Print result
res.km

# Enhanced hierarchical clustering
res.hc <- eclust(df, "hclust") # compute hclust
fviz_dend(res.hc, rect = TRUE) # dendrogam


fviz_dend(hc, cex = 0.5)
       
```



```{r}
# Cut the tree
fviz_dend(res.hc, cex = 0.5, k = 4, color_labels_by_k = TRUE)


# Don't color labels, add rectangles
fviz_dend(res.hc, cex = 0.5, k = 4,
 color_labels_by_k = FALSE, rect = TRUE)

# Change the color of tree using black color for all groups
# Change rectangle border colors
fviz_dend(res.hc, rect = TRUE, k_colors ="black",
rect_border = 2:5, rect_lty = 1)
```


```{r fig.width=12, fig.height=8 }
ex1DT <- top_n_codes(archetypes = archetypes1,n = 10,dopull = F) |>
  mutate( origin = as.numeric(as.factor(player)) )

hc.complete <- hclust(DSim_ex1, method = "average")
# plot(hc.complete)

fviz_dist(DSim_ex1,
          gradient = list(low = "#00AFBB", mid = "white", high = "#FC4E07")
          ) +
  labs(title = "Distance Matrix")
  
# Customized color for groups
fviz_dend(res.hc, k = 4,
 k_colors = c("#1B9E77", "#D95F02", "#7570B3", "#E7298A"))

# Color labels using k-means clusters
km.clust <- kmeans(df, 4)$cluster
fviz_dend(res.hc, k = 4,
 k_colors = c("blue", "green3", "red", "black"),
 label_cols =  km.clust[res.hc$order], cex = 0.6)


ExampleDT1 |>
  distinct(player,.keep_all = T) >
  select(player,origin)
plot(hc.complete, labels = ExampleDT1$player)

library("factoextra")


# ggplot(DSim_ex1)+
#       geom_tile()
# 
# # Compute cophentic distance
# res.coph <- cophenetic(hc.complete)
# # Correlation between cophenetic distance and the original distance
# cor(DSim_ex1, res.coph)

data(USArrests)
df <- scale(USArrests)
# Hierarchical clustering
res.hc <- hclust(dist(df))
# Default plot
fviz_dend(res.hc)


archetypes1.pretty <- c("Draven/Sion","StarFish","Darkness","Ping City","Poppy/Ziggs")
ex1.hc.complete$labels <- rep(archetypes1.pretty,each=10)
ex1.hc.single$labels <- rep(archetypes1.pretty,each=10)

fviz_dend(ex1.hc.complete, cex = 0.5,
          label_cols = rep(1:5,each=10) ) + 
  labs(title = "Complete") +
  
fviz_dend(ex1.hc.single, cex = 0.5,
        label_cols = rep(1:5,each=10) ) + 
  labs(title = "Single") +
  
fviz_dend(ex1.hc.average, cex = 0.5,
        label_cols = rep(1:5,each=10) ) + 
  labs(title = "Average") +
  
fviz_dend(ex1.hc.centroid, cex = 0.5,
        label_cols = rep(1:5,each=10) ) + 
  labs(title = "Centroid")  
  


iris0 <- iris %>%  
  group_by(Species) %>%  
  nest() %>%  
  mutate(
    gg1 = purrr::map(data, ~ ggplot(., aes(Sepal.Length, Sepal.Width)) + geom_point()),
    gg2 = purrr::map(data, ~ ggplot(., aes(Sepal.Length, Petal.Width)) + geom_point()),
    gg3 = purrr::map(data, ~ ggplot(., aes(Sepal.Length, Petal.Length)) + geom_point()),
    g = purrr::pmap(list(gg1, gg2, gg3), ~ gridExtra::grid.arrange(..1, ..2, ..3))
  )




  

# Color labels using k-means clusters
km.clust <- kmeans(df, 4)$cluster
fviz_dend(res.hc, k = 4,
 k_colors = c("blue", "green3", "red", "black"),
 label_cols =  km.clust[res.hc$order], cex = 0.6)



#' distance Matrix given deck_codes
cos.dsimMatrix <- function( codes ) {
  deck.matrix <- LoR.Card$cardCode |> purrr::map_dfc(setNames, object = list(numeric()))
  for (i in 1:length(codes)) {
    decklist <- codes[i] |> lordecks::get_decklist_from_code()
    deck.matrix[NROW(deck.matrix)+1, decklist$cardcode] <- as.list(decklist$count)
  }
  deck.matrix <- deck.matrix |> mutate( across(everything(), ~replace_na(.x, 0)) ) 
  eisen_cos.sim(deck.matrix)
}



```



```{r}
library(dbscan)

data(iris)
iris <- as.matrix(iris[,1:4])
```

```{r}
library(dplyr)
library(tidyr)
library(purrr)
library(ggplot2)
iris0 <- iris %>%  
  group_by(Species) %>%  
  nest() %>%  
  mutate(
    gg1 = purrr::map(data, ~ ggplot(., aes(Sepal.Length, Sepal.Width)) + geom_point()),
    gg2 = purrr::map(data, ~ ggplot(., aes(Sepal.Length, Petal.Width)) + geom_point()),
    gg3 = purrr::map(data, ~ ggplot(., aes(Sepal.Length, Petal.Length)) + geom_point()),
    g = purrr::pmap(list(gg1, gg2, gg3), ~ gridExtra::grid.arrange(..1, ..2, ..3))
  )
```


```{r}
kNNdistplot(iris, k = 5)
abline(h=.5, col = "red", lty=2)
```
```{r}
res <- dbscan(iris, eps = .5, minPts = 5)
res
```
```{r}
pairs(iris, col = res$cluster + 1L)
```

```{r}
hullplot(x = iris, cl = res) # grafico delle aree convesse
```

```{r}
# if(!require(devtools)) install.packages("devtools")
# devtools::install_github("kassambara/factoextra")

library(factoextra)
data("multishapes")
df <- multishapes[, 1:2]
set.seed(123)
km.res <- kmeans(df, 5, nstart = 25)
fviz_cluster(km.res, df, frame = FALSE, geom = "point")

# install.packages("fpc")
# install.packages("dbscan")
```

```{r}
# Load the data 
# Make sure that the package factoextra is installed
data("multishapes", package = "factoextra")
df <- multishapes[, 1:2]
```

```{r}
library("fpc")
# Compute DBSCAN using fpc package
set.seed(123)
db <- fpc::dbscan(df, eps = 0.15, MinPts = 5)
# Plot DBSCAN results
plot(db, df, main = "DBSCAN", frame = FALSE)
```
```{r}
library("factoextra")
fviz_cluster(db, df, stand = FALSE, frame = FALSE, geom = "point")
```

```{r}
# Print DBSCAN
print(db)
```

```{r}
# Cluster membership. Noise/outlier observations are coded as 0
# A random subset is shown
db$cluster[sample(1:1089, 50)]
```
```{r}
dbscan::kNNdistplot(df, k =  5)
abline(h = 0.15, lty = 2)
```

```{r}
#The iris dataset is used:

# Load the data
data("iris")
iris <- as.matrix(iris[, 1:4])
#The optimal value of “eps” parameter can be determined as follow:

dbscan::kNNdistplot(iris, k =  4)
abline(h = 0.4, lty = 2)
# Compute DBSCAN using fpc::dbscan() and dbscan::dbscan(). Make sure that the 2 packages are installed:

set.seed(123)
# fpc package
res.fpc <- fpc::dbscan(iris, eps = 0.4, MinPts = 4)
# dbscan package
res.db <- dbscan::dbscan(iris, 0.4, 4)
# The result of the function fpc::dbscan() provides an object of class ‘dbscan’ containing the following components:
# cluster: integer vector coding cluster membership with noise observations (singletons) coded as 0
# isseed: logical vector indicating whether a point is a seed (not border, not noise)
# eps: parameter eps
# MinPts: parameter MinPts
# The result of the function dbscan::dbscan() is an integer vector with cluster assignments. Zero indicates noise points.
# Note that the function dbscan:dbscan() is a fast re-implementation of DBSCAN algorithm. The implementation is significantly faster and can work with larger data sets than the function fpc:dbscan().

# Make sure that both version produce the same results:

all(res.fpc$cluster == res.db)
## [1] TRUE
#The result can be visualized as follow:

fviz_cluster(res.fpc, iris, geom = "point")
```


# Legal bla bla {.unnumbered}

This content was created under Riot Games' "Legal Jibber Jabber" policy using assets owned by Riot Games. Riot Games does not endorse or sponsor this project.