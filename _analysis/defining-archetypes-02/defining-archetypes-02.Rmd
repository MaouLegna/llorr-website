---
params:
  ind: "02"
  patch: "Patch 2.17 - Week 1"
  title: "Defining Archetypes #2: xxx xxx xxx"
  description: "xxx xxx xxx xxx"
  cardlurl: "https://dd.b.pvp.net/latest/set5/en_us/img/cards/05BC116.png"
  # prev:  "2021-09-29 21:00:00" #UTC tz / 'current' previous week start
  start: "2021-09-01 21:00:00" #UTC tz / 'current' week start
  end:   "2021-09-15 21:00:00" #UTC tz / 'current' week end
  skip:  2800000  # ~ Patch 2.16

title: | 
  `r params$title`
description: |
  `r params$patch` - `r params$description`
base_url: https://www.llorr-stats.com
preview: |
  `r params$cardlurl`
author:
  - name: Valentino (Legna) Vazzoler
date: 10-06-2021
output:
 distill::distill_article:
    toc: true
    toc_float: true
    toc_depth: 3
    self_contained: false
citation: false
draft: TRUE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  eval = TRUE,
  warning = FALSE,
  error = FALSE,
  message = FALSE,
  comment = NA,
  R.options = list(width = 140,
                   digits.secs=6),
  dev.args = list(bg = 'transparent'), # make graphics with transparent background
  fig.align = 'center',
  fig.width=12,
  fig.height=8,
  engine.path = list(
    python = 'C:/anaconda/'   # -> use_python("C:/anaconda/")
  ),
  #'distill options
  layout="l-body-outset",
  preview=FALSE
)

#' R Option
options(scipen = 999)
source(file.path("C:","LlorR","scripts","lor_main.R" ))
xaringanExtra::use_panelset()
```

```{r panelset-style}
xaringanExtra::style_panelset_tabs(
  font_family = "Helvetica",
  active_foreground = "white",
  hover_foreground = "black",
  hover_border_color = "black",
  active_background = "#007fff"
  )
```

```{r functions}
#' extract the top n most played list for 'archetypes provided'
top_n_codes <- \(DT = LoR.Melt.Matches.RMD,archetypes,n,dopull=T) DT |>
  dplyr::filter(player%in%{{archetypes}}) |>
  dplyr::group_by(player) |>
  dplyr::count(deck_code) |>
  dplyr::slice_max(deck_code,n=n,with_ties=F) |>
  ungroup()|>{\(x) if( dopull==T ) dplyr::pull(x,deck_code) else x}()


#' distance Matrix given deck_codes
dsimMatrix <- function( codes ) {
  deck.matrix <- LoR.Card$cardCode |> purrr::map_dfc(setNames, object = list(numeric()))
  for (i in 1:length(codes)) {
    if (i%%100==0) glue::glue("Fill parse matrix #{i} - {Sys.time()}") |> message()
    decklist <- codes[i] |> lordecks::get_decklist_from_code()
    deck.matrix[NROW(deck.matrix)+1, decklist$cardcode] <- as.list(decklist$count)
  }
  deck.matrix |> mutate( across(everything(), ~replace_na(.x, 0)) ) 
}

#' distance Matrix given deck_codes
cos.dsimMatrix <- function( codes ) {
  deck.matrix <- LoR.Card$cardCode |> purrr::map_dfc(setNames, object = list(numeric()))
  for (i in 1:length(codes)) {
    if (i%%500==0) glue::glue("Fill parse matrix #{i} - {Sys.time()}") |> message()
    decklist <- codes[i] |> lordecks::get_decklist_from_code()
    deck.matrix[NROW(deck.matrix)+1, decklist$cardcode] <- as.list(decklist$count)
  }
  deck.matrix <- deck.matrix |> mutate( across(everything(), ~replace_na(.x, 0)) ) 
  eisen_cos.sim(deck.matrix)
}
```


```{r raw-data-all}
# skip.dt <-fread(file.path("C:","LlorR","data","raw","skip_row.csv")  )
# skip.dt

#' load gameDT
#'############
file.DT <- file.path("C:","LlorR","data","raw","LoR_MatchDT.csv")
header        <- fread(file.DT, header = FALSE, na.strings = c("",NA), nrows = 1, stringsAsFactors = FALSE)
LoR.Match.RMD <- fread(file.DT, header = FALSE, na.strings = c("",NA), skip = params$skip )
colnames(LoR.Match.RMD) <- unlist(header,use.names = F)

patch215216code <- LoR.Match.RMD |>
  filter( game_type=="Ranked" ) |>
  filter( game_start_time_utc >= as.POSIXct(params$start, tz = "UTC") & game_start_time_utc < as.POSIXct(params$end, tz = "UTC") ) |>
  select( -ends_with("_3"),-ends_with("_4")  ) |>
  select( starts_with("deck_code") ) |>
  pivot_longer(cols = c(ends_with("_1"),ends_with("_2")),
               names_to = c(".value"),
               names_pattern = "(.*)_[0-9]"
               )

#' load Account
#'#############
LoR.Account.RMD <- fread(file.path("C:","LlorR","data","raw","LoR_ACCOUNT.csv"),
                         header=T, na.strings = c("",NA), encoding = 'UTF-8') |>
  mutate( RiotID = sprintf("%s#%s",gameName,tagLine) )

#' load DeckDT
#'############
LoR.Deck        <- fread(file.path("C:","LlorR","data","raw","LoR_DECK.csv"),na.strings = c("",NA))

#' load parse Matrix
#'##################
DSim_patch214215 <- fread(file.path("C:","LlorR","data","clean","DSimMatrix_0215to0216.csv"))
cos.DSim_patch214215 <- fread(file.path("C:","LlorR","data","clean","cos.DSimMatrix_0215to0216.csv"), header=T) |> as.matrix()
# fwrite(DSim_patch215216,file.path("C:","LlorR","data","clean","DSimMatrix_0215to0216.csv"))

# cos.DSim_patch214215[1:10,1:10]
# DSim_patch214215[1:10] |> eisen_cos.sim()

NROW(cos.DSim_patch214215)
```

```{r distances}
# example <- matrix( c(3,1,0,0,0,
#                      0,2,0,0,0,
#                      3,0,0,0,0), ncol = 5, byrow=T )
# 
# dist(example, method = "manhattan")
```


```{r prepare-examples}
#' archetypes names
archetypes1 <- c( 
  "Draven/Sion (NX/PZ)",
  "Nami/Zoe",
  "Senna/Veigar (BC/SI)",
  "Miss Fortune/Quinn",
  "Poppy/Ziggs (BC/NX)"
  )
# getCardCode("Quinn")

archetypes2 <- c(
  "Draven/Sion (NX/PZ)",
  "Poppy/Ziggs (BC/NX)",
  "Braum/Vladimir",
  "Gangplank/Miss Fortune (BW/NX)",
  "Swain/Twisted Fate"
)

archetypes3 <- c(
  "Draven/Sion (NX/PZ)",
  "RubinBait - Draven/Sion",
  "RubinBait - Caitlyn/Draven",
  "RubinBait - Draven/Ezreal"
  # "RubinBait - BandleBurn"
)

# LoR.Deck[ !is.na(archetype_pretty), archetype:=archetype_pretty  ]

# set.seed(123)
# archetypes4 <- LoR.Deck |>
#   tabyl(archetype) |>
#   arrange(desc(n)) |>
#   filter(n >= 100) |>
#   select(archetype) |>
#   slice_sample(n = 15) |>
#   pull()

#' codes
# exCodes1 <- top_n_codes(archetypes = archetypes1,n = 10,dopull = T)
# exCodes2 <- top_n_codes(archetypes = archetypes2,n = 10,dopull = T)
# exCodes3 <- top_n_codes(archetypes = archetypes3,n = 10,dopull = T)

# set.seed(123)
# exCodes1 <- LoR.Deck[ archetype %in% archetypes1, sample(deck_code,size = 20), by=archetype ]
# exCodes2 <- LoR.Deck[ archetype %in% archetypes2, sample(deck_code,size = 20), by=archetype ]
# exCodes3 <- LoR.Deck[ archetype %in% archetypes3, sample(deck_code,size = 20), by=archetype ]
# 
# #' distance matrix
# DSim_ex1 <- cos.dsimMatrix(exCodes1$V1)
# DSim_ex2 <- cos.dsimMatrix(exCodes2$V1)
# DSim_ex3 <- cos.dsimMatrix(exCodes3$V1)

# DSim_patch215216 <- unique(patch215216code$deck_code) |> dsimMatrix()
# fwrite(DSim_patch215216,file.path("C:","LlorR","data","clean","DSimMatrix_0215to0216.csv"))

DSim <- DSim_patch215216 |> eisen_cos.sim()

# fwrite(as.matrix(DSim),file.path("C:","LlorR","data","clean","cos.DSimMatrix_0215to0216.csv"))



head(DSim)
```

# Introduction

Defining archetypes on Legends of Runeterra is both a complex and simple problem. It's simple if we consider that it's possible to define decks by the combination of champions and regions of choice but it's also complex by the fact that such definition is limited 

On our [previous article/analysis](https://llorr-stats.netlify.app/analysis/defining-archetypes-01/) we gave a possible method about how to compare archetypes and see if they can be considered from a shared common archetype or not. The proposed method makes use of inferential statistical analysis to reach a conclusion and so giving the results a certain robustness (not in the statistical meaning) with precise decision parameters. Sadly, it's also a methodology that's more fitting a posterior analysis, when hypothetical archetypes are already defined, a tool more fitted to refine the results.

# Data

The sample is reduced to `r NROW(LoR.Melt.Matches.RMD)` games

## Complete Data

## Examples

In this article we will use 4 different examples:

1. Five archetypes with Different regions & different play style
  - Draven / Sion (NX/PZ)
  - Starfish - Nami / Zoe
  - Darkness - Senna / Veigar (BC/SI)
  - Ping City - Gangplank / Twisted Fate (BC/BW)
  - Poppy / Ziggs (BC/NX)
  
2. Five archetypes with a common regions & different play style
  - Draven / Sion (NX/PZ)
  - Poppy / Ziggs (BC/NX)
  - Braum / Vladimir
  - Ping City - Gangplank / Twisted Fate (BC/BW)
  - Poppy / Ziggs (BC/NX)


3. Four Similar regions & similar play style
  - RubinBait - Draven / Sion
  - RubinBait - Caitlyn / Draven
  - RubinBait - BandleBurn
  - Draven / Sion (NX/PZ)[^1]
  
4. Random selection of 15 archetypes
  
[^1]: much different from the other burn 3 burn decks but has the role of highlightiun

```{r microbenchark }
set.seed(123)
microTimes <- microbenchmark::microbenchmark(
  hclust(DSim_ex1, method = "complete"),
  hclust(DSim_ex1, method = "single"),
  hclust(DSim_ex1, method = "average"),
  hclust(DSim_ex1, method = "centroid"),
  times = 50
)

microTimes
```

# Methods

## Aggregating Data - Clustering

### Hierarchical Clustering

It is good to find small subgroups

#### Complete

#### Single

### DBSCAN

# Analysis

## Hierchical Clustering

### Example 1 - Different regions & different win conditions

### Example 2 - Similar regions & different win conditions

### Example 3 - Similar regions & similar win conditions

## DBSCAN

# Conclusion


```{r Example1}
ex1.hc.complete <- hclust(DSim_ex1, method = "complete")
set.seed(123)
ex1.hc.complete.n <- hclust(DSim_ex1, method = "complete", members = sample(1:5000,100))

ex1.hc.single   <- hclust(DSim_ex1, method = "single")

ex1.hc.average  <- hclust(DSim_ex1, method = "average")
set.seed(123)
ex1.hc.average.n  <- hclust(DSim_ex1, method = "average", members = sample(1:5000,100))

ex1.hc.centroid <- hclust(DSim_ex1, method = "centroid")
set.seed(123)
ex1.hc.centroid.n <- hclust(DSim_ex1, method = "centroid", members = sample(1:5000,100))

ex1.hc.complete$labels <- rep(archetypes1,each=20)
fviz_dend(ex1.hc.complete, cex = 0.5 )
fviz_dend(ex1.hc.complete.n, cex = 0.5 )

fviz_dend(ex1.hc.average, cex = 0.5 )
fviz_dend(ex1.hc.average.n, cex = 0.5 )

fviz_dend(ex1.hc.centroid, cex = 0.5 )
fviz_dend(ex1.hc.centroid.n, cex = 0.5 )

# label_cols =  rep(1:5,each=5)

# plot(hc.complete)

fviz_dist(DSim_ex1,
          gradient = list(low = "#00AFBB", mid = "white", high = "#FC4E07")) +
  labs(title = "Distance Matrix")


# Gap statistic plot
fviz_gap_stat(res.km$gap_stat)
# Optimal number of clusters using gap statistics
res.km$nbclust

# Silhouette plot
fviz_silhouette(res.km)

# Print result
res.km

# Enhanced hierarchical clustering
res.hc <- eclust(df, "hclust") # compute hclust
fviz_dend(res.hc, rect = TRUE) # dendrogam


fviz_dend(hc, cex = 0.5)



       
```



```{r}
# Cut the tree
fviz_dend(res.hc, cex = 0.5, k = 4, color_labels_by_k = TRUE)


# Don't color labels, add rectangles
fviz_dend(res.hc, cex = 0.5, k = 4,
 color_labels_by_k = FALSE, rect = TRUE)

# Change the color of tree using black color for all groups
# Change rectangle border colors
fviz_dend(res.hc, rect = TRUE, k_colors ="black",
rect_border = 2:5, rect_lty = 1)
```


```{r fig.width=12, fig.height=8 }
ex1DT <- top_n_codes(archetypes = archetypes1,n = 10,dopull = F) |>
  mutate( origin = as.numeric(as.factor(player)) )

hc.complete <- hclust(DSim_ex1, method = "average")
# plot(hc.complete)

fviz_dist(DSim_ex1,
          gradient = list(low = "#00AFBB", mid = "white", high = "#FC4E07")
          ) +
  labs(title = "Distance Matrix")
  
# Customized color for groups
fviz_dend(res.hc, k = 4,
 k_colors = c("#1B9E77", "#D95F02", "#7570B3", "#E7298A"))

# Color labels using k-means clusters
km.clust <- kmeans(df, 4)$cluster
fviz_dend(res.hc, k = 4,
 k_colors = c("blue", "green3", "red", "black"),
 label_cols =  km.clust[res.hc$order], cex = 0.6)


ExampleDT1 |>
  distinct(player,.keep_all = T) >
  select(player,origin)
plot(hc.complete, labels = ExampleDT1$player)

library("factoextra")


# ggplot(DSim_ex1)+
#       geom_tile()
# 
# # Compute cophentic distance
# res.coph <- cophenetic(hc.complete)
# # Correlation between cophenetic distance and the original distance
# cor(DSim_ex1, res.coph)

data(USArrests)
df <- scale(USArrests)
# Hierarchical clustering
res.hc <- hclust(dist(df))
# Default plot
fviz_dend(res.hc)


archetypes1.pretty <- c("Draven/Sion","StarFish","Darkness","Ping City","Poppy/Ziggs")
ex1.hc.complete$labels <- rep(archetypes1.pretty,each=10)
ex1.hc.single$labels <- rep(archetypes1.pretty,each=10)

fviz_dend(ex1.hc.complete, cex = 0.5,
          label_cols = rep(1:5,each=10) ) + 
  labs(title = "Complete") +
  
fviz_dend(ex1.hc.single, cex = 0.5,
        label_cols = rep(1:5,each=10) ) + 
  labs(title = "Single") +
  
fviz_dend(ex1.hc.average, cex = 0.5,
        label_cols = rep(1:5,each=10) ) + 
  labs(title = "Average") +
  
fviz_dend(ex1.hc.centroid, cex = 0.5,
        label_cols = rep(1:5,each=10) ) + 
  labs(title = "Centroid")  
  


iris0 <- iris %>%  
  group_by(Species) %>%  
  nest() %>%  
  mutate(
    gg1 = purrr::map(data, ~ ggplot(., aes(Sepal.Length, Sepal.Width)) + geom_point()),
    gg2 = purrr::map(data, ~ ggplot(., aes(Sepal.Length, Petal.Width)) + geom_point()),
    gg3 = purrr::map(data, ~ ggplot(., aes(Sepal.Length, Petal.Length)) + geom_point()),
    g = purrr::pmap(list(gg1, gg2, gg3), ~ gridExtra::grid.arrange(..1, ..2, ..3))
  )




  

# Color labels using k-means clusters
km.clust <- kmeans(df, 4)$cluster
fviz_dend(res.hc, k = 4,
 k_colors = c("blue", "green3", "red", "black"),
 label_cols =  km.clust[res.hc$order], cex = 0.6)



#' distance Matrix given deck_codes
cos.dsimMatrix <- function( codes ) {
  deck.matrix <- LoR.Card$cardCode |> purrr::map_dfc(setNames, object = list(numeric()))
  for (i in 1:length(codes)) {
    decklist <- codes[i] |> lordecks::get_decklist_from_code()
    deck.matrix[NROW(deck.matrix)+1, decklist$cardcode] <- as.list(decklist$count)
  }
  deck.matrix <- deck.matrix |> mutate( across(everything(), ~replace_na(.x, 0)) ) 
  eisen_cos.sim(deck.matrix)
}



```



```{r}
library(dbscan)

data(iris)
iris <- as.matrix(iris[,1:4])
```

```{r}
library(dplyr)
library(tidyr)
library(purrr)
library(ggplot2)
iris0 <- iris %>%  
  group_by(Species) %>%  
  nest() %>%  
  mutate(
    gg1 = purrr::map(data, ~ ggplot(., aes(Sepal.Length, Sepal.Width)) + geom_point()),
    gg2 = purrr::map(data, ~ ggplot(., aes(Sepal.Length, Petal.Width)) + geom_point()),
    gg3 = purrr::map(data, ~ ggplot(., aes(Sepal.Length, Petal.Length)) + geom_point()),
    g = purrr::pmap(list(gg1, gg2, gg3), ~ gridExtra::grid.arrange(..1, ..2, ..3))
  )
```


```{r}
kNNdistplot(iris, k = 5)
abline(h=.5, col = "red", lty=2)
```
```{r}
res <- dbscan(iris, eps = .5, minPts = 5)
res
```
```{r}
pairs(iris, col = res$cluster + 1L)
```

```{r}
hullplot(x = iris, cl = res) # grafico delle aree convesse
```

```{r}
# if(!require(devtools)) install.packages("devtools")
# devtools::install_github("kassambara/factoextra")

library(factoextra)
data("multishapes")
df <- multishapes[, 1:2]
set.seed(123)
km.res <- kmeans(df, 5, nstart = 25)
fviz_cluster(km.res, df, frame = FALSE, geom = "point")

# install.packages("fpc")
# install.packages("dbscan")
```

```{r}
# Load the data 
# Make sure that the package factoextra is installed
data("multishapes", package = "factoextra")
df <- multishapes[, 1:2]
```

```{r}
library("fpc")
# Compute DBSCAN using fpc package
set.seed(123)
db <- fpc::dbscan(df, eps = 0.15, MinPts = 5)
# Plot DBSCAN results
plot(db, df, main = "DBSCAN", frame = FALSE)
```
```{r}
library("factoextra")
fviz_cluster(db, df, stand = FALSE, frame = FALSE, geom = "point")
```

```{r}
# Print DBSCAN
print(db)
```

```{r}
# Cluster membership. Noise/outlier observations are coded as 0
# A random subset is shown
db$cluster[sample(1:1089, 50)]
```
```{r}
dbscan::kNNdistplot(df, k =  5)
abline(h = 0.15, lty = 2)
```

```{r}
#The iris dataset is used:

# Load the data
data("iris")
iris <- as.matrix(iris[, 1:4])
#The optimal value of “eps” parameter can be determined as follow:

dbscan::kNNdistplot(iris, k =  4)
abline(h = 0.4, lty = 2)
# Compute DBSCAN using fpc::dbscan() and dbscan::dbscan(). Make sure that the 2 packages are installed:

set.seed(123)
# fpc package
res.fpc <- fpc::dbscan(iris, eps = 0.4, MinPts = 4)
# dbscan package
res.db <- dbscan::dbscan(iris, 0.4, 4)
# The result of the function fpc::dbscan() provides an object of class ‘dbscan’ containing the following components:
# cluster: integer vector coding cluster membership with noise observations (singletons) coded as 0
# isseed: logical vector indicating whether a point is a seed (not border, not noise)
# eps: parameter eps
# MinPts: parameter MinPts
# The result of the function dbscan::dbscan() is an integer vector with cluster assignments. Zero indicates noise points.
# Note that the function dbscan:dbscan() is a fast re-implementation of DBSCAN algorithm. The implementation is significantly faster and can work with larger data sets than the function fpc:dbscan().

# Make sure that both version produce the same results:

all(res.fpc$cluster == res.db)
## [1] TRUE
#The result can be visualized as follow:

fviz_cluster(res.fpc, iris, geom = "point")
```

```{r twitter-meta, echo = FALSE}
library(metathis)
meta() %>%
  meta_description(
    "First entry on a series of article that will gather my explorations over different way to define archetypes in Legends of Runeterra"
  ) %>% 
  meta_viewport() %>% 
  meta_social(
    title = "Defining Archetypes #1: Looking at the similarity of Akshan/Sivir/Zed with similar archetypes",
    url = "https://llorr-stats.netlify.app/",
    image = "images/archetypes/A01-ASZSZ.png",
    image_alt = "ASZSZ",
    og_type = "website",
    og_author = "Legna",
    twitter_card_type = "summary",
    twitter_creator = "@Maou_Legna"
  )
```

# Legal bla bla {.unnumbered}

This content was created under Riot Games' "Legal Jibber Jabber" policy using assets owned by Riot Games. Riot Games does not endorse or sponsor this project.
