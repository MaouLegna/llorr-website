---
title: "Defining Archetypes #2: Application of Hierarchical clustering algorithms to decklist"
description: | 
  . Second entry on my exploration about how to define archetypes in Legends of Runeterra
base_url: https://www.llorr-stats.com
preview:
author:
  - name: Valentino (Legna) Vazzoler
date: 09-23-2021
output:
 distill::distill_article:
    toc: true
    toc_float: true    
    toc_depth: 3
    self_contained: false
citation: false
draft: FALSE
params:
  start: "2021-09-01 21:00:00" #UTC tz / start of emergency patch 2.14
  end:   "2021-09-22 21:00:00" #UTC tz / end of patch 2.15
  skip:  2800000  # Patch 2.11 - after removing a few games  
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  eval = TRUE,
  warning = FALSE,
  error = FALSE,
  message = FALSE,
  comment = NA,
  R.options = list(width = 140,
                   digits.secs=6),
  dev.args = list(bg = 'transparent'), # make graphics with transparent background
  fig.align = 'center',
  fig.width=9,
  fig.height=6,
  engine.path = list(
    python = 'C:/anaconda/'   # -> use_python("C:/anaconda/")
  ),
  #'distill options
  layout="l-body-outset",
  preview=FALSE
)

#' R Option
source(file.path("C:","LlorR","scripts","lor_main.R" ))
require("factoextra")

# require(Hmisc)    # provides knitrSet and other functions
xaringanExtra::use_panelset()
```

```{r panelset-style}
xaringanExtra::style_panelset_tabs(font_family = "Roboto",
                                   active_foreground = "white",
                                   hover_foreground = "black",
                                   hover_border_color = "black",
                                   active_background = "#007fff"
                                   )
```

```{r twitter-meta, echo = FALSE}
library(metathis)
meta() %>%
  meta_description(
    "First entry on a series of article that will gather my explorations over different way to define archetypes in Legends of Runeterra"
  ) %>% 
  meta_viewport() %>% 
  meta_social(
    title = "Defining Archetypes #1: Looking at the similarity of Akshan/Sivir/Zed with similar archetypes",
    url = "https://llorr-stats.netlify.app/",
    image = "images/archetypes/A01-ASZSZ.png",
    image_alt = "ASZSZ",
    og_type = "website",
    og_author = "Legna",
    twitter_card_type = "summary",
    twitter_creator = "@Maou_Legna"
  )
```
```{r functions}
#' extract the top n most played list for 'archetypes provided'
top_n_codes <- \(DT = LoR.Melt.Matches.RMD,archetypes,n,dopull=T) DT|>filter(player%in%{{archetypes}})|>group_by(player)|>count(deck_code)|>slice_max(deck_code,n=n,with_ties=F)|>ungroup()%>%{if( dopull==T ) pull(.,deck_code) else .}

#' distance Matrix given deck_codes
dsimMatrix <- function( codes ) {
  deck.matrix <- LoR.Card$cardCode |> purrr::map_dfc(setNames, object = list(numeric()))
  for (i in 1:length(codes)) {
    decklist <- codes[i] |> lordecks::get_decklist_from_code()
    deck.matrix[NROW(deck.matrix)+1, decklist$cardcode] <- as.list(decklist$count)
  }
  deck.matrix |> mutate( across(everything(), ~replace_na(.x, 0)) )
}
```


```{r raw-data}
#' load gameDT
#'############
file.DT <- file.path("C:","LlorR","data","raw","LoR_MatchDT.csv")
header        <- fread(file.DT, header = FALSE, na.strings = c("",NA), nrows = 1, stringsAsFactors = FALSE)
LoR.Match.RMD <- fread(file.DT, header = FALSE, na.strings = c("",NA), skip = params$skip )
colnames(LoR.Match.RMD) <- unlist(header,use.names = F)

#' load Account
#'#############
file.Account <- file.path("C:","LlorR","data","raw","LoR_ACCOUNT.csv")
LoR.Account.RMD <- fread(file.Account, header=T, na.strings = c("",NA), encoding = 'UTF-8') |>
  mutate( RiotID = paste(gameName,tagLine),refID = puuid_4 ) |>
  pivot_longer(
  cols = contains("puuid"),
  names_to = "origin",
  values_to = "puuid"
)

#' load DeckDT
#'############
LoR.Deck        <- fread(file.path("C:","LlorR","data","raw","LoR_DECK.csv"),na.strings = c("",NA))
```

# Data {.unnumbered}

```{r prepare-data}
LoR.Melt.Matches.RMD <- LoR.Match.RMD |>
  #' Base filters
  filter( game_type=="Ranked" ) |>
  filter( game_start_time_utc >= as.POSIXct(params$start, tz = "UTC") & game_start_time_utc < as.POSIXct(params$end, tz = "UTC") ) |>
  #' 'process' data
  left_join(LoR.Deck[,.(deck_code,archetype)] |> setnames(old = "archetype", new = "player_1")   ,by=c("deck_code_1"="deck_code")) |>
  left_join(LoR.Deck[,.(deck_code,archetype)] |> setnames(old = "archetype", new = "opponent_1") ,by=c("deck_code_2"="deck_code")) |>
  mutate( player_2 = opponent_1, opponent_2 = player_1, oppoppuid_1 = puuid_2, oppoppuid_2 = puuid_1 ) |>
  select( match_key,server,game_start_time_utc,game_version,total_turn_count,
          ends_with("_1"),ends_with("_2"),-ends_with("_3"),-ends_with("_4"),-contains("deck_id"),-contains("participants") ) %>%
  #' melt data
  melt(id.vars=c("match_key","server","game_start_time_utc","game_version","total_turn_count"), measure.vars=patterns(
    str_sub(
      names(select(.,ends_with("_1")))
      ,end = -3)
  ),
  value.name = str_sub(
    names(select(.,ends_with("_1")))
    ,end = -3)
  ) |>
  #' finish 'process' data
  left_join(LoR.Account.RMD[,c("puuid","RiotID","refID")] |> setnames(old = "RiotID", new = "userID")     ,by=c("puuid"="puuid")) |>
  left_join(LoR.Account.RMD[,c("puuid","RiotID")] |> setnames(old = "RiotID", new = "opponentID") ,by=c("oppoppuid"="puuid")) |>
  left_join(LoR.Deck |> select(!archetype),by=c("deck_code","factions")) |>
  select(-ends_with("puuid"),-refID)
```

```{r Rubin-fix}
#' ASZ
LoR.Melt.Matches.RMD[ player %in% c("Akshan / Sivir (IO/SH)","Sivir / Zed","Akshan / Sivir / Zed"), player := "ASZ - Sivir Ionia"  ] 

#' RubinBaits decks
LoR.Deck <- LoR.Deck[ deck_code %in%  (LoR.Melt.Matches.RMD |> distinct(deck_code) |> pull()) ]

#' Sion
RubinBait_deckCode_1 <- LoR.Deck |>
  filter(factions == "faction_Noxus_Name,faction_Piltover_Name") |>
  filter(archetype %in% c("Draven / Sion (NX/PZ)") ) |>
  rowwise() |>
  mutate(nCard = sum(str_detect(c_across(contains("Card")), getCardCode("Decimate")),na.rm = T)) |> # "04FR018" # Abominable Guardian
  filter(nCard==3) |>
  pull(deck_code)

LoR.Melt.Matches.RMD[deck_code %in% RubinBait_deckCode_1, player:="RubinBait - Draven / Sion" ]

#' Ezreal
RubinBait_deckCode_2 <- LoR.Deck |>
  filter(factions == "faction_Noxus_Name,faction_Piltover_Name") |>
  filter(archetype %in% c("Draven / Ezreal") ) |>
  rowwise() |>
  mutate(nCard = sum(str_detect(c_across(contains("Card")), getCardCode("Decimate")),na.rm = T)) |> # "04FR018" # Abominable Guardian
  filter(nCard==3) |>
  pull(deck_code)

LoR.Melt.Matches.RMD[deck_code %in% RubinBait_deckCode_2, player:="RubinBait - Draven / Ezreal" ]

#' Cait 
RubinBait_deckCode_3 <- LoR.Deck |>
  filter(factions == "faction_Noxus_Name,faction_Piltover_Name") |>
  filter(archetype %in% c("Caitlyn / Draven") ) |>
  rowwise() |>
  mutate(nCard = sum(str_detect(c_across(contains("Card")), getCardCode("Decimate")),na.rm = T)) |> # "04FR018" # Abominable Guardian
  filter(nCard==3) |>
  pull(deck_code)

#' Bandle
RubinBait_deckCode_4 <- LoR.Deck |>
  filter(factions =="faction_BandleCity_Name,faction_Noxus_Name") |>
  rowwise() |>
  mutate(key_search = sum(str_detect(c_across(contains("Card")), getCardCode("Decimate")),na.rm = T)) |>
  filter(key_search==3) |>
  mutate(key_search = sum(str_detect(c_across(contains("Card")), getCardCode("Noxian Fervor")),na.rm = T)) |>
  filter(key_search==3) |>
  pull(deck_code)

LoR.Melt.Matches.RMD[deck_code %in% RubinBait_deckCode_4, player:="RubinBait - BandleBurn" ]
```

```{r prepare-examples}
#' archetypes names
archetypes1 <- c( "Draven / Sion (NX/PZ)",
                  "Nami / Zoe",
                  "Senna / Veigar (BC/SI)",
                  "Gangplank / Twisted Fate (BC/BW)",
                  "Poppy / Ziggs (BC/NX)" )

archetypes2 <- c( "Draven / Sion (NX/PZ)",
                  "Poppy / Ziggs (BC/NX)",
                  "Braum / Vladimir",
                  # "Caitlyn / Draven",
                  "Gangplank / Miss Fortune (BW/NX)",
                  "Swain / Twisted Fate" )

archetypes3 <- c( "Draven / Sion (NX/PZ)",
                  "RubinBait - Draven / Sion",
                  "RubinBait - Caitlyn / Draven",
                  "RubinBait - BandleBurn" )

#' codes
exCodes1 <- top_n_codes(archetypes = archetypes1,n = 10,dopull = T)
exCodes2 <- top_n_codes(archetypes = archetypes2,n = 10,dopull = T)
exCodes3 <- top_n_codes(archetypes = archetypes3,n = 10,dopull = T)

#' distance matrix
DSim_1 <- dsimMatrix(exCodes1)
DSim_2 <- dsimMatrix(exCodes2)
DSim_3 <- dsimMatrix(exCodes3)
```

```{r microbenchark }
set.seed(123)
microTimes <- microbenchmark::microbenchmark(
  hclust(DSim_ex1, method = "complete"),
  hclust(DSim_ex1, method = "single"),
  hclust(DSim_ex1, method = "average"),
  hclust(DSim_ex1, method = "centroid"),
  times = 50L
)

microTimes
```

```{r Example1}
ex1.hc.complete <- hclust(DSim_ex1, method = "complete")
ex1.hc.single   <- hclust(DSim_ex1, method = "single")
ex1.hc.average  <- hclust(DSim_ex1, method = "average")
ex1.hc.centroid <- hclust(DSim_ex1, method = "centroid")



hc.complete$labels <- ExampleDT1$player
fviz_dend(hc.complete, cex = 0.5,
          label_cols =  ExampleDT1$origin )


# plot(hc.complete)

fviz_dist(DSim_ex1,
          gradient = list(low = "#00AFBB", mid = "white", high = "#FC4E07")) +
  labs(title = "Distance Matrix")


# Gap statistic plot
fviz_gap_stat(res.km$gap_stat)
# Optimal number of clusters using gap statistics
res.km$nbclust

# Silhouette plot
fviz_silhouette(res.km)

# Print result
res.km

# Enhanced hierarchical clustering
res.hc <- eclust(df, "hclust") # compute hclust
fviz_dend(res.hc, rect = TRUE) # dendrogam


fviz_dend(hc, cex = 0.5)
       
```



```{r}
# Cut the tree
fviz_dend(res.hc, cex = 0.5, k = 4, color_labels_by_k = TRUE)


# Don't color labels, add rectangles
fviz_dend(res.hc, cex = 0.5, k = 4,
 color_labels_by_k = FALSE, rect = TRUE)

# Change the color of tree using black color for all groups
# Change rectangle border colors
fviz_dend(res.hc, rect = TRUE, k_colors ="black",
rect_border = 2:5, rect_lty = 1)
```


```{r fig.width=12, fig.height=8 }
ex1DT <- top_n_codes(archetypes = archetypes1,n = 10,dopull = F) |>
  mutate( origin = as.numeric(as.factor(player)) )

hc.complete <- hclust(DSim_ex1, method = "average")
# plot(hc.complete)

fviz_dist(DSim_ex1,
          gradient = list(low = "#00AFBB", mid = "white", high = "#FC4E07")
          ) +
  labs(title = "Distance Matrix")
  
# Customized color for groups
fviz_dend(res.hc, k = 4,
 k_colors = c("#1B9E77", "#D95F02", "#7570B3", "#E7298A"))

# Color labels using k-means clusters
km.clust <- kmeans(df, 4)$cluster
fviz_dend(res.hc, k = 4,
 k_colors = c("blue", "green3", "red", "black"),
 label_cols =  km.clust[res.hc$order], cex = 0.6)


ExampleDT1 |>
  distinct(player,.keep_all = T) >
  select(player,origin)
plot(hc.complete, labels = ExampleDT1$player)

library("factoextra")


# ggplot(DSim_ex1)+
#       geom_tile()
# 
# # Compute cophentic distance
# res.coph <- cophenetic(hc.complete)
# # Correlation between cophenetic distance and the original distance
# cor(DSim_ex1, res.coph)

data(USArrests)
df <- scale(USArrests)
# Hierarchical clustering
res.hc <- hclust(dist(df))
# Default plot
fviz_dend(res.hc)


archetypes1.pretty <- c("Draven/Sion","StarFish","Darkness","Ping City","Poppy/Ziggs")
ex1.hc.complete$labels <- rep(archetypes1.pretty,each=10)
ex1.hc.single$labels <- rep(archetypes1.pretty,each=10)

fviz_dend(ex1.hc.complete, cex = 0.5,
          label_cols = rep(1:5,each=10) ) + 
  labs(title = "Complete") +
  
fviz_dend(ex1.hc.single, cex = 0.5,
        label_cols = rep(1:5,each=10) ) + 
  labs(title = "Single") +
  
fviz_dend(ex1.hc.average, cex = 0.5,
        label_cols = rep(1:5,each=10) ) + 
  labs(title = "Average") +
  
fviz_dend(ex1.hc.centroid, cex = 0.5,
        label_cols = rep(1:5,each=10) ) + 
  labs(title = "Centroid")  
  
  
  

# Color labels using k-means clusters
km.clust <- kmeans(df, 4)$cluster
fviz_dend(res.hc, k = 4,
 k_colors = c("blue", "green3", "red", "black"),
 label_cols =  km.clust[res.hc$order], cex = 0.6)
```



```{r}
library(dbscan)

data(iris)
iris <- as.matrix(iris[,1:4])
```

```{r}
kNNdistplot(iris, k = 5)
abline(h=.5, col = "red", lty=2)
```
```{r}
res <- dbscan(iris, eps = .5, minPts = 5)
res
```
```{r}
pairs(iris, col = res$cluster + 1L)
```

```{r}
hullplot(x = iris, cl = res) # grafico delle aree convesse
```

```{r}
# if(!require(devtools)) install.packages("devtools")
# devtools::install_github("kassambara/factoextra")

library(factoextra)
data("multishapes")
df <- multishapes[, 1:2]
set.seed(123)
km.res <- kmeans(df, 5, nstart = 25)
fviz_cluster(km.res, df, frame = FALSE, geom = "point")

# install.packages("fpc")
# install.packages("dbscan")
```

```{r}
# Load the data 
# Make sure that the package factoextra is installed
data("multishapes", package = "factoextra")
df <- multishapes[, 1:2]
```

```{r}
library("fpc")
# Compute DBSCAN using fpc package
set.seed(123)
db <- fpc::dbscan(df, eps = 0.15, MinPts = 5)
# Plot DBSCAN results
plot(db, df, main = "DBSCAN", frame = FALSE)
```
```{r}
library("factoextra")
fviz_cluster(db, df, stand = FALSE, frame = FALSE, geom = "point")
```

```{r}
# Print DBSCAN
print(db)
```

```{r}
# Cluster membership. Noise/outlier observations are coded as 0
# A random subset is shown
db$cluster[sample(1:1089, 50)]
```
```{r}
dbscan::kNNdistplot(df, k =  5)
abline(h = 0.15, lty = 2)
```

```{r}
#The iris dataset is used:

# Load the data
data("iris")
iris <- as.matrix(iris[, 1:4])
#The optimal value of “eps” parameter can be determined as follow:

dbscan::kNNdistplot(iris, k =  4)
abline(h = 0.4, lty = 2)
# Compute DBSCAN using fpc::dbscan() and dbscan::dbscan(). Make sure that the 2 packages are installed:

set.seed(123)
# fpc package
res.fpc <- fpc::dbscan(iris, eps = 0.4, MinPts = 4)
# dbscan package
res.db <- dbscan::dbscan(iris, 0.4, 4)
# The result of the function fpc::dbscan() provides an object of class ‘dbscan’ containing the following components:
# cluster: integer vector coding cluster membership with noise observations (singletons) coded as 0
# isseed: logical vector indicating whether a point is a seed (not border, not noise)
# eps: parameter eps
# MinPts: parameter MinPts
# The result of the function dbscan::dbscan() is an integer vector with cluster assignments. Zero indicates noise points.
# Note that the function dbscan:dbscan() is a fast re-implementation of DBSCAN algorithm. The implementation is significantly faster and can work with larger data sets than the function fpc:dbscan().

# Make sure that both version produce the same results:

all(res.fpc$cluster == res.db)
## [1] TRUE
#The result can be visualized as follow:

fviz_cluster(res.fpc, iris, geom = "point")
```


# Legal bla bla {.unnumbered}

This Meta Report was created under Riot Games' "Legal Jibber Jabber" policy using assets owned by Riot Games. Riot Games does not endorse or sponsor this project.


```{r}

# lor_deckcodes <- reticulate::import("lor_deckcodes")
# 
# lordecks::get_decklist_from_code("CQBQCAIEBAAQKBQBA4CQUAJJOSTQDLYBYIA4MAIBAYCQUGTAQEAYIANAAHAACAIBAUFNCAI",format = "simple")
# 
# sampleData <- LoR.Melt.Matches.RMD|>
#   slice_tail(n=5) |>
#   select(match_key,factions,deck_code)
# 
# sampleData |>
#   distinct(deck_code) |>
#   mutate(cards_list = map(.x = deck_code, .f = ~lordecks::get_decklist_from_code(.,format = "simple") )) |>
#   right_join(sampleData, by = "deck_code") |>
#   # distinct(across(c(starts_with("faction_"), cards_list))) %>%
#   mutate(
#     cards = map_chr(cards_list, str_flatten, collapse = " "),
#     champs = str_extract_all(cards, pattern = paste(LoR.Champion$cardCode, collapse = "|")),
#     champs_factions = str_extract_all(champs, pattern = paste(c("BC","BW","DE","FR","IO","NX","MT","SI","SH"), collapse = "|")),
#     champs = map_chr(champs, str_flatten, collapse = " "),
#     champs_factions = map_chr(champs_factions, str_flatten, collapse = " ")
#   ) 
#   
# %>%
#   left_join(data_regions %>% select(faction_abb1 = abbreviation, nameRef), by = c("faction_1" = "nameRef")) %>%
#   left_join(data_regions %>% select(faction_abb2 = abbreviation, nameRef), by = c("faction_2" = "nameRef")) %>%
#   unite(col = factions, faction_abb1, faction_abb2, sep = " ") %>%
#   mutate(
#     factions = str_remove_all(factions, pattern = " NA|NA "),
#     across(c(champs, champs_factions, factions),  function(x) unname(sapply(x, function(x) { paste(sort(trimws(strsplit(x[1], ' ')[[1]])), collapse=' ')} ))),
#     no_fix = map2_lgl(.x = factions, .y = champs_factions, .f = ~grepl(pattern = .x, x = .y)),
#     champs_factions = str_replace_all(champs_factions, pattern = " ", replacement = "|"),
#     champs_factions = paste0(champs_factions, "| "),
#     factions_to_add = str_remove_all(factions, pattern = champs_factions),
#     archetype = if_else(no_fix, champs, sprintf("%s (%s)", champs, factions_to_add))
#   ) %>%
#   left_join(data, ., by = c("faction_1", "faction_2", "cards_list")) %>%
#   select(-c(cards_list, champs_factions, factions, no_fix, factions_to_add))
# 
# # make archetype name nicer
# data <- data %>%
#   mutate(archetype = str_replace_all(archetype, set_names(data_champs$name, data_champs$cardCode))) %>%
#   mutate(across(archetype, function(x) ifelse(grepl("^( )", x), paste0("No Champions", x), x)))
```

