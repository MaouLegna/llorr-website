---
title: "DEFINING ARCHETYPES #1: LOOKING AT THE SIMILARITY OF AKSHAN/SIVIR/ZED DECKS WITH SIMILAR ARCHETYPES"
description: |
  First entry on a series of article that will gather my explorations over different way to define archetypes in Legends of Runeterra
base_url: https://llorr-stats.netlify.app
preview: "images/preview-mastery.png"
author:
  - name: Valentino (Legna) Vazzoler
date: 08-01-2021
output:
 distill::distill_article:
    toc: true
    toc_float: true    
    toc_depth: 3
    self_contained: false
citation: false
draft: TRUE
twitter:
  site: "@Maou_Legna"
  creator: "@Maou_Legna"
params:
  # prev:  "2021-07-07 21:00:00" #UTC tz / 'previous' week start
  start: "2021-07-14 21:00:00" #UTC tz / 'current' week start
  end:   "2021-08-25 21:00:00" #UTC tz / 'current' week end
  skip:  1850000  # Patch 2.11 - after removing a few games  
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  eval = TRUE,
  warning = FALSE,
  error = FALSE,
  message = FALSE,
  comment = NA,
  R.options = list(width = 140,
                   digits.secs=6),
  dev.args = list(bg = 'transparent'), # make graphics with transparent background
  fig.align = 'center',
  fig.width=9,
  fig.height=6,
  engine.path = list(
    python = 'C:/anaconda/'   # -> use_python("C:/anaconda/")
  ),
  #'distill options
  layout="l-body-outset",
  preview=FALSE
)

#' R Option
source(file.path("C:","LlorR","scripts","lor_main.R" ))

# require(Hmisc)    # provides knitrSet and other functions
xaringanExtra::use_panelset()
#' Python
# py_run_string("print('Hello World')")
# lor_deckcodes <- import("lor_deckcodes")
# py_module_available("lor_deckcodes")
```

```{r panelset-style}
xaringanExtra::style_panelset_tabs(font_family = "Roboto",
                                   active_foreground = "white",
                                   hover_foreground = "black",
                                   hover_border_color = "black",
                                   active_background = "#007fff"
                                   )
```

# Introduction

This series of article/analysis are meant to rappresent my journey in how to define archetypes.

Archetypes in Legends of Runeterra are *currently* defined by me by the combinations of champions and regions. While it's a lazy method, it's (was?) a first approximation that worked decently aside for some exception. A limitation I always knew is that the number of possible archetypes increase too rapidaly with the release of new cards and will probably get too high compared to the number of available games (at least at Master) sooner or later. On the other side of the spectrum the most restricting classification would with a categorical (maybe even just dichotomical) variable, something like using the **Super Archetypes** from viciousSyndicate (vS): *Initiative* and *Resource* decks [^1]. Every other archetype classification is in immediatiate and it's a vast ocean of possibilities with no 'correct' solution.

[^1]: their definition, example and so on will be a topic for the future.

As everything needs to be done step by step, I'll start with what was pointed to me a few weeks ago:

```{r tweet1}
require(tweetrmd)
tweet_screenshot(tweet_url("drlor4", "1420488109603442688"),
                 maxwidth = 400)
```

Ever since Dragons decks turned into legit meta options (also 'Overwhelm' decks with "Renekton / Sejuani / Sivir") deck with 3 champions (often in a ratio 3-2-1) have become more widely used and they are their *acceptance* as legfit option increased without being considered some wacky tech. Of course I'm just talking about *acceptance*, I'm not talking about performances or if they are indeed the better option, again this could be a topic for the future and not regarding the archetypes definitions.

So, returning to the tweet, in the previous patch at the moment I'm writing this (2.14) a clear case of three champions being played togheter are: Akshan/Sivir/Zed (ASZ).

The question is simple: is my current aggregation too lacking? There are archetypes that may indeed looks similar to other just by intuition but it's not a "proper approach", but are they? Is Sivir/Zed just a special (SZ) case of ASZ that lacks Akshan?

This article will try to respond to such question.

**Note**: I'm aware that the aggregation problem is not limited to cases with three champions but even with 2, see Viego with different regions, or what actually matters are even just a couple of cards in the deck like "Feel the Rush" or "ARAM (Howling Abyss)" but as mentioned, one must proceed with baby steps and tackling and example of the 'three champ' problem is probably the easiest example.

# Data

```{r raw-data}
#' load gameDT
#'############
file.DT <- file.path("C:","LlorR","data","raw","LoR_MatchDT.csv")
header        <- fread(file.DT, header = FALSE, na.strings = c("",NA), nrows = 1, stringsAsFactors = FALSE)
LoR.Match.RMD <- fread(file.DT, header = FALSE, na.strings = c("",NA), skip = 1850000 ) # ~2.11/2.12
colnames(LoR.Match.RMD) <- unlist(header,use.names = F)

#' load Account
#'#############
file.Account <- file.path("C:","LlorR","data","raw","LoR_ACCOUNT.csv")
LoR.Account.RMD <- fread(file.Account, header=T, na.strings = c("",NA), encoding = 'UTF-8') %>%
  mutate( RiotID = paste(gameName,tagLine),refID = puuid_4 ) %>%
  pivot_longer(
  cols = c("puuid","puuid_1","puuid_2","puuid_3","puuid_4"),
  names_to = "origin",
  values_to = "puuid"
)

#' load DeckDT
#'############
LoR.Deck        <- fread(file.path("C:","LlorR","data","raw","LoR_DECK.csv"),na.strings = c("",NA))
```

```{r account-info}
masterEU   <- LoR.Account.RMD %>% filter(activeShard=="europe"   & master=="master") %>% distinct(gameName,tagLine) %>% count() %>% pull()
masterNA   <- LoR.Account.RMD %>% filter(activeShard=="americas" & master=="master") %>% distinct(gameName,tagLine) %>% count() %>% pull()
masterASIA <- LoR.Account.RMD %>% filter(activeShard=="asia"     & master=="master") %>% distinct(gameName,tagLine) %>% count() %>% pull()

namesList.EU.RMD     <- length(lor_leaderboard("europe")$name)
namesList.NA.RMD     <- length(lor_leaderboard("americas")$name)
namesList.ASIA.RMD   <- length(lor_leaderboard("asia")$name)
```

```{r prepare-data}
LoR.Melt.Matches.RMD <- LoR.Match.RMD %>%
  #' Base filters
  ###############
  filter( game_type=="Ranked" ) %>%
  filter( game_start_time_utc >= as.POSIXct(params$start, tz = "UTC") & game_start_time_utc < as.POSIXct(params$end, tz = "UTC") ) %>%
  #' 'process' data
  #################
  left_join(.,LoR.Deck[,.(deck_code,archetype)] %>% setnames(old = "archetype", new = "player_1")   ,by=c("deck_code_1"="deck_code")) %>%
  left_join(.,LoR.Deck[,.(deck_code,archetype)] %>% setnames(old = "archetype", new = "opponent_1") ,by=c("deck_code_2"="deck_code")) %>%
  mutate( player_2 = opponent_1, opponent_2 = player_1, oppoppuid_1 = puuid_2, oppoppuid_2 = puuid_1 ) %>%
  select( match_key,server,game_start_time_utc,game_version,total_turn_count,
          ends_with("_1"),ends_with("_2"),-ends_with("_3"),-ends_with("_4"),-contains("deck_id"),-contains("participants") ) %>%
  #' melt data
  ############
  melt(id.vars=c("match_key","server","game_start_time_utc","game_version","total_turn_count"), measure.vars=patterns(
    str_sub(
      names(select(.,ends_with("_1")))
      ,end = -3)
  ),
  value.name = str_sub(
    names(select(.,ends_with("_1")))
    ,end = -3)
  ) %>%
  #' finish 'process' data
  ########################
  left_join(. , LoR.Account.RMD[,c("puuid","RiotID","refID")] %>% setnames(old = "RiotID", new = "userID")     ,by=c("puuid"="puuid")) %>%
  left_join(. , LoR.Account.RMD[,c("puuid","RiotID")] %>% setnames(old = "RiotID", new = "opponentID") ,by=c("oppoppuid"="puuid")) %>%
  left_join(.,LoR.Deck %>% select(!archetype),by=c("deck_code","factions")) %>%
  #' nChamp
  #########
  rowwise() %>%
  mutate(champions = extract_champions(c_across(contains("Champion")) ) ) %>%
  ungroup() %>%
  mutate( nChamp = str_count(champions,pattern = "/")+1) %>%
  mutate( nChamp = replace(nChamp, str_detect(player,"Championless"),0) ) %>%
  select(-ends_with("puuid"),-refID)
```

The sample is made of `r NROW(LoR.Melt.Matches.RMD)` Ranked games from `r params$start` to `r params$end`, so covering the patch 2.13 after the start of the Ruination Event so that there wouldn't be any change i the card pool in the timeframe analyzed.

```{r ASZ}
#' Akshan / Sivir / Zed abs freq
################################
nGames <- LoR.Melt.Matches.RMD %>%
  filter( player != "Akshan / Sivir (DE/SH)" ) %>%
  NROW()

ASZ.DT <- LoR.Melt.Matches.RMD %>%
  filter( player != "Akshan / Sivir (DE/SH)" ) %>%
  filter( champions == "Akshan / Sivir / Zed" )

LoR.Melt.Matches.RMD %<>%
  filter( player != "Akshan / Sivir (DE/SH)" )
```

Because there was the raise of the Demacian deck with Akshan/Sivir, these decks are removed as they could create a few problem in the following steps. The sample is reduced to `r nGames` games

Let's now add some information about the presence of ASZ decks and the variant with just Zed (SZ) or just Akshan (AZ).

First of all, the amount of 'Akshan/Sivir/Zed' decks in the sample amounts to `r NROW(ASZ.DT)`

```{r table-nChamp}
require(gtsummary)
require(gt)

tbl1 <- LoR.Melt.Matches.RMD %>%
  mutate( SZ = ifelse( (str_detect(champions,"Sivir") & str_detect(champions,"Zed"))  ,"Sivir/Zed","no Sivir/Zed") ) %>%
  select(nChamp,SZ) %>%
  gtsummary::tbl_summary(., by = SZ, label = nChamp ~ "#Champion") %>%
  gtsummary::add_overall()
  # gtsummary::as_gt() %>%
  # gt::tab_source_note(gt::md(glue::glue("Ranked games from {params$start} to {params$end}")))

tbl2 <- LoR.Melt.Matches.RMD %>%
  mutate( SZ = ifelse( (str_detect(champions,"Sivir") & str_detect(champions,"Akshan"))  ,"Sivir/Akshan","no Sivir/Akshan") ) %>%
  select(nChamp,SZ) %>%
  gtsummary::tbl_summary(., by = SZ, label = nChamp ~ "#Champion")
  # gtsummary::add_overall()
  # gtsummary::as_gt() %>%
  # gt::tab_source_note(gt::md(glue::glue("Ranked games from {params$start} to {params$end}")))
  
tbl <- tbl_merge( 
    tbls = list(tbl1, tbl2),
    tab_spanner = c("**Zed**", "**Akshan**")
  )
  # modify_spanning_header(stat_0_1 ~ NA)

tbl %>%
  as_gt() %>%
  tab_options(
    table.background.color = "transparent",
    table.font.color = "black",
    table.font.color.light = "black"
  )
```

```{r}
tblData <- LoR.Melt.Matches.RMD %>%
  tabyl(nChamp)

#' overall freq of 3 champ decks
################################
nChamp3.percent <- tblData %>%
  filter(nChamp == 3) %>%
  pull(percent) %>%
  percent(accuracy = 0.01)

nChamp3 <- tblData %>%
  filter(nChamp == 3) %>%
  pull(n)
  

#' freq of decks with 3 champs among decks with Sivir Zed
##########################################################
SZ3.percent <- LoR.Melt.Matches.RMD %>%
  mutate( SZ = ifelse( (str_detect(champions,"Sivir") & str_detect(champions,"Zed"))  ,"Sivir/Zed","no Sivir/Zed") )

#' Absolute number for SivirZed3
################################
SZ3 <- LoR.Melt.Matches.RMD %>%
  mutate( SZ = ifelse( (str_detect(champions,"Sivir") & str_detect(champions,"Zed"))  ,"Sivir/Zed","no Sivir/Zed") ) %>%
  filter( SZ == "Sivir/Zed" ) %>%
  tabyl(nChamp) %>%
  filter(nChamp == 3) %>%
  pull(n)

#' Absolute number for SivirAkshan3  
###################################
SA3 <- LoR.Melt.Matches.RMD %>%
  mutate( SZ = ifelse( (str_detect(champions,"Sivir") & str_detect(champions,"Akshan"))  ,"Sivir/Akshan","no Sivir/Akshan") ) %>%
  filter( SZ == "Sivir/Akshan" ) %>%
  tabyl(nChamp) %>%
  filter(nChamp == 3) %>%
  pull(n)

# sprintf(paste0("",round(tblData[4,"percent"]*100,2),"%%"))
```

```{r}
tbl
```

`r kableExtra::text_spec("Note :", color = "red")` The percetages are column-wise

The overall prevalence of '3 champions deck' while it may looks higher than common believes (`r nChamp3.percent`) the value is mostly carried by the Akshan/Sivir/Zed which amoutn to almost half the cases of 3 champs decks `r round(NROW(ASZ.DT)/nChamp3,3)*100`%

More specificaly, those `r NROW(ASZ.DT)` ASZ decks are the main subset of both SZ decks when using 3-champions (`r round(NROW(ASZ.DT)/SZ3,3)*100`% of the cases) and for AZ decks too (`r round(NROW(ASZ.DT)/SA3,3)*100`% of the cases). In other words, it seems the ASZ are indeed almost always the case of the 3-champion option when going from two to three champions starting from SZ or AS.

```{r print-gt-SZ-three-champ}
SZgt <- LoR.Melt.Matches.RMD %>%
  filter(nChamp %in% 3 ) %>%
  filter( str_detect(champions,"Sivir") & str_detect(champions,"Zed") ) %>%
  select(champions) %>%
  separate_rows(champions,sep = " / ") %>%
  janitor::tabyl(champions) %>%
  arrange(desc(n)) %>%
  mutate( percent = percent*3 ) %>%
  filter( champions %!in% c("Sivir","Zed") ) %>%
  select(-n) %>%
  gt() %>%
  tab_header(
    title = "Champions Frequencies",
    subtitle = "Prevalance of the 'third' champion in Sivir/Zed with 3 Champions"
  ) %>%
  fmt_percent(
    columns = percent,
    decimals = 3
  ) %>%
  cols_label(
    champions = md(str_to_title("**champions**")),
    percent = md(str_to_title("**percent**"))
  ) 

SZgt %>%
  tab_options(
    table.background.color = "transparent",
    table.font.color = "black",
    table.font.color.light = "black"
  )

SZgt
```
Lastly, just to give a bit of additional info, the previous tables shows the relative frequencies of the third champion of choice in decks with three champions with Sivir and Zed

# Methods

This section illustrate the conceptual framework I'll (would) use to tackle the question for this article.

While the question is about the similarity between ASZ and SZ decks what I'll try to look at are the following relationships:

```{r}
require(DiagrammeR)

grViz("
      digraph TB {

      # node definitions with substituted label text
      node [fontname = Arial, shape = oval, color = Gold, style = filled, fontcolor = Black]
      a [label = '@@1']
      
      node [fontname = Arial] // sets as circles
      b [label = '@@2']
      c [label = '@@3']
      
      subgraph {
        rank = same; b; c;
      }
      
      # add node statements
      a -> {b,c} [color = green, label = 'subset of ASZ']
      b -> a [color = red]
      c -> a [color = red]
      
      b->c 
      c->b 
      
      }
      [1]: 'Akshan/Sivir/Zed'
      [2]: 'Sivir/Akshan'
      [3]: 'Sivir/Zed'
      
      ")
```
* The first step would be finding whenever Sivir/Zed (SZ) and Sivir/Akshan (SA) decks are a specific case of Akshan/Sivir/Zed (ASZ) decks. ( green arrow )

* If true, and only then, the following and final step would then be accerting the similarity/equality of Sivir/Akshan with Sivir/Zed ( black arrow )

```{r veen}
require(eulerr)

tbl<-tibble(
    AkshanSiviZed=rep(1, 5),
    AkshanSivir=c(1,1,0,0,0)
)
tbl

plot(euler(tbl))
```
Or to make it simpler:

* The first step is seeking if there is indeed an intersection between AkshanSivir and SivirZed

* If there is indeed an intersection how relevant it is. Is it big enough so that the two archetypes should be aggregated ?


```{r archetype-decklist}
AS <- LoR.Melt.Matches.RMD %>%
  filter( player == "Akshan / Sivir (IO/SH)" ) %>%
  pull(deck_code)

SZ <- LoR.Melt.Matches.RMD %>%
  filter( player == "Sivir / Zed" ) %>%
  pull(deck_code)

ASZ <- LoR.Melt.Matches.RMD %>%
  filter( player == "Akshan / Sivir / Zed" ) %>%
  pull(deck_code)

# set.seed(123)
# rASZ <- LoR.Melt.Matches.RMD %>%
#   filter( player == "Akshan / Sivir / Zed" ) %>%
#   slice_sample(n = 10) %>%
#   pull(deck_code)
```

```{r define-functions}
# ak_into_zed <- function(deck_code){
#   # If Akshan Sivir is the indeed a special case of Akshan Sivir Zed, than removing all decks for Akshan / Sivir should give similar distributions
#   # getCardCode("Akshan") # 04SH130 <- 3
#   # getCardCode("Sivir")  # 04SH020 <- 3
#   # getCardCode("Zed")    # 01IO009 <- 0
#   
#   # deck_code <- "CMCACAICBQAQEAQFAEBQEGIGAQDRIJRWG5OWOAYBAMBAUAIEA6BACAYBAILCKMICAECAPCQBAIAQECI2"
#   
#   deck_code %>%
#   # "CMCACAICBQAQEAQFAEBQEGIGAQDRIJRWG5OWOAYBAMBAUAIEA6BACAYBAILCKMICAECAPCQBAIAQECI2" %>%
#     lordecks::get_decklist_from_code() |>
#     dplyr::filter( cardcode != "01IO009" ) |>
#     dplyr::mutate( count = replace(count, cardcode %in% c("04SH020","04SH030"), 3) ) |>
#     lordecks::get_code_from_decklist_df()
# }

rm_asz <- function(deck_code) {
  deck_code %>%
  # "CMCACAICBQAQEAQFAEBQEGIGAQDRIJRWG5OWOAYBAMBAUAIEA6BACAYBAILCKMICAECAPCQBAIAQECI2" %>%
    lordecks::get_decklist_from_code() |>
    dplyr::filter( cardcode %!in% c("01IO009","04SH120","04SH130") ) |>
    lordecks::get_code_from_decklist_df()
}
```

How to approach this problem? There are several options, both that I may can think and that I cannot currently imagine. Since this is the foundation of the tools I want to use in the future for defining archetypes it will use clustering methods. By using clustering a distance is necessary and a distance is indeed the tool I'll mainly use for the analysis.


```{r modify-deckcode}
ASZ.rm.codes <- ASZ %>%
  tabyl() %>%
  arrange(desc(n)) %>%
  mutate( cumFreq = cumsum(percent) ) %>%
  filter( cumFreq <= 0.50 ) %>%
  rename("deck_code"=1) %>%
  pull(deck_code) %>%
  map_chr(.x = ., ~rm_asz(.x))

SZ.rm.codes <- SZ %>%
  tabyl() %>%
  arrange(desc(n)) %>%
  mutate( cumFreq = cumsum(percent) ) %>%
  filter( cumFreq <= 0.50 ) %>%
  rename("deck_code"=1) %>%
  pull(deck_code) %>%
  map_chr(.x = ., ~rm_asz(.x))

  # slice_tail(n=10)
```

```{r create-matrix}
# LoR.Deck.RMD <- paste(paste0("Card","."), str_pad(01:40, 2, pad = "0"),sep="") %>% purrr::map_dfc(setNames, object = list(numeric()))
# Subset <- LoR.Deck %>% slice_head(n=1) %>% select(starts_with("Card"))
# DeckRow <- Subset[1,]  %>% unlist(.,use.names = F) %>% table()  

deck.matrix <- LoR.Card$cardCode %>% purrr::map_dfc(setNames, object = list(numeric()))
codes <- c(ASZ.rm.codes,SZ.rm.codes)

for (i in 1:length(codes)) {
  # decklist <- codes[1] %>% get_decklist_from_code()
  decklist <- codes[i] %>% get_decklist_from_code()
  deck.matrix[NROW(deck.matrix)+1, decklist$cardcode] <- as.list(decklist$count)
}

deck.matrix <- deck.matrix %>% 
  mutate( across(everything(), ~replace_na(.x, 0))  )
```
```{r}
# require(igraph)
# 
# # Create Igraph object
# graph <- graph_from_adjacency_matrix(deck.matrix, mode="undirected")
# 
# # Make a tidygraph object from it. Igraph methods can still be called on it.
# tbl_graph <- as_tbl_graph(graph)
# 
# hub_id <- which.max(degree(graph))
# 
# # Add spacial positions, hub distance and degree information to the nodes.
# tbl_graph <- tbl_graph %>%
#   activate(nodes) %>%
#   mutate(
#     x = x,
#     y = y,
#     hub_dist = replace_na(bfs_dist(root = hub_id), Inf),
#     degree = degree(graph),
#     friends_of_friends = replace_na(local_ave_degree(), 0),
#     cluster = as.factor(group_infomap())
#   )
```


```{r}
DSim <- eisen_cos.sim(deck.matrix)

sub.DSim.1 <- as.matrix(DSim)[1:length(ASZ.rm.codes),1:length(ASZ.rm.codes)]
sub.DSim.2 <- as.matrix(DSim)[(length(ASZ.rm.codes)+1):NROW(DSim),(length(ASZ.rm.codes)+1):NROW(DSim)]
sub.DSim.X <- as.matrix(DSim)[1:length(ASZ.rm.codes),(length(ASZ.rm.codes)+1):NROW(DSim)]

DSim.tbl <- rbind(
  tibble( value = sub.DSim.1[upper.tri(sub.DSim.1)],
          group = "ASZ" ),
  tibble( value = sub.DSim.2[upper.tri(sub.DSim.2)],
          group = "SZ" ),
  tibble( value = sub.DSim.X %>% as.vector(),
          group = "Cross" )
)

DSim.tbl |>
  ggplot(aes(x = value, fill=group)) +
  geom_density() +
  theme(legend.position = "bottom") +
  xlim(c(0,1)) +
DSim.tbl |>
  ggplot(aes(x = value, fill=group)) +
  geom_boxplot() +
  theme(legend.position = "none")
  xlim(c(0,1))
```


```{r}
# DSim.tbl %>%
#   group_by(group) %>%
#   summarise(across(.fns = list(mean = mean, sd = sd, skew = skew), .names = "{col}_{fn}"))
# 
# DSim.tbl %>%
#   ggplot(aes(value, group = group, color = group)) +
#   stat_ecdf()
```
