---
params:
  ind: "00"
  title: "From Curve to Cap"
  description: "Exploring Clustering Algorithms applied to Archetypes of Legends of Runeterra"
title: | 
  `r params$title`
description: |
  `r params$description`
# preview: 
base_url: https://www.llorr-stats.com
author:
  - name: Valentino (Legna) Vazzoler
date: 11-10-2021
output:
 distill::distill_article:
    toc: true
    toc_float: true
    toc_depth: 3
    self_contained: false
citation: false
bibliography: references.bib
draft: TRUE
---

CECACAIDFYAQEAQFAIAQECAPAMBAGBYIBECQCAQCBIAQEAYBAECAEBYCAEBAYOICAEBTMNYEAEAQGJABAMBAKAIEAMFAEAICEUXA
All from EU

CECQCAIDGUAQGAICAECACEQCAQBQEBAFAEAQGDQ7GAZQGAIBAM2ACBADBABACAI6HEAQEBABBIGA
LeYeti

- vS explained the concept of Skill-Cap by looking at the performances/win in the ladder by looking at the differences between Top Legends / DiamondI-IV
But differently for the Skill-Curve they don't look at the WR in function of games but at each MU-WR disparity ( which already big if it goes 2/3% )
They look at the single MU because the meta would easily influence the mean value ( and looking at what I have for PR between the two groups it is an obvious confounder)

Now, their example, Contact Rogue had a diff of 7.5% which is crazily high

So, now it's clearer why there is the problem I asked:
- Because a certain sample size is required also at top MMR  / in addition by taking the games from the start of the "top players" we know we can expect an higher WR because of the relationship between nGames and WR, but then, including games from when they were Plat+ seems wrong because of the definition


https://www.invenglobal.com/articles/15634/vs-zacho-grandmasters-are-not-immune-to-making-poor-judgment-calls-like-running-safety-inspector-in-paladin
- But I don't think any deck reached these kinds of numbers where the improvement is by well over 5% from upper Diamond to top legend. Decks rarely if ever reach a 3% overall matchup improvement.

Podcast info: ep.62 ~28:00

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo       = FALSE,
  eval       = TRUE,
  warning    = FALSE,
  error      = FALSE,
  message    = FALSE,
  comment    = NA,
  R.options  = list(width = 140, digits.secs=6),
  dev.args   = list(bg = 'whitesmoke'),
  fig.align  = 'center',
  fig.width  = 12,
  fig.height = 8,
  # fig.path   = "figures/prefix-"
  fig.path   = glue::glue("images/{params$ind}-"),
  layout     = "l-page",
  preview    = TRUE
)

#' R Option
options(scipen = 999)
source(file.path("C:","LlorR","scripts","lor_main.R" ))
source(file.path("C:","LlorR","scripts","functions","lor_constants.R"))
source(file.path("C:","LlorR","scripts","functions","lor_functions.R"))
xaringanExtra::use_panelset()
```

```{r panelset-style}
xaringanExtra::style_panelset_tabs(
  font_family        = "Helvetica",
  active_foreground  = "white",
  hover_foreground   = "black",
  hover_border_color = "black",
  active_background  = "#007fff"
  )
```

```{r raw-data}
# load DeckDT
LoR.Deck.RMD       <- fread(file.path("C:","LlorR","data","raw","LoR_DECK.csv"),na.strings = c("",NA))

# load Games DT
LoR.Account.RMD <- list.files(path = file.path("C:", "LlorR", "data", "raw"), pattern = glue("^(.*)ACCOUNT(.*)csv$"), full.names = T) |>
  map_dfr(data.table::fread,colClasses = "character",header = T, na.strings = c("", NA), encoding = "UTF-8") |>
  mutate(activeShard = if_else(activeShard %in% c("sea","asia"),"apac",activeShard) ) |>
  mutate(RiotID = glue::glue("{gameName}#{tagLine}")) |>
  distinct(puuid,.keep_all = T)

# load Seasonal
LoR.Seasonal.DT.RMD <- list.files(path = file.path("C:", "LlorR", "data", "raw","games"), pattern = glue("^(.*)Seasonal(.*)csv$"), full.names = T) |>
  map_dfr(data.table::fread,header = T, na.strings = c("", NA), encoding = "UTF-8") |>
  mutate(server = if_else(server %in% c("sea","asia"),"apac",server) )

# load Temp DT
LoR.Temp.DT.RMD <- list.files(path = file.path("C:", "LlorR", "data", "raw","games"), pattern = glue("^(.*)Temp_DT_S12(.*)csv$"), full.names = T) |>
  map_dfr(data.table::fread,header = T, na.strings = c("", NA), encoding = "UTF-8") |>
  mutate(server = if_else(server %in% c("sea","asia"),"apac",server) )

# load Games DT
LoR.Match.DT.RMD <- list.files(path = file.path("C:", "LlorR", "data", "raw"), pattern = glue("^(.*)Match_DT_S12(.*)csv$"), full.names = T) |>
  str_subset(pattern = "Keys",negate = T) |>
  map_dfr(data.table::fread,header = T, na.strings = c("", NA), encoding = "UTF-8") |>
  mutate(server = if_else(server %in% c("sea","asia"),"apac",server) )

# load Games DT
LoR.Diamond.DT.RMD <- list.files(path = file.path("C:", "LlorR", "data", "raw"), pattern = glue("^(.*)Diamond_DT_S12(.*)csv$"), full.names = T) |>
  str_subset(pattern = "Keys",negate = T) |>
  map_dfr(data.table::fread,header = T, na.strings = c("", NA), encoding = "UTF-8") |>
  mutate(server = if_else(server %in% c("sea","asia"),"apac",server) )
```

```{r}
LoR.Seasonal.DT.RMD |>
  filter(game_version == max(game_version) ) |>
  select(match_key,starts_with("puuid")) |>
  pivot_longer(-match_key,values_to = "puuid") |>
  distinct(puuid) |>
  pull() -> puuid_seasonal
```


```{r melt-data}
LoR.Melt.Games.RMD <- LoR.Temp.DT.RMD |>
  bind_rows(LoR.Match.DT.RMD) |>
  bind_rows(LoR.Diamond.DT.RMD) |>
  filter(game_mode == "Constructed") |>
  filter(puuid_1 %in% puuid_seasonal | puuid_2 %in% puuid_seasonal) |>
  distinct(match_key,.keep_all = T) |>
  filter(game_start_time_utc >= as_datetime("2022-02-16 19:00:00") ) |>
  # filter(game_type == "Ranked") |>
  select(-contains("factions")) |>
  rename(playerPuuid_1 = puuid_1, playerPuuid_2 = puuid_2 ) |>
  mutate(opponentPuuid_1 = playerPuuid_2, opponentPuuid_2 = playerPuuid_1 ) |>
  mutate(opponent_deck_code_1 = deck_code_2, opponent_deck_code_2 = deck_code_1 ) |>
  pivot_longer(cols = c(ends_with("_1"),ends_with("_2")),
               names_to = c(".value"),
               names_pattern = "(.*)_[0-9]"
               ) |>
  as.data.table() |>
  # Add Deck data
  left_join(LoR.Deck.RMD, by="deck_code") |>
  rename(playerDeck=archetype) |>
  left_join(
    LoR.Deck.RMD[,.(deck_code,opponentDeck=archetype)],
    by=c("opponent_deck_code"="deck_code")) |>
  # Add Player data
  left_join(LoR.Account.RMD[,.(puuid,playerID=RiotID)]   ,by=c("playerPuuid"="puuid")) |>
  left_join(LoR.Account.RMD[,.(puuid,opponentID=RiotID)] ,by=c("opponentPuuid"="puuid"))
```

```{r}
LoR.Melt.Games.RMD |>
  filter(str_detect(playerDeck,"Galio")) |>
  tabyl(playerDeck) |>
  slice_max(n, n = 5) |>
  pull(playerDeck) -> galio_decks


plot_master_curve <- function(deck,deck_name,lq=0.05,uq=0.95) {
  
  # deck <- galio_decks[1]
  # deck_name <- galio_decks[1]
  # lq = 0.05
  # uq = 0.95
  
  # deck_to_search <- deck

  LoR.Melt.Games.RMD |> 
    filter(game_outcome != "tie") |>
    filter(playerPuuid %in% puuid_seasonal) |>
    filter(playerDeck %in% deck) |>
    summarise(meanWR = mean(game_outcome=="win")) |>
    pull(meanWR) -> mean_wr

  LoR.Melt.Games.RMD |> 
    filter(game_outcome != "tie") |>
    filter(playerDeck %in% deck) |>
    filter(playerPuuid %in% puuid_seasonal) |>
    arrange(playerPuuid,game_start_time_utc) |>
    mutate(game_outcome = (factor(game_outcome) |> as.numeric()-1) ) |>
    # mutate
    group_by(playerPuuid) |>
    mutate(nGames = row_number() ) |>
    arrange(playerPuuid,game_start_time_utc) |>
    mutate(nWin = cumsum(game_outcome)) |>
    ungroup() |>
    mutate(meanWR = nWin/nGames) |>
    group_by(playerPuuid) |>
    slice_max(nGames) |>
    ungroup() |>
    group_by(nGames) |>
    summarise(meanWR = mean(meanWR)) -> data
  
  data |>
    filter( between(nGames, quantile(nGames,lq,names = F), quantile(nGames,uq,names = F) ) ) |>
    ggplot(aes(x = nGames, y = meanWR)) +
    geom_line() +
    geom_smooth(method = "lm", formula = 'y ~ x + I(x^2)', size = 1) +
    geom_hline(yintercept = mean_wr, color="red") +
    labs(x="Total Games",
         y="Win Rate",
         title = glue("{deck_name} - Mastery Curve"),
         caption = glue("Constructed games from Seasonal Players
                        The data under the {lq*100}th percentile and over the {uq*100}th percentile are removed ") ) +
    theme_539() +
    scale_x_continuous(n.breaks = 10) +
    scale_y_continuous(
      n.breaks = 10,
      labels = scales::percent_format(accuracy = 1)
    ) -> plot
  
  ggplot(data, aes(x = nGames)) +
    geom_density(binwidth = 10,color="black",fill="steelblue") +
    scale_x_continuous(n.breaks = 10) +
    scale_y_continuous(
      labels = scales::percent_format(accuracy = 1)
    ) +
    labs(
      title = "#Games Density",
      subtitle = glue("Density Plot of games played with {deck}"),
      x = "#Games"
    ) -> plot_hist
      
    # hist(main=glue("Number of Games with {deck_name}"),breaks=15,xlab = "#Games") -> hist
  
  list("mastery_curve"=plot,
       "histogram"=plot_hist)
  
}

# galio_1 <- plot_master_curve(galio_decks[1],galio_decks[1],lq = 0.05,uq = 0.95)

map(galio_decks, ~plot_master_curve(.x,.x,lq = 0.05,uq = 0.95) )
```

```{r}
deck <- galio_decks[1] 
plots <- plot_master_curve(deck,deck,lq = 0.05,uq = 0.95)
ggsave(plot = plots$mastery_curve,filename = "mastery_curve_galio_1.png", width = 12,height = 8  )
ggsave(plot = plots$histogram,filename = "games_galio_1.png", width = 12,height = 8  )

deck <- galio_decks[2] 
plots <- plot_master_curve(deck,deck,lq = 0.05,uq = 0.95)
ggsave(plot = plots$mastery_curve,filename = "mastery_curve_galio_2.png", width = 12,height = 8  )
ggsave(plot = plots$histogram,filename = "games_galio_2.png", width = 12,height = 8  )

deck <- galio_decks[3] # Braum Galio
plots <- plot_master_curve(deck,deck,lq = 0.05,uq = 0.95)

ggsave(plot = plots$mastery_curve,filename = "mastery_curve_galio_3.png", width = 12,height = 8  )
ggsave(plot = plots$histogram,filename = "games_galio_3.png", width = 12,height = 8  )

deck <- galio_decks[4] 
plots <- plot_master_curve(deck,deck,lq = 0.05,uq = 0.95)
ggsave(plot = plots$mastery_curve,filename = "mastery_curve_galio_4.png", width = 12,height = 8  )
ggsave(plot = plots$histogram,filename = "games_galio_4.png", width = 12,height = 8  )
```


```{r mastery-timeline}
# getCardCode("Concurrent Timelines") # 04PZ010

LoR.Deck.RMD |>
  filter(str_detect(champs,"Gnar")) |>
  filter(str_detect(cards,"(04PZ010\\s?){2,3}")) |>
  pull(deck_code) -> gnar_timeline_decks

LoR.Melt.Games.RMD |> 
  filter(game_outcome != "tie") |>
  filter(playerPuuid %in% puuid_seasonal) |>
  filter(deck_code %in% gnar_timeline_decks) |>
  summarise(meanWR = mean(game_outcome=="win")) |>
  pull(meanWR) -> gnar_mean_wr

LoR.Melt.Games.RMD |> 
  filter(game_outcome != "tie") |>
  filter(deck_code %in% gnar_timeline_decks) |>
  filter(playerPuuid %in% puuid_seasonal) |>
  arrange(playerPuuid,game_start_time_utc) |>
  mutate(game_outcome = (factor(game_outcome) |> as.numeric()-1) ) |>
  # mutate
  group_by(playerPuuid) |>
  mutate(nGames = row_number() ) |>
  arrange(playerPuuid,game_start_time_utc) |>
  mutate(nWin = cumsum(game_outcome)) |>
  ungroup() |>
  mutate(meanWR = nWin/nGames) |>
  group_by(playerPuuid) |>
  slice_max(nGames) |>
  ungroup() |>
  group_by(nGames) |>
  summarise(meanWR = mean(meanWR)) |>
  filter( between(nGames, quantile(nGames,0.05,names = F), quantile(nGames,0.90,names = F) ) ) |>
  ggplot(aes(x = nGames, y = meanWR)) +
  geom_line() +
  geom_smooth(method = "lm", formula = 'y ~ x + I(x^2) + I(x^3)', size = 1) +
  geom_hline(yintercept = gnar_mean_wr, color="red") +
  labs(x="Total Games",
       y="Win Rate",
       title="Cavemen Time - Mastery Curve",
       subtitle = "Mastery Curve on Gnar Timelines decks",
       caption = glue("Constructed games from Seasonal Players
                      The data under the 5th percentile and over the 90th percentile are removed ") ) +
  theme_539() +
  scale_x_continuous(n.breaks = 10) +
  scale_y_continuous(
    n.breaks = 10,
    labels = scales::percent_format(accuracy = 1)
  ) -> plot_cavemen_time
  
ggsave(plot = plot_cavemen_time,filename = "mastery_curve_timeline.png", width = 12,height = 8  )

LoR.Melt.Games.RMD |>
  filter(game_outcome != "tie") |>
  filter(deck_code %in% gnar_timeline_decks) |>
  # filter(playerDeck %in% galio_decks[1]) |>
  filter(playerPuuid %in% puuid_seasonal) |>
  mutate(Date = as_date(game_start_time_utc)) |>
  pull(Date) |>
  summary()
```

