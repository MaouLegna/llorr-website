---
params:
  ind: "MR028"
  patch: "Patch 2.17 - Week 1"
  title: "THE META REPORT NAME IS TOO LONG, TOO DAMN LONG (nÂ°27)"
  description: "Patch next week. So that Sion won't dominate anymore... So that Sion won't dominate anymore, right?"
  cardlurl: "https://dd.b.pvp.net/latest/set5/en_us/img/cards/05SI015-full.png"
  prev:  "2021-10-06 21:00:00" #UTC tz / 'current' previous week start
  start: "2021-10-13 21:00:00" #UTC tz / 'current' week start
  end:   "2021-10-20 21:00:00" #UTC tz / 'current' week end
  skip:  3400000  # ~ Patch 2.16

title: | 
  `r params$title`
description: |
  `r params$patch` - `r params$description`
base_url: https://www.llorr-stats.com
preview: |
  `r params$cardlurl`
author:
  - name: Valentino (Legna) Vazzoler
date: 10-13-2021
output:
 distill::distill_article:
    toc: true
    toc_float: true
    toc_depth: 3
    self_contained: false
citation: false
draft: TRUE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  eval = TRUE,
  warning = FALSE,
  error = FALSE,
  message = FALSE,
  comment = NA,
  R.options = list(width = 140,
                   digits.secs=6),
  dev.args = list(bg = 'transparent'), # make graphics with transparent background
  fig.align = 'center',
  fig.width=12,
  fig.height=8,
  engine.path = list(
    python = 'C:/anaconda/'   # -> use_python("C:/anaconda/")
  ),
  #'distill options
  layout="l-body-outset",
  preview=FALSE
)

#' R Option
options(scipen = 999)
source(file.path("C:","LlorR","scripts","lor_main.R" ))
xaringanExtra::use_panelset()
```

```{r panelset-style}
xaringanExtra::style_panelset_tabs(
  font_family = "Helvetica",
  active_foreground = "white",
  hover_foreground = "black",
  hover_border_color = "black",
  active_background = "#007fff"
  )
```

```{r raw-data}
# skip.dt <-fread(file.path("C:","LlorR","data","raw","skip_row.csv")  )
# skip.dt

#' load gameDT
#'############
file.DT <- file.path("C:","LlorR","data","raw","LoR_MatchDT.csv")
header        <- fread(file.DT, header = FALSE, na.strings = c("",NA), nrows = 1, stringsAsFactors = FALSE)
LoR.Match.RMD <- fread(file.DT, header = FALSE, na.strings = c("",NA), skip = params$skip )
colnames(LoR.Match.RMD) <- unlist(header,use.names = F)

#' load Account
#'#############
LoR.Account.RMD <- fread(file.path("C:","LlorR","data","raw","LoR_ACCOUNT.csv"),
                         header=T, na.strings = c("",NA), encoding = 'UTF-8') |>
  mutate( RiotID = sprintf("%s#%s",gameName,tagLine) )

#' load DeckDT
#'############
LoR.Deck        <- fread(file.path("C:","LlorR","data","raw","LoR_DECK.csv"),na.strings = c("",NA))
```

```{r prepare-data}
#' Melt tbl
#'#########
LoR.Melt.Matches.RMD <- LoR.Match.RMD |>
  filter( game_type=="Ranked" ) |>
  filter( game_start_time_utc >= as.POSIXct(params$start, tz = "UTC") & game_start_time_utc < as.POSIXct(params$end, tz = "UTC") ) |>
  select( -ends_with("_3"),-ends_with("_4")  ) |>
  left_join(LoR.Deck[,.(deck_code,playerDeck_1=archetype)],  by=c("deck_code_1"="deck_code")) |>
  left_join(LoR.Deck[,.(deck_code,opponentDeck_1=archetype)],by=c("deck_code_2"="deck_code")) |>
  rename( playerPuuid_1 = puuid_1, playerPuuid_2 = puuid_2 ) |>
  mutate( playerDeck_2 = opponentDeck_1, opponentDeck_2 = playerDeck_1, opponentPuuid_1 = playerPuuid_2, opponentPuuid_2 = playerPuuid_1 ) |>
  pivot_longer(cols = c(ends_with("_1"),ends_with("_2")),
               names_to = c(".value"),
               names_pattern = "(.*)_[0-9]"
               ) |>
  #' finish 'process' data
  left_join(LoR.Account.RMD[,.(puuid,playerID=RiotID)]   ,by=c("playerPuuid"="puuid")) |>
  left_join(LoR.Account.RMD[,.(puuid,opponentID=RiotID)] ,by=c("opponentPuuid"="puuid")) |>
  left_join(LoR.Deck |> select(!archetype),by=c("deck_code","factions"))
```

```{r get-muWR}
MUtbl <- LoR.Melt.Matches.RMD |>
  filter(game_outcome!="tie") |>
  select( playerDeck,opponentDeck,game_outcome,server ) |>
  group_by(playerDeck,opponentDeck) |>
  summarise( muWin   = sum(game_outcome=="win"),
             muGames = n(),
             muWR=mean(game_outcome=="win") ) |>
  as.data.table()

MUtbl[, c("LCI","UCI") := binom.confint(muWin,muGames,0.95,methods="exact")[5:6] ]
MUtbl[, okCI:=(!between(0.50,LCI,UCI)) ]
MUtbl[, direction:=ifelse(muWR>0.50,"POS","NEG")  ]

MUtbl <- MUtbl |>
  mutate( CI := glue("({percent(LCI,accuracy = 0.1)} - {percent(UCI,accuracy = 0.1)})" ) )
```

```{r process-winRate}
WR.DT <- LoR.Melt.Matches.RMD |>
  filter(game_outcome!="tie") |>
  select( playerDeck,opponentDeck,game_outcome ) |>
  group_by(playerDeck) |>
  summarise( nWin   = sum(game_outcome=="win"),
             nGames = n(),
             WR=mean(game_outcome=="win")
            ) |>
  ungroup() |>
  mutate( playrate = nGames/sum(nGames) )

WR.DT.Reg <- LoR.Melt.Matches.RMD |>
  filter(game_outcome!="tie") |>
  select( playerDeck,opponentDeck,game_outcome,server ) |>
  group_by(server,playerDeck) |>
  summarise(
    nWin   = sum(game_outcome=="win"),
    nGames = n(),
    WR=mean(game_outcome=="win"),
    ) |>
  ungroup() |>
  group_by(server) |>
  mutate( sumGames = sum(nGames), regPlayrate = nGames/sumGames ) |>
  left_join(WR.DT[,c("playerDeck","playrate")],by="playerDeck") 
```

# Match Ups

```{r process-tableChampion}
CC.tableByReg <- LoR.Melt.Matches.RMD |>
  tabyl(playerDeck,server) |>
  adorn_percentages("col")

CC.table <- LoR.Melt.Matches.RMD |>
  tabyl(playerDeck, show_na = F) |>
  rename_all(~c("playerDeck","n","freq")) |>
  left_join(CC.tableByReg,by="playerDeck")
```

```{r get-WR-Top10}
mu <- 15

TopCC <- CC.table |> 
  arrange(desc(freq)) |> 
  {\(x) slice_head(x,n = mu)}() |> 
  select(playerDeck) |> 
  pull()

WRTop10 <- MUtbl[ playerDeck %in% TopCC & opponentDeck %in% TopCC, ]
# WRTop10 <- setorderv(WRTop10, c("playerDeck","opponentDeck"), c(1,1))
```

::: l-page
::::: {.panelset}
::: {.panel}

## Match-up Grid {.panel-name}

The win rates on the grid are among the `r mu` most played champion combination.

```{r prepare-flex}
require(flextable)
require(officer)

big_border   = fp_border(color="darkgray", width = 2)
small_border = fp_border(color="gray", width = 1)

dummy_fun <- function(x){
  ifelse( !is.na(x),sprintf( "%.0f%%", x*100 ),NA )
}
```

```{r prepare-flex-grid}
grid <- matrix(WRTop10$muWR, nrow = mu, ncol = mu, byrow = T)
diag(grid) <- NA

colnames(grid) <- TopCC
colourer <- col_numeric(
  palette = c(
    "#D73027", # red
    # "#f9ccac", # red/orange
    "white",
    # "#e3eaa7", # green
    "#1A9850" # darker green
    ),
  domain = c(0, 1))

funs <- setNames(rep(list(dummy_fun), mu), TopCC)
```

```{r print-flex, fig.width=24, fig.height=16}
ft <- grid |> 
  as_tibble() |>
  # mutate(across(everything(),~scales::percent(.x, accuracy = 0.1 ))) |>
  add_column(TopCC,.before = TopCC[1]) |>
  rename("MatchUps"="TopCC") |>
  flextable::flextable( ) |> 
  theme_vanilla( ) |>
  # theme_booktabs(bold_header = TRUE) |> 
  flextable::align(align = "center", part = "all") |>
  flextable::bg(
    bg = colourer,
    j = ~ . -MatchUps,
    part = "body") |>
  {\(x) border_remove(x = x)}() |>
  border_outer(part="all", border = big_border ) |>
  border_inner_h(part="all", border = small_border ) |>
  border_inner_v(part="all", border = small_border ) |>
  set_formatter(values = funs) |>
  fontsize(size = 8, part = "header") |>
  fontsize(j=1, size = 8) |>
  bg(part = "header", bg = "white"  ) |>
  bg(j = 1, bg = "white"  ) |>
  height(height = .08) %>% 
  hrule(rule = "exact", part = "body") %>% 
  width(width =  .08)
  # set_table_properties(layout = "fixed")
  # autofit()

ft

save_as_image(ft,
              path = glue::glue("./images/meta-report/{params$ind}-MU.png"),
              zoom = 5,
              expand = 20,
              webshot = "webshot2") |> invisible()
```

:::